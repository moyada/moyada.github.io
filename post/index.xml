<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>  | 不睡觉的猫头鹰</title>
    <link>https://moyada.github.io/post/</link>
      <atom:link href="https://moyada.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description> </description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><copyright>© 2017 - 2020 moyada</copyright><lastBuildDate>Wed, 29 Apr 2020 22:10:40 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=true) shape:circle]</url>
      <title> </title>
      <link>https://moyada.github.io/post/</link>
    </image>
    
    <item>
      <title>谷歌翻译 API 调用</title>
      <link>https://moyada.github.io/post/google-translate/</link>
      <pubDate>Wed, 29 Apr 2020 22:10:40 +0800</pubDate>
      <guid>https://moyada.github.io/post/google-translate/</guid>
      <description>&lt;h2 id=&#34;调试接口&#34;&gt;调试接口&lt;/h2&gt;
&lt;p&gt;由于时常使用
&lt;a href=&#34;https://translate.google.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谷歌翻译&lt;/a&gt;，就想着把接口做成服务调用，省去登陆网页的麻烦。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要更好的服务可以使用谷歌云服务 &lt;a href=&#34;https://cloud.google.com/translate&#34;&gt;https://cloud.google.com/translate&lt;/a&gt; ，每月可获赠价值不超过 $10 的免费用量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用开发者工具调试页面接口拿到了翻译调用的接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://translate.google.com/translate_a/single?client=webapp&amp;amp;sl=zh-CN&amp;amp;tl=en&amp;amp;hl=zh-CN&amp;amp;dt=at&amp;amp;dt=bd&amp;amp;dt=ex&amp;amp;dt=ld&amp;amp;dt=md&amp;amp;dt=qca&amp;amp;dt=rw&amp;amp;dt=rm&amp;amp;dt=sos&amp;amp;dt=ss&amp;amp;dt=t&amp;amp;otf=1&amp;amp;ssel=5&amp;amp;tsel=5&amp;amp;xid=1791807%2C45625687%2C45626150&amp;amp;kc=11&amp;amp;tk=718445.806187&amp;amp;q=%E4%BD%A0%E5%A5%BD&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是在调试发现，接口中带了个签名参数 &lt;code&gt;tk&lt;/code&gt;，通过查找 js 源文件，在 
&lt;a href=&#34;https://translate.google.com/translate/releases/twsfe_w_20200420_RC00/r/js/translate_m_zh-CN.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;translate_m_zh-CN.js&lt;/a&gt; 这里发现了相关痕迹，但是解析起来太费劲了。。。&lt;/p&gt;
&lt;h2 id=&#34;调用模块&#34;&gt;调用模块&lt;/h2&gt;
&lt;p&gt;这个时候检索的能力就体验出来了，通过在 Google 里的一顿操作，得知 &lt;code&gt;Node&lt;/code&gt; 里有相关使用库，它将 tk 的获取函数提取出来了。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;npm install --save google-translate-api&lt;/code&gt; 安装模块到本地，修改源代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;google-translate-api&lt;/code&gt; 和 &lt;code&gt;google-translate-token&lt;/code&gt; 下的 &lt;code&gt;index.js&lt;/code&gt; 里的 &lt;b&gt;translate.google.com&lt;/b&gt; 替换为 &lt;b&gt;translate.google.cn&lt;/b&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;google-translate-api/index.js&lt;/code&gt; 中请求参数 &lt;code&gt;data&lt;/code&gt; 的数据 &lt;b&gt;client: &#39;gtx&#39;&lt;/b&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;修改完成后便在国内也能调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const translate = require(&#39;google-translate-api&#39;);
 
translate(&#39;您好&#39;, {to: &#39;en&#39;}).then(res =&amp;gt; {
    console.log(res.text);
}).catch(err =&amp;gt; {
    console.error(err);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中使用可以这样方式调用 node&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os

p = os.popen(&#39;node translate.js %s&#39; % value)
print(p.readlines()[0])

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://www.zhihu.com/question/47239748&#34;&gt;https://www.zhihu.com/question/47239748&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Spring Bean 生命周期简单分析</title>
      <link>https://moyada.github.io/post/spring-bean/</link>
      <pubDate>Sat, 28 Mar 2020 14:19:35 +0800</pubDate>
      <guid>https://moyada.github.io/post/spring-bean/</guid>
      <description>&lt;p&gt;容器是 Spring 设计中一个核心组件，它负责管理 Bean 实例，并提供了接口 &lt;code&gt;BeanFactory&lt;/code&gt; 使用。&lt;/p&gt;
&lt;p&gt;网上对这个有太多分析的文章了，但大多繁琐不堪，不易新手理解，这里就只对关键步骤做个简单分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章中所研究的 Spring 版本为 5.1.4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;p&gt;Bean 的创建是其生命周期中最复杂的一步，这边对 &lt;code&gt;getBean&lt;/code&gt; 方法跟踪，进入到了 &lt;code&gt;AbstractBeanFactory&lt;/code&gt; 的 &lt;code&gt;doGetBean&lt;/code&gt; 方法，该方法的内容就是构造 Bean 的主要流程，这里只将关键的步骤提取出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    final String beanName = transformedBeanName(name); // 解析 Bean 名称
    
    Object bean;

    Object sharedInstance = getSingleton(beanName); // 1. 获取 Bean 实例或构造工厂
    if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
        // 这里主要是对构造工厂进行创建实例
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    } else {
        BeanFactory parentBeanFactory = getParentBeanFactory();
        // 检查父级构造工厂是否包含实例，是则交由父级工厂创建返回
        ...

        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
        // 初始化当前 Bean 所依赖的 Bean
        ...


        // 2. 根据 Bean 的类型选择构造方式，这里分析单例模式
        sharedInstance = getSingleton(beanName, () -&amp;gt; {
            try {
                return createBean(beanName, mbd, args); // 具体构造实例的逻辑
            }
            catch (BeansException ex) {
                destroySingleton(beanName);
                throw ex;
            }
        });
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }

    // 类型检查和转换
    ...
    return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取单例&#34;&gt;获取单例&lt;/h3&gt;
&lt;p&gt;其实整个流程十分复杂，这里也能够看出 Spring 的严谨性。首先跟进 &lt;code&gt;1. getSingleton()&lt;/code&gt;，它的逻辑虽然简单，但其实是对解决循环依赖问题非常关键的一步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
                ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有两个解决循环引用的要点，这里先知道就行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一是 &lt;code&gt;isSingletonCurrentlyInCreation(beanName)&lt;/code&gt;，这是标记了一个 Bean 正处于构造阶段中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一个是 &lt;code&gt;this.singletonFactories.get(beanName)&lt;/code&gt;，这里返回的是 Bean 实例的构造工厂，需要在其他位置通过调用 &lt;code&gt;addSingletonFactory&lt;/code&gt; 加入进来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;创建-bean-实例&#34;&gt;创建 Bean 实例&lt;/h3&gt;
&lt;p&gt;创建实例调用的内容非常多，这边主要讲下构造、注入、处理器的过程。&lt;/p&gt;
&lt;p&gt;首先看到 &lt;code&gt;2. getSingleton()&lt;/code&gt;，这里需要关注的只有这几步，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beforeSingletonCreation&lt;/code&gt; 和 &lt;code&gt;afterSingletonCreation&lt;/code&gt; 分别为标记 Bean 在创建中和移除标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用前面的 &lt;code&gt;createBean&lt;/code&gt; 创建实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;addSingleton&lt;/code&gt; 则是将创建的实例加入到容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
    beforeSingletonCreation(beanName);
    try {
        singletonObject = singletonFactory.getObject();
        newSingleton = true;
    }
    finally {
        afterSingletonCreation(beanName);
    }
    if (newSingleton) {
        addSingleton(beanName, singletonObject);
    }
    return singletonObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继续分析 &lt;code&gt;createBean&lt;/code&gt;，其实里面主要是委托了 &lt;code&gt;doCreateBean&lt;/code&gt; 方法来创建实例，解决循环引用的关键点就是这里的 &lt;code&gt;addSingletonFactory&lt;/code&gt;，使得 Bean 在创建阶段就提供依赖引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
        throws BeanCreationException {

    // 创建实例，会涉及构造器注入
    BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args);
    final Object bean = instanceWrapper.getWrappedInstance();

    // 缓存实例引用
    boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
            isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
    }

    Object exposedObject = bean;

    // 初始化实例
    populateBean(beanName, mbd, instanceWrapper);
    exposedObject = initializeBean(beanName, exposedObject, mbd);

    return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;当 Bean 在 &lt;code&gt;doCreateBean&lt;/code&gt; 中完成了实例的创建，接着就会对实例进行&lt;code&gt;属性注入&lt;/code&gt;、&lt;code&gt;调用初始化方法&lt;/code&gt;、&lt;code&gt;执行前置/后置处理器&lt;/code&gt;，而后将实例加入到 Spring 容器中，就完成了一个 Bean 的创建阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个过程也可以通过 &lt;code&gt;AutowireCapableBeanFactory#initializeBean&lt;/code&gt; 来完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;销毁&#34;&gt;销毁&lt;/h2&gt;
&lt;p&gt;一个 Bean 实例的销毁可以随着 Spring 生命周期结束而触发，也可以通过调用 &lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt; 中的 &lt;code&gt;destroyBean&lt;/code&gt; 来进行。&lt;/p&gt;
&lt;p&gt;他将构造一个 &lt;code&gt;DisposableBeanAdapter&lt;/code&gt; 来执行不同实例的销毁流程，这里的代码流程清晰明了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void destroy() {
    for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
        processor.postProcessBeforeDestruction(this.bean, this.beanName); // 执行前置销毁处理器
    }

    // 执行实现 DisposableBean 的销毁方法
    ((DisposableBean) this.bean).destroy();

    // 执行自定义销毁方法
    invokeCustomDestroyMethod(this.destroyMethod);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>爬虫与反爬虫</title>
      <link>https://moyada.github.io/post/scrapy/</link>
      <pubDate>Mon, 23 Mar 2020 00:28:42 +0800</pubDate>
      <guid>https://moyada.github.io/post/scrapy/</guid>
      <description>&lt;p&gt;爬虫与反爬虫是个在软件开发行业里一直存在的斗争。爬虫，一般常见的有窃取同行数据、分析行业数据、恶意攻击等，最终都是以牟利为目的。为了防止爬虫，就诞生了反爬虫技术，通过识别非法操作与正常操作来做到拦截爬虫请求。&lt;/p&gt;
&lt;p&gt;下面就来分析一下这些常见的爬虫与反爬虫都有哪些手段。&lt;/p&gt;
&lt;h2 id=&#34;爬虫&#34;&gt;爬虫&lt;/h2&gt;
&lt;h3 id=&#34;api&#34;&gt;API&lt;/h3&gt;
&lt;p&gt;一般情况下，爬虫都是直接调用网站内请求数据的接口，这是成本最低的方式。通过分析接口请求规则，组装成 HTTP 请求，模拟正常用户操作。&lt;/p&gt;
&lt;p&gt;常见的 API 有&lt;code&gt;数据型&lt;/code&gt;和&lt;code&gt;操作型&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如通过某之家的接口 &lt;a href=&#34;https://car.m.autohome.com.cn/ashx/car/GetModelConfigNew3.ashx?seriesId=18&#34;&gt;https://car.m.autohome.com.cn/ashx/car/GetModelConfigNew3.ashx?seriesId=18&lt;/a&gt; ，通过接口可以获取到市场上车型参数的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而某东的登陆接口 &lt;a href=&#34;https://passport.jd.com/uc/loginService&#34;&gt;https://passport.jd.com/uc/loginService&lt;/a&gt; ，操作后保存 session，便可以在后面操作其他电商接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过这些接口的使用，就出现了数据分析工具，黄牛抢购，轰炸机脚本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;模拟浏览器&#34;&gt;模拟浏览器&lt;/h3&gt;
&lt;p&gt;在一些网站对接口升级防护后，可能原有的方式就失效了，这个时候再尝试分析请求接口就可能徒劳无功。但是，通过模拟正常用户操作的话，那不是又能够越过防护了，这时模拟浏览器手段的爬虫开始流行起来。&lt;/p&gt;
&lt;p&gt;这类爬虫手段可以做到像手工操作一样模拟，登陆、验证码、获取网页元素，为了提高效率还可以设置禁止加载图片和 css。&lt;/p&gt;
&lt;p&gt;常用的工具有 &lt;code&gt;Python&lt;/code&gt; 的 
&lt;a href=&#34;https://www.selenium.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;selenium&lt;/a&gt; 和 
&lt;a href=&#34;https://miyakogi.github.io/pyppeteer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pyppeteer&lt;/a&gt;，两者都可以很方便的操作网页元素，前者是市面上相对成熟的爬虫工具，&lt;/p&gt;
&lt;h3 id=&#34;代理池&#34;&gt;代理池&lt;/h3&gt;
&lt;p&gt;上述的爬虫方式都是直接通过本机请求的，如果网站对来访的请求有流量控制策略，那么当请求过于频繁时，将可能被限制访问。&lt;/p&gt;
&lt;p&gt;这时可以通过 &lt;code&gt;匿名代理&lt;/code&gt; 的手段来隐藏真实 ip，通常是使用 ip 代理池来实现，这个代理池可以是自身维护的也可以是第三方的付费服务，每次请求都从这个 ip 代理池中获取 ip 代理操作，这样网站收集到的请求地址就是代理的 ip。&lt;/p&gt;
&lt;h2 id=&#34;反爬虫&#34;&gt;反爬虫&lt;/h2&gt;
&lt;h3 id=&#34;header-拦截&#34;&gt;Header 拦截&lt;/h3&gt;
&lt;p&gt;在网站的目标访问用户可预知的情况下，可以设置一些 Header、User-Agent、Cookie 来简单拦截非法请求。&lt;/p&gt;
&lt;p&gt;但是这种手段十分容易被攻破，只需通过抓取正常请求信息进行解析，再对爬虫请求配置请求头就可以模拟正常用户操作。&lt;/p&gt;
&lt;h3 id=&#34;验证码&#34;&gt;验证码&lt;/h3&gt;
&lt;p&gt;为了防止爬虫的大量请求影响网站可用性，通常会对一些关键接口增加验证码校验，比如字符验证码、问答验证码、滑动验证码、图形验证码。&lt;/p&gt;
&lt;p&gt;有些网站只是在接口外增加了验证码的保护，但爬虫不是像正常用户访问浏览器来请求的，而是绕过了验证码直接请求业务接口，所以需要将验证码与接口绑定在一起使用。&lt;/p&gt;
&lt;h3 id=&#34;数据加密&#34;&gt;数据加密&lt;/h3&gt;
&lt;p&gt;现在的网站为了防止爬虫，还会对页面数据进行混淆，直接返回 html 代码或使用 css 渲染数据，增加爬虫的成本。&lt;/p&gt;
&lt;p&gt;有的网站还会对一些关键接口的进行数据加密或者通信协议加密，需要动态跟踪加密过程来破解。这样使得爬虫分析接口变得几乎不可能，但是却避免不了通过模拟浏览器的操作。&lt;/p&gt;
&lt;h3 id=&#34;频次拦截&#34;&gt;频次拦截&lt;/h3&gt;
&lt;p&gt;在对爬虫敏感的网站，会对请求数据进行收集分析，通过识别爬虫行为来拦截请求，通常使用 &lt;code&gt;滑动窗口&lt;/code&gt; 对归类的请求进行统计。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ip 代理技术就是为了防止请求被拦截的匿名手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通常情况下，为了做到高效的反爬虫，会将各个反爬虫手段结合使用，有些还会反向分析爬虫工具针对性拦截。&lt;/p&gt;
&lt;p&gt;然而，再完善的防御，还是会有被突破的可能，这一切都是成本的博弈。只有当爬虫行为的 ROI 远远低于预期时，那么反爬虫就是成功的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是我的某宝下单脚本，由于该网站对交易请求做了加密，还在 selenium 做了很大功夫的防爬虫，于是便使用了能应对现有防御的 pyppeteer &lt;a href=&#34;https://github.com/moyada/auto-order&#34;&gt;https://github.com/moyada/auto-order&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>第五届中间件性能挑战赛</title>
      <link>https://moyada.github.io/post/middleware-competition-5/</link>
      <pubDate>Sun, 08 Sep 2019 19:57:23 +0000</pubDate>
      <guid>https://moyada.github.io/post/middleware-competition-5/</guid>
      <description>&lt;p&gt;今年参与了阿里巴巴举办的
&lt;a href=&#34;https://tianchi.aliyun.com/competition/entrance/231714/introduction&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;中间件性能挑战赛&lt;/a&gt;，并且有幸进入到了复赛，虽然后期由于其他原因没法专心参与，不过通过这次比赛也让我在技术上收获了不少，这边小小的做下本次比赛的总结。&lt;/p&gt;
&lt;h2 id=&#34;初赛自适应负载均衡的设计实现&#34;&gt;初赛：《自适应负载均衡的设计实现》&lt;/h2&gt;
&lt;h3 id=&#34;赛题分析&#34;&gt;赛题分析&lt;/h3&gt;
&lt;p&gt;初赛的题目是在 
&lt;a href=&#34;http://dubbo.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dubbo&lt;/a&gt; 之上进行的插件开发，对参与者对于 Dubbo 的调用过程有一定的要求。官方在 gateway 端提供了 CallbackListenerImpl、TestClientFilter、UserLoadBalance 供开发。在 provider 端提供了 CallbackServiceImpl、TestRequestLimiter、TestServerFilter 供开发。&lt;/p&gt;
&lt;p&gt;将这些组件结合起来就形成了基本的调用链路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/adaptive-loadbalance.png&#34; alt=&#34;adaptive-loadbalance&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;provider 在接收请求大于处理线程池大小的时候，将会执行拒绝策略 AbortPolicyWithReport，并将线程栈信息以日志文件输出。这无疑增加了服务端的压力，那么就需要让 provider 在 TestRequestLimiter 进行限流，在剩余线程数量不足时拒绝进来的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要完成自适应的负载均衡，那么就需要由 provider 端将权重推送至 gateway，这项工作通过 CallbackServiceImpl 和 CallbackListenerImpl 来完成。但是传输的数据为字符串，不包含 provider 标识，这时就需要能够获取 provider 的服务地址，连带指标推送给 gateway。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gateway 接收到请求时选择性能最优 provider，当所有 provider 压力均满时直接拒绝请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;设计与实现&#34;&gt;设计与实现&lt;/h3&gt;
&lt;h4 id=&#34;provider-拒绝服务&#34;&gt;provider 拒绝服务&lt;/h4&gt;
&lt;p&gt;通过分析 &lt;code&gt;AllChannelHandler&lt;/code&gt; 的源码发现，provider 在通过 Filter 后才会使用线程池处理请求，为了不让服务进入拒绝策略，就需要在线程池不足时利用 Filter 拒绝他。官方是允许使用 SPI 的，那么可根据 &lt;code&gt;WrappedChannelHandler&lt;/code&gt; 的代码，从 &lt;code&gt;DataStore&lt;/code&gt; 里获取所使用的线程池，提取出线程池最大线程数，在请求前后进行计数，拦截超出能力的请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class WrappedChannelHandler implements ChannelHandlerDelegate {

    public WrappedChannelHandler(ChannelHandler handler, URL url) {
        this.handler = handler;
        this.url = url;
        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class)
        		.getAdaptiveExtension().getExecutor(url);

        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;
        if (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) {
            componentKey = Constants.CONSUMER_SIDE;
        }
        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();
        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);
    }

...
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过了这一层拦截，分数就已经明显上去了，但是由于 provider 的能力各不相同，还需要通过计算权重进行请求分发。&lt;/p&gt;
&lt;h4 id=&#34;数据通信&#34;&gt;数据通信&lt;/h4&gt;
&lt;p&gt;当消费方与多个服务方都需要进行通信时，能够唯一确定数据的来源是关键，还是通过读源码，我发现能够从服务 URL 中获取到主机地址和端口号。在 provider 端，自定义暴露监听器保存系统的地址。在 gateway 端，自定义引用监听器将 URL 与地址进行一一映射。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// gateway

public class InvokerMapperListener implements InvokerListener {

private static final Map&amp;lt;URL, String&amp;gt; addressMapper = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Override
    public void referred(Invoker&amp;lt;?&amp;gt; invoker) throws RpcException {
        URL url = invoker.getUrl();
        String address = getAddress(url);

	addressMapper.put(url, address);
    }
}

// provider

public class ThreadPoolExporterListener implements ExporterListener {

    @Override
    public void exported(Exporter&amp;lt;?&amp;gt; exporter) throws RpcException {
	if (Context.ADDRESS != null) {
		return;
	}

	URL url = exporter.getInvoker().getUrl();
        Context.ADDRESS = getAddress(url);
    }
}

public static String getAddress(URL url) {
    String ip = url.getParameter(Constants.BIND_IP_KEY);
    String port = url.getParameter(Constants.BIND_PORT_KEY);
    return ip + &amp;quot;:&amp;quot; + port;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通信功能算是完成了，这时可以直接使用前面 provider 获取到的线程池大小作为权重，但是由于服务能力是动态变化的，为了达到更好的效果还需要进一步改进。&lt;/p&gt;
&lt;h4 id=&#34;动态负载&#34;&gt;动态负载&lt;/h4&gt;
&lt;p&gt;根据评测代码可知，消费服务在程序内部使用了 &lt;code&gt;Semaphore&lt;/code&gt; 对请求进行了拦截，实际可容纳的请求小于线程数，并且并发数随着时间也在发生变化。&lt;/p&gt;
&lt;p&gt;如果单位时间内接收的请求数大于实际并发数时，则多余的请求将会被置为等待状态。当请求数持续大于并发数时，会导致请求堆积造成大量超时。因此在 Dubbo 中有个超时检测机制 &lt;code&gt;org.apache.dubbo.remoting.exchange.support.DefaultFuture##TIME_OUT_TIMER&lt;/code&gt;，这是一个用于中止任务的时间轮，当一个请求进入执行阶段时，它将会被放入时间轮，在一定时间后结束请求返回错误信息。&lt;/p&gt;
&lt;p&gt;因此需使得请求在时间轮触发之前执行，这样才能保证不会造成异常响应。在这里我还是使用到了前面获取的线程池，由于线程在线程池中空闲的状态为 &lt;code&gt;WAITING&lt;/code&gt; 或 &lt;code&gt;TIMED_WAITING&lt;/code&gt;，在执行过程中工作线程的状态可能为 &lt;code&gt;RUNNABLE&lt;/code&gt;、&lt;code&gt;BLOCKED&lt;/code&gt;、&lt;code&gt;WAITING&lt;/code&gt;、&lt;code&gt;TIMED_WAITING&lt;/code&gt;，空闲线程与工作线程存在状态重叠，因而无法将 &lt;code&gt;getActiveCount&lt;/code&gt; 用作并发数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/thread_state.png&#34; alt=&#34;thread_state&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此在执行阶段 Filter 前后对当前线程进行标记，并放入一个 placeHolder 中保存，在退出 Filter 时移除标记。由此一来 placeHolder 中就只存在工作中的线程，在除去 &lt;code&gt;BLOCKED&lt;/code&gt; 和 &lt;code&gt;WAITING&lt;/code&gt; 状态的线程即为并发数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了避免并发冲突影响效率，采用无锁编程，预先创建好数组，利用线程id作为下标指定标记元素位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在得到实际并发数后，再通过与 cpu核心数、cpu频率 进行计算得出权重值，定时的发送给 gateway 用于选择最优 provider。&lt;/p&gt;
&lt;p&gt;gateway 将收到并发数作为负载均衡还远远不够，如果一个服务由于机器资源不足、网络故障等原因也将会导致请求异常，因此请求耗时也是一个考量负载的指标。由于网络消耗的存在，则在 gateway 端做请求耗时的收集，将并发数与耗时进行结合完成负载均衡策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/adaptive-loadbalance-architecture.png&#34; alt=&#34;adaptive-loadbalance-architecture&#34; title=&#34;最终架构图&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;复赛实现一个进程内基于队列的消息持久化存储引擎&#34;&gt;复赛：《实现一个进程内基于队列的消息持久化存储引擎》&lt;/h2&gt;
&lt;h3 id=&#34;赛题分析-1&#34;&gt;赛题分析&lt;/h3&gt;
&lt;p&gt;赛题要求实现一个进程内消息持久化的存储引擎，提供了 4g 的堆内存，2g 的堆外内存，300g 的SSD磁盘。过程分别为发送、查询聚合消息、查询聚合结果，串行执行三个步骤，每个步骤需要在 30 分钟内完成，以每个阶段的 发送数\时间 总和为成绩。&lt;/p&gt;
&lt;h3 id=&#34;设计&#34;&gt;设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由于查询阶段需要对 时间戳 和 数值 进行条件过滤，考虑以 时间戳 和 数值 创建索引键对数据分散进行存储，以数据块为存储单位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个线程所发送消息的时间戳是递增的，对查询过滤天然适合，则为每个线程映射一个存储组件实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方提供使用的存储介质为 SSD磁盘，大量数据写入的效率好，所以将数个数据块为一组单位，缓存于内存中，在写入数据达到下一组单位时进行文件存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在查询阶段为了更好的利用资源，使用 lru缓存 保存查询数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/data_write.png&#34; alt=&#34;data_write&#34; title=&#34;存储组件&#34;&gt;&lt;/p&gt;
&lt;p&gt;发送阶段完成后磁盘文件组织如下，以时间戳定位文件，再以数值选择文件内的数据块（图中以 8192 为时间戳分片大小，4096 为数值为片大小，均为 2 的幂次方，以位运算即可完成路由）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/file_store.png&#34; alt=&#34;file_store&#34; title=&#34;文件编排&#34;&gt;&lt;/p&gt;
&lt;p&gt;如查询条件为 &lt;code&gt;{ t: [8000, 22000], a: [5000, 20000] }&lt;/code&gt;，则选择文件 hash-0、hash-1、hash-2 为目标文件，分别对文件内的 index-1、index-2、index-3、index-4 数据块进行检索，其中 &lt;code&gt;hash-1 index-2&lt;/code&gt;、&lt;code&gt;hash-1 index-3&lt;/code&gt; 为中间数据，无需对数据进行条件过滤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/middleware-competition-5/data_read.png&#34; alt=&#34;data_read&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;其实复赛的设计思路并不难，主要的难点是分片大小的选择，如何更好的利用内存不发生 OOM，以及利用多线程提升效率。&lt;/p&gt;
&lt;p&gt;在写入阶段，使用内存进行数据的缓存，利用时间戳的有序性检测是否进入下个文件数据集，由于需要对全量数据都进行哈希，采用了位移操作提升效率。&lt;/p&gt;
&lt;p&gt;在读取阶段，对条件使用哈希确定目标数据的分布范围，充分利用堆内存与堆外内存，将分配的 &lt;code&gt;ByteBuffer&lt;/code&gt; 进行缓存，提高下次查询时的效率。同理，对于无需条件过滤的结果也可以通过缓存来提高效率。&lt;/p&gt;
&lt;p&gt;增加了缓存就需要考虑内存容量问题，为了避免 OOM 需要引入淘汰规则。直接使用 &lt;code&gt;SoftReference&lt;/code&gt; 容易频繁产生 CMS GC，影响查询效率，而使用 &lt;code&gt;WeakReference&lt;/code&gt; 缓存数据则具有不确定性，数据很可能被快速回收，失去了缓存的意义。&lt;/p&gt;
&lt;p&gt;经过分析后选择了LRU算法，在固定大小集合里缓存数据，对长久未使用的数据进行清理。传统的 LRU Cache 可用继承 &lt;code&gt;LinkedHashMap&lt;/code&gt; 的方式实现，然而这个类是非线程安全的，在查询场景可能产生并发问题，因此重新实现了一个线程安全的 LRU Cache。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ConcurrentLRUCache&amp;lt;K, V&amp;gt; {

    private final Queue&amp;lt;K&amp;gt; keySet;
    private final Map&amp;lt;K, T&amp;gt; cache;

    private final AtomicInteger acquire;
    private final int outSize;

    private volatile boolean full = false;

    public ConcurrentLRUCache(int size) {
        this.keySet = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
        this.cache = new ConcurrentHashMap&amp;lt;&amp;gt;(size, 1f);
        this.acquire = new AtomicInteger(size);
        this.outSize = size + 1;
    }

    public void put(K key, T value) {
        if (full) {
            K firstKey = keySet.poll();
            cache.remove(firstKey);
        } else {
            int nextSize = acquire.incrementAndGet();

            if (nextSize &amp;gt; outSize) {
                Thread.yield();
                put(key, value);
                return;
            }

            if (nextSize == outSize) {
                full = true;
            }
        }
        cache.put(key, value);
        keySet.offer(key);
    }

    public T get(K key) {
        T value = cache.get(key);
        if (value == null) {
            return null;
        }
        
        if (keySet.remove(key)) {
            keySet.offer(key);
        }
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;除了添加缓存外，还有其他优化手段，比如 多线程并发处理数据块、对分块数据进行压缩、数据与消息体分开存储、利用时间戳的顺序中断查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这次比赛中，主要收获了在系统设计上的锻炼，分析问题也更加全面了，以及在 &lt;code&gt;无锁编程&lt;/code&gt;、&lt;code&gt;NIO处理&lt;/code&gt;、&lt;code&gt;编写高性能代码&lt;/code&gt; 方面的进步。如通过 &lt;code&gt;async-profiler&lt;/code&gt; 发现乐观锁在大量请求下的性能问题，并转变思路使用无锁编程。了解到 &lt;code&gt;MappedByteBuffer&lt;/code&gt; 在大量写入的情况下会频繁发生 pageCache 的 &lt;code&gt;flush&lt;/code&gt;，可以先准备好 &lt;code&gt;ByteBuffer&lt;/code&gt; 保存数据，之后再将整个 &lt;code&gt;ByteBuffer&lt;/code&gt; 写入到 &lt;code&gt;MappedByteBuffer&lt;/code&gt; 中。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shenandoah GC 介绍</title>
      <link>https://moyada.github.io/post/shenandoah-gc/</link>
      <pubDate>Sun, 04 Aug 2019 13:30:02 +0000</pubDate>
      <guid>https://moyada.github.io/post/shenandoah-gc/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Shenandoah GC 是 OpenJDK 在 JDK12 推出的新一代 &lt;code&gt;标记整理&lt;/code&gt; 的垃圾回收器，它的目标时为了使大容量内存应用在垃圾回收时只进行短暂的应用暂停，使用 -XX:+UseShenandoahGC 开启。&lt;/p&gt;
&lt;p&gt;它能够在垃圾回收周期中进行 &lt;code&gt;并发整理&lt;/code&gt; 和 &lt;code&gt;并发更新&lt;/code&gt;，不暂停应用线程，并将垃圾回收分解为多个阶段，来达到极短的暂停时间，同时不会随着堆内存大小而影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=VCeHkcwfF9Q&#34;&gt;https://www.youtube.com/watch?v=VCeHkcwfF9Q&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=E1M3hNlhQCg&#34;&gt;https://www.youtube.com/watch?v=E1M3hNlhQCg&lt;/a&gt;
&lt;a href=&#34;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&#34;&gt;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&#34;&gt;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&#34;&gt;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;并发复制&#34;&gt;并发复制&lt;/h3&gt;
&lt;p&gt;Shenandoah GC 是如何做到并发复制的呢？这主要是利用了 &lt;code&gt;读屏障&lt;/code&gt; 和 &lt;code&gt;Brooks Pointers&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://rkennke.wordpress.com/2013/10/23/shenandoah-gc-brooks-pointers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brooks Pointers&lt;/a&gt; 是为了保证并发环境下数据一致性而设计的字段，它在对象地址中占用了 8 位地址来标识实际对象地址的偏移值。&lt;/p&gt;
&lt;p&gt;通常情况下它指向当前对象地址自身，当进入并发整理的对象拷贝阶段时，GC 将会利用 CAS 操作替换新的地址偏移值，并保证只进行一次成功的操作。&lt;/p&gt;
&lt;p&gt;当应用线程操作该对象时将会使用 &lt;code&gt;读屏障&lt;/code&gt; 获取 &lt;code&gt;brooks pointers&lt;/code&gt; 偏移值再计算得出实际地址返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hotspot/share/gc/shenandoah/shenandoahBrooksPointer.inline.hpp

inline oop ShenandoahBrooksPointer::forwardee(oop obj) {
  shenandoah_assert_correct(NULL, obj);
  return oop(*brooks_ptr_addr(obj));
}

inline HeapWord** ShenandoahBrooksPointer::brooks_ptr_addr(oop obj) {
  return (HeapWord**)((HeapWord*) obj + word_offset());
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于通常情况下并不需要使用读屏障来获取地址，Shenandoah GC 又引入了 &lt;code&gt;slow path&lt;/code&gt; 的设计。&lt;/p&gt;
&lt;p&gt;它的作用是，只有当垃圾回收进行中，并且对象处于 &lt;code&gt;collection set&lt;/code&gt; 中，那么程序才会使用 读屏障 来获取对象地址。&lt;/p&gt;
&lt;p&gt;同时 Shenandoah GC 还会对字节码进行优化，以确保程序正确的情况下减少用读屏障获取地址的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/concurrent-copy.png&#34; alt=&#34;concurrent-copy&#34; title=&#34;并发修改&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于需要使用额外的空间来存储 &lt;code&gt;brooks pointers&lt;/code&gt;，则必须使用 64 位地址，同时堆空间也会增加 3% ~ 15% 的开销，而 CAS 和 读屏障 则产生 2% ~ 20% 的吞吐量下降。&lt;/p&gt;
&lt;h3 id=&#34;空间划为&#34;&gt;空间划为&lt;/h3&gt;
&lt;p&gt;Shenandoah 与 G1 类似也是以 Region 来划分堆内存，但是不进行分代标记。&lt;/p&gt;
&lt;p&gt;每个 Region 对应一个数组用来表示有哪些 Region 存在对象指向自身 Region 中的对象，这就避免了 G1 在年轻代之间的引用关系需要扫描整个年轻代甚至是堆的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/region-incoming.png&#34; alt=&#34;region-incoming&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;numa&#34;&gt;NUMA&lt;/h3&gt;
&lt;p&gt;与 ZGC 相同，利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的 CPU 缓存，并且使 应用线程 与 GC线程 处于同一核心线程下，共享同一个 Region 的数据。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;从 &lt;code&gt;hotspot/share/gc/shenandoah/shenandoahControlThread.cpp::run_service()&lt;/code&gt; 可以观察到 Shenandoah GC 的垃圾收回触发策略，将会根据 内存分配情况 或 提交的垃圾回收事件 &lt;code&gt;_requested_gc_cause&lt;/code&gt; 来决定所执行的具体垃圾回收流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  switch (mode) {
    case none:
      break;
    case concurrent_traversal:
      service_concurrent_traversal_cycle(cause);
      break;
    case concurrent_normal:
      service_concurrent_normal_cycle(cause);
      break;
    case stw_degenerated:
      service_stw_degenerated_cycle(cause, degen_point);
      break;
    case stw_full:
      service_stw_full_cycle(cause);
      break;
    default:
      ShouldNotReachHere();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;Shenandoah 的回收过程与 G1 类似，都是基于 Region 的收集策略，一般情况下将垃圾回收声明周期分解成数个阶段执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/shenandoah-gc-cycle.png&#34; alt=&#34;shenandoah-gc-cycle&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，扫描 GC Roots。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;b&gt;并发标记&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与应用程序并发进行，通过上一阶段的 GC Roots 遍历堆，使用 STAB 算法描绘存活对象图谱。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，处理位于队列中的标记和更新操作，并预先进行下一阶段，可能与下一阶段同时完成。&lt;/p&gt;
&lt;p&gt;收集存在死亡对象的 Region&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将无存活对象的 Region 进行清理并加入空闲列表。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;b&gt;并发疏散&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将收集集合中的对象复制至空闲 Region 中，此阶段不会造成应用线程暂停。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;初始更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;短暂的暂停应用线程，只确保疏散操作均已完成。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;b&gt;并发更新引用&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历堆中对象，更新疏散对象的引用。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;最终更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，堆当前的 Root Set 进行更新，对收集集合的 Region 进行回收。&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回收无任何对象引用的 Region。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ZGC 介绍</title>
      <link>https://moyada.github.io/post/zgc/</link>
      <pubDate>Fri, 28 Jun 2019 20:12:10 +0000</pubDate>
      <guid>https://moyada.github.io/post/zgc/</guid>
      <description>&lt;h2 id=&#34;什么是-zgc&#34;&gt;什么是 ZGC&lt;/h2&gt;
&lt;p&gt;由于现在系统日趋增长的内存，传统的垃圾回收器在整理阶段需要花费更长的时间，为了提高 jvm 在大容量内存应用的回收效率，一款新的垃圾回收器 ZGC 在 JDK11 上正式公布问世。通过配置参数 -XX:+UseZGC 开启，目前仅支持 Linux x86 64位的系统。&lt;/p&gt;
&lt;p&gt;ZGC 全称 Z Garbage Collector，是一款 &lt;code&gt;低停顿&lt;/code&gt; 的标记整理垃圾收集器，它能够在大部分时间与应用线程并行运行。ZGC 在 Oracle 官方资料中表明能够保证垃圾回收中最高 &lt;code&gt;10毫秒&lt;/code&gt; 的停顿，而作为低停顿的代价也只是最多下降 15% 的总吞吐量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://openjdk.java.net/projects/zgc/&#34;&gt;https://openjdk.java.net/projects/zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7k_XfLGu-Ts&#34;&gt;https://www.youtube.com/watch?v=7k_XfLGu-Ts&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=kF_r3GE3zOo&#34;&gt;https://www.youtube.com/watch?v=kF_r3GE3zOo&lt;/a&gt;
&lt;a href=&#34;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&#34;&gt;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&#34;&gt;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&lt;/a&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&#34;&gt;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&#34;&gt;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7cWiwu7kYkE&#34;&gt;https://www.youtube.com/watch?v=7cWiwu7kYkE&lt;/a&gt;
&lt;a href=&#34;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&#34;&gt;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/gc-concurrent.png&#34; alt=&#34;gc-concurrent&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;基于-region-的并发收集模式&#34;&gt;基于 Region 的并发收集模式&lt;/h3&gt;
&lt;p&gt;ZGC 与 G1 类似，也是以 Region 划分堆内存结构的，不同的是，ZGC 中 Region 是以大小进行分组的，分别是 Small (2MB)、Medium (32MB)、Large (N*MB)，并且尚未进行分代。由于没有了分代，也就没有了 &lt;code&gt;CardTable&lt;/code&gt; 和 &lt;code&gt;RememberedSet&lt;/code&gt; 的开销。&lt;/p&gt;
&lt;h3 id=&#34;使用-numa架构技术httpsenwikipediaorgwikinon-uniform_memory_access高效的分配空间和进行对象的扫描&#34;&gt;使用 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Non-uniform_memory_access&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NUMA架构技术&lt;/a&gt;高效的分配空间和进行对象的扫描&lt;/h3&gt;
&lt;p&gt;利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的节点缓存，使线程在操作自身创建的对象时提高效率。&lt;/p&gt;
&lt;h3 id=&#34;设计颜色指针标记对象状态保障引用关系一致&#34;&gt;设计颜色指针标记对象状态，保障引用关系一致&lt;/h3&gt;
&lt;p&gt;颜色指针就好比状态机，ZGC 在对象地址的其中 4bit 的空间用于标记&lt;code&gt;颜色&lt;/code&gt;状态，这四个字节分别称之 &lt;code&gt;Finalizable&lt;/code&gt;、 &lt;code&gt;Remapped&lt;/code&gt; 、&lt;code&gt;Marked1&lt;/code&gt;、 &lt;code&gt;Marked0&lt;/code&gt;，通过在不同的收集阶段对指定标记的状态检测，从而采取不同的执行动作。&lt;/p&gt;
&lt;p&gt;由于需要额外的空间来存储标记，因此不支持 32 位平台和指针压缩。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Makred0、 Marked1 用于识别对象在垃圾回收周期中是否被标记存活，存在两个的原因是因为一个被标记的对象可能来自上一个回收周期并未重新映射，此类对象则只需进行映射而无需重定位。&lt;/li&gt;
&lt;li&gt;Remapped 表明该引用对象需要从地址映射表中获取新地址并转移。&lt;/li&gt;
&lt;li&gt;Finalizable 表示这是一个 finalizar 对象，只有 Finalizer 可以对其进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体逻辑见 &lt;code&gt;hotspot/share/gc/z/zAddress.hpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.cpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.inline.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;利用-读屏障-修改引用来提高对象的整理迁移功能&#34;&gt;利用 读屏障 修改引用来提高对象的整理迁移功能&lt;/h3&gt;
&lt;p&gt;对比 G1 使用 &lt;code&gt;写屏障&lt;/code&gt; 来保证引用关系一致，ZGC 则是使用 &lt;code&gt;读屏障&lt;/code&gt; 来达到。&lt;/p&gt;
&lt;p&gt;在应用线程与 GC 线程同时操作同一对象时，通过读屏障检测对象状态，通过 CAS 对重映射对象进行迁移。&lt;/p&gt;
&lt;p&gt;这种设计使得无需暂停应用线程就能保证引用正确，而读屏障的性能开销只有约 4%。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;hotspot/share/gc/z/zDirector.cpp&lt;/code&gt; 中可得知，ZGC 与其他 GC 的回收策略有所不同，是一种主动式的垃圾回收模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ZDirector::run_service() {
  // Main loop
  while (_metronome.wait_for_tick()) {  // 1
    sample_allocation_rate();
    const GCCause::Cause cause = make_gc_decision(); // 2
    if (cause != GCCause::_no_gc) {
      ZCollectedHeap::heap()-&amp;gt;collect(cause);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;wait_for_tick&lt;/code&gt; 中，JVM 会利用时钟计算等待时间，当到达唤醒时间并且不在安全点期间则执行后续逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make_gc_decision&lt;/code&gt; 是根据条件返回回收策略，包含 4 种可执行垃圾回收的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;** 定时执行 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断当前时间距离上次垃圾回收的差值，当时间差值大于设定的间隔时间时则触发垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 内存预热 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据堆内存使用率判断是否进行垃圾回收，当每突破一个 10% 值时进行垃圾回收，例如超过 20%、30% 时。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 吞吐量过大 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对比剩余空间所需分配时间与最久 GC 时间差值，当大于指定间距时 (默认 0.1) 则说明存在空间不足分配的可能性，需要进行垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 主动触发 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当距离上次垃圾回收已经过了 5 分钟同时堆空间上涨了 10%，并且距离上次 GC 的时间大于最久 GC 时间的 49 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当这些条件满足时 JVM 将会调用 Monitor (synchronized 底层线程安全模块) 唤醒线程，&lt;code&gt;异步&lt;/code&gt; 执行垃圾回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;ZGC 的回收过程几乎是完全并发进行的，只会在三个阶段进行短短的暂停: 标记开始(mark-start)、标记结束(mark-final)、迁移开始(relocate-start)，具体流程可见于 &lt;code&gt;src/hotspot/share/gc/z/zDriver.cpp::run_gc_cycle()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/phases.png&#34; alt=&#34;zgc-phases&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;【标记开始】&lt;/strong&gt; 开始标记时，会暂停所有应用线程，标记出堆中的 
&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/gcroots.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GC Roots&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-start.png&#34; alt=&#34;mark-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发标记】&lt;/strong&gt; 释放应用线程，通过 GC Roots 遍历堆中所有对象，找出存活的对象集合 (类似一个 bitmap)。应用线程利用&lt;code&gt;读屏障&lt;/code&gt;将对象的变化信息保存于线程中，之后转交由 GC 线程处理引用关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-mark.png&#34; alt=&#34;concurrent-mark&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;【标记结束】&lt;/strong&gt; 完成所有对象的标记后，短时暂停应用线程，完成标记阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-final.png&#34; alt=&#34;mark-final&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发准备】&lt;/strong&gt; 为下一阶段的重定位做准备，收集那些垃圾对象占比最大或最多的 page 加入 &lt;code&gt;relocate set&lt;/code&gt;，每个 page 都分配一个 &lt;code&gt;forwarding table&lt;/code&gt; 保存重定向地址，还进行一些其他数据的清理 (比如软弱虚引用、Finalizer 对象、字符串常量池、元数据)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/prepare.png&#34; alt=&#34;prepare&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;【迁移开始】&lt;/strong&gt; 暂停应用线程，扫描 GC Roots 的指向对象，对 &lt;code&gt;relocate set&lt;/code&gt; 内对象进行迁移并将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt;。将本地线程状态设置为 &lt;code&gt;bad mask&lt;/code&gt;，对应用线程内对迁移对象的引用标记为 &lt;code&gt;Remapped relocate&lt;/code&gt;。分配大块连续空间，以便能够存放要迁移的对象，申请一下阶段所需的工作线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/relocate-start.png&#34; alt=&#34;relocate-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发迁移】&lt;/strong&gt; 对 &lt;code&gt;relocate set&lt;/code&gt; 中 page 里剩余的存活对象进行迁移，将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt; 中。应用线程在操作 &lt;code&gt;Remapped relocate&lt;/code&gt; 对象时将通过读屏障进行重新映射地址，同时 GC线程 也对程序内的对象引用进行重映射。当映射地址与原地址一致时则表明所有引用均已重映射，标记 page 在之后清除释放空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-relocate.png&#34; alt=&#34;concurrent-relocate&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如未重映射对象在下一垃圾回收周期也被标记，则该对象则不会进行分配重定位地址，为了达到这一区别所以才有了 &lt;code&gt;Makred0&lt;/code&gt;、 &lt;code&gt;Marked1&lt;/code&gt; 两个标记标识。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;停顿时间不会随着堆空间的大小增长，但是与 GC Root 的数量是成正比，而 GC Root 的数量则与应用线程的数量有关。
在 GC 的周期内，标记开始和迁移开始操作会比较花费时间，但所有停顿时间总共也是小于 10 毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>在非 SpringBoot 工程中实现 Eureka 构建 Feign 服务</title>
      <link>https://moyada.github.io/post/feign-eureka-without-springboot/</link>
      <pubDate>Sat, 18 May 2019 08:47:26 +0000</pubDate>
      <guid>https://moyada.github.io/post/feign-eureka-without-springboot/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近有个需求需要嵌入至其他业务中，其中有个数据需要通过 Eureka 获取，正常情况下使用 &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt; 和 &lt;code&gt;@EnableFeignClients&lt;/code&gt; 即可获取服务接口实例。可是由于我使用了 BeanPostProcessor 对注解进行了切片代理，并且目标项目也存在非 SpringCloud 项目，那么便只能通过底层 API 构建服务方实例了。&lt;/p&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;EurekaClient 提供了服务发现注册功能，但是在 Feign 所接收的属性中并没有用于负载均衡的，其中最有可能的就是 Client 属性了，这是用于负责服务请求的模块，那么就需要调研下是否能够通过 EurekaClient 构建出一个带有负载均衡功能的客户端。&lt;/p&gt;
&lt;h3 id=&#34;创建-lbclientfactory&#34;&gt;创建 LBClientFactory&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Feign&lt;/strong&gt; 的官方 Wiki 提供了构建服务实例的
&lt;a href=&#34;https://github.com/OpenFeign/feign#integrations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;方法&lt;/a&gt;，但 Feign 并不提供构建所需属性的实现，而是由其他框架适配 Feign 所提供的接口来实现每个功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在分析 &lt;strong&gt;Ribbon&lt;/strong&gt; 的 Client 实现 &lt;code&gt;RibbonClient&lt;/code&gt;，其构造器接收一个 &lt;code&gt;LBClientFactory&lt;/code&gt; 参数，负载均衡的功能就是由它提供。&lt;/p&gt;
&lt;p&gt;通过搜索引擎发现了打通 Robbion 与 EurekaClient 的实现方式，需要引入依赖 &lt;code&gt;&amp;lt;artifactId&amp;gt;ribbon-eureka&amp;lt;/artifactId&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Client newClient(String vipAddress, Provider&amp;lt;EurekaClient&amp;gt; provider) {
    ServerList&amp;lt;DiscoveryEnabledServer&amp;gt; list = new DiscoveryEnabledNIWSServerList(vipAddress, provider);
    ServerListFilter&amp;lt;DiscoveryEnabledServer&amp;gt; filter = new ZoneAffinityServerListFilter&amp;lt;DiscoveryEnabledServer&amp;gt;();

    ZoneAwareLoadBalancer&amp;lt;DiscoveryEnabledServer&amp;gt; lb = LoadBalancerBuilder.&amp;lt;DiscoveryEnabledServer&amp;gt;newBuilder()
            .withDynamicServerList(list)
            .withRule(new AvailabilityFilteringRule())
            .withServerListFilter(filter)
            .buildDynamicServerListLoadBalancer();

    return RibbonClient.builder().lbClientFactory(new LBClientFactory() {
        @Override
        public LBClient create(String clientName) {
            return LBClient.create(lb, ClientFactory.getNamedConfig(clientName));
        }
    }).build();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中需要使用 &lt;code&gt;DiscoveryEnabledNIWSServerList&lt;/code&gt; 用于发现服务集合，它接收两个提供两个参数，一个是项目的 vipAddress，一个是 Provider&lt;EurekaClient&gt;。&lt;/p&gt;
&lt;h3 id=&#34;创建-eurekaclient&#34;&gt;创建 EurekaClient&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;Eureka&lt;/strong&gt; 的官方 Wiki 中提供了 EurekaClient 的
&lt;a href=&#34;https://github.com/Netflix/eureka/tree/master/eureka-examples/src/main/java/com/netflix/eureka&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构造方式&lt;/a&gt;，需要传入 &lt;code&gt;EurekaClientConfig&lt;/code&gt; 和 &lt;code&gt;EurekaInstanceConfig&lt;/code&gt; 用来提供模块的配置信息。&lt;/p&gt;
&lt;p&gt;在 netflix 提供的 eureka-client 模块下，提供了 &lt;code&gt;DefaultEurekaClientConfig&lt;/code&gt; 和 &lt;code&gt;MyDataCenterInstanceConfig&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个类默认将会读取 eureka-client.properties 下的配置，可以通过设置 &lt;code&gt;eureka.client.props&lt;/code&gt; 参数更改读取的配置文件，也可以使用 &lt;code&gt;ConfigurationManager&lt;/code&gt; 的静态方法来指定读取配置文件。&lt;/p&gt;
&lt;p&gt;除此之外，spring-cloud 也提供了相应的实现类 &lt;code&gt;EurekaClientConfigBean&lt;/code&gt; 和 &lt;code&gt;EurekaInstanceConfigBean&lt;/code&gt;，通过 spring 的配置资源解析器将属性装配成对象使用。&lt;/p&gt;
&lt;p&gt;入参已经拿到了，但是还未结束，在跟进 &lt;code&gt;DiscoveryClient&lt;/code&gt; 代码实现中，发现他在构造方法中会对属性进行静态保存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()
// to work with DI&#39;d DiscoveryClient
DiscoveryManager.getInstance().setDiscoveryClient(this);
DiscoveryManager.getInstance().setEurekaClientConfig(config);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个项目中，有可能存在业务项目内部与嵌入模块使用了不同的 Eureka 服务，为了保持与业务项目的隔离，这里需要对官方提供的代码模版进行点改造。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static volatile EurekaClient eurekaClient = null;

public EurekaClient initEurekaClient(EurekaInstanceConfig instanceConfig, EurekaClientConfig clientConfig) {
    if (null != eurekaClient) {
        return eurekaClient;
    }

    synchronized (DiscoveryManager.class) {
        if (null == eurekaClient) {
            DiscoveryClient discoveryClient = DiscoveryManager.getInstance().getDiscoveryClient();
            EurekaClientConfig eurekaClientConfig = DiscoveryManager.getInstance().getEurekaClientConfig();
            EurekaInstanceConfig eurekaInstanceConfig = DiscoveryManager.getInstance().getEurekaInstanceConfig();

            // create the client
            InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();
            ApplicationInfoManager infoManager = new ApplicationInfoManager(instanceConfig, instanceInfo);
            infoManager.setInstanceStatus(InstanceInfo.InstanceStatus.STARTING);

            EurekaClient client = new DiscoveryClient(infoManager, clientConfig);
            infoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);

            eurekaClient = client;

            DiscoveryManager.getInstance().setDiscoveryClient(discoveryClient);
            DiscoveryManager.getInstance().setEurekaClientConfig(eurekaClientConfig);
            DiscoveryManager.getInstance().setEurekaInstanceConfig(eurekaInstanceConfig);
        }
    }
    return eurekaClient;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在实际开发中可通过 DiscoveryManager 的静态属性对其进行管理的，避免重复构建。但是在这个场景下需要保证与业务之间的隔离，则以这种方式构建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;创建-providereurekaclient&#34;&gt;创建 Provider&lt;EurekaClient&gt;&lt;/h3&gt;
&lt;p&gt;在创建 LBClientFactory 的过程中，我们需要构建 DiscoveryEnabledNIWSServerList 用于服务的发现，由于构造方法接收的参数为 &lt;code&gt;Provider&amp;lt;EurekaClient&amp;gt;&lt;/code&gt;，这里还需要对 EurekaClient 再经过包装后使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Provider&amp;lt;EurekaClient&amp;gt;() {
    @Override
    public EurekaClient get() {
        return eurekaClient;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构造服务实例&#34;&gt;构造服务实例&lt;/h3&gt;
&lt;p&gt;通过上述步骤基本完成了一个 EurekaClient 到 RobbionClient 的各个过程，最后代入 Feign 的创建方法中便可构造使用 Eureka 进行服务发现的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public &amp;lt;T&amp;gt; T getInstance(Class&amp;lt;T&amp;gt; target, String namespace, Provider&amp;lt;EurekaClient&amp;gt; provider) {
    return Feign.builder()
        .client(newClient(namespace, provider))
        .encoder(new JacksonEncoder())
        .decoder(new JacksonDecoder())
        .options(new Request.Options(1000, 3000))
        .logLevel(Logger.Level.FULL)
        .target(target, &amp;quot;http://&amp;quot; + namespace);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>instanceOf、isInstance、isAssignableFrom 的区别</title>
      <link>https://moyada.github.io/post/diff-instanceof-isassignablefrom/</link>
      <pubDate>Sun, 05 May 2019 20:23:32 +0000</pubDate>
      <guid>https://moyada.github.io/post/diff-instanceof-isassignablefrom/</guid>
      <description>&lt;p&gt;在 Java 中，对一个类的子类判断有三种方式，分别是 &lt;code&gt;obj instanceof [TypeName]&lt;/code&gt;、&lt;code&gt;class.isInstance(obj)&lt;/code&gt;、&lt;code&gt;class.isAssignableFrom(class)&lt;/code&gt;，他们的作用都是进行父子类型判断，然而他们的区别又在什么地方。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;其中 &lt;code&gt;instanceof&lt;/code&gt; 是一个 Java 原语，通过对象与类型签名进行判断，需要在编译期就进行解析成字节码。跟进 JVM 源码里，在 &lt;code&gt;templateTable.hpp&lt;/code&gt; 中发现了 instanceof 方法的定义，从其中 &lt;code&gt;templateTable_x86.cpp&lt;/code&gt;、&lt;code&gt;templateTable_arm.cpp&lt;/code&gt; 的 &lt;code&gt;instanceof&lt;/code&gt; 方法可得，其实现方式主要是通过汇编指令从 klass 中获取标记进行判断，逻辑比较长也就不一一分析了。对于这段冗长的汇编代码，JVM 也进行了优化，当触发 JIT 编译时，会把这段逻辑编译成机器码写入 C1 层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;isInstance&lt;/code&gt; 是 Class 类下的 native 方法，接收参数为对象。分析了在 &lt;code&gt;jni.cpp&lt;/code&gt; 中的大体流程，程序先通过 class 获取到 Klass，调用 object 内 klass 的 &lt;code&gt;is_subtype_of&lt;/code&gt; 方法，传入方才获取的 Klass，判断二者地址是否相同，是则判定为同一类型，否则再调用 &lt;code&gt;search_secondary_supers&lt;/code&gt;，判断父级类型是否存在与传入的 Klass 相匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;JNI_QUICK_ENTRY(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
  JNIWrapper(&amp;quot;IsInstanceOf&amp;quot;);

  HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);

  jboolean ret = JNI_TRUE;
  if (obj != NULL) {
    ret = JNI_FALSE;
    Klass* k = java_lang_Class::as_Klass(
      JNIHandles::resolve_non_null(clazz));
    if (k != NULL) {
      ret = JNIHandles::resolve_non_null(obj)-&amp;gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
    }
  }

  HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
  return ret;
JNI_END

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// hotspot/share/oops/oop.inline.hpp

bool oopDesc::is_a(Klass* k) const {
  return klass()-&amp;gt;is_subtype_of(k);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// hotspot/share/oops/klass.hpp

// subtype check: true if is_subclass_of, or if k is interface and receiver implements it
bool is_subtype_of(Klass* k) const {
  juint    off = k-&amp;gt;super_check_offset();
  Klass* sup = *(Klass**)( (address)this + off );
  const juint secondary_offset = in_bytes(secondary_super_cache_offset());
  if (sup == k) {
    return true;
  } else if (off != secondary_offset) {
    return false;
  } else {
    return search_secondary_supers(k);
  }
}

bool Klass::search_secondary_supers(Klass* k) const {
  // Put some extra logic here out-of-line, before the search proper.
  // This cuts down the size of the inline method.

  // This is necessary, since I am never in my own secondary_super list.
  if (this == k)
    return true;
  // Scan the array-of-objects for a match
  int cnt = secondary_supers()-&amp;gt;length();
  for (int i = 0; i &amp;lt; cnt; i++) {
    if (secondary_supers()-&amp;gt;at(i) == k) {
      ((Klass*)this)-&amp;gt;set_secondary_super_cache(k);
      return true;
    }
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;isAssignableFrom&lt;/code&gt; 也是 Class 类下的 native 方法，接收参数为 Class 类。主要逻辑与 &lt;code&gt;isInstance&lt;/code&gt; 相同，区别在于当 主体 Class 与 参数 Class 其中一个为原生类型时，则选择使用对象头判断类型是否相等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;isInstance&lt;/code&gt; 和 &lt;code&gt;isAssignableFrom&lt;/code&gt; 对入参校验上也有区别，isInstance 当对象为空时将会返回 &lt;code&gt;false&lt;/code&gt; isAssignableFrom 则会对参数进行非空校验。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isInstance&lt;/code&gt; 和 &lt;code&gt;isAssignableFrom&lt;/code&gt; 在方法标记上都有 &lt;code&gt;@HotSpotIntrinsicCandidate&lt;/code&gt;，会被 JVM 使用更高效的字节码替换，节省了 JNI 调用的开销。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JNI_QUICK_ENTRY(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
  JNIWrapper(&amp;quot;IsSubclassOf&amp;quot;);

  HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);

  oop sub_mirror   = JNIHandles::resolve_non_null(sub);
  oop super_mirror = JNIHandles::resolve_non_null(super);
  if (java_lang_Class::is_primitive(sub_mirror) ||
      java_lang_Class::is_primitive(super_mirror)) {
    jboolean ret = oopDesc::equals(sub_mirror, super_mirror);

    HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
    return ret;
  }
  Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
  Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
  assert(sub_klass != NULL &amp;amp;&amp;amp; super_klass != NULL, &amp;quot;invalid arguments to jni_IsAssignableFrom&amp;quot;);
  jboolean ret = sub_klass-&amp;gt;is_subtype_of(super_klass) ?
                   JNI_TRUE : JNI_FALSE;

  HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
  return ret;
JNI_END
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下，&lt;code&gt;instanceof&lt;/code&gt;、&lt;code&gt;isInstance&lt;/code&gt;、&lt;code&gt;isAssignableFrom&lt;/code&gt; 其实无太大区别，instanceof 和 isInstance 适用于主体是对象，并且 instanceof 需要在编译期就指定类型，灵活性不如 isInstance。而 isAssignableFrom 是针对两个类的关系校验，在泛型对比上比较适合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://stackoverflow.com/questions/496928/what-is-the-difference-between-instanceof-and-class-isassignablefrom&#34;&gt;https://stackoverflow.com/questions/496928/what-is-the-difference-between-instanceof-and-class-isassignablefrom&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>序列化框架对比</title>
      <link>https://moyada.github.io/post/java-serializer/</link>
      <pubDate>Fri, 03 May 2019 20:19:46 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-serializer/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近接到一个需求，涉及到大流量的数据传输，那么就不可避免序列化，正巧我也有想法对最近主流的序列化框架做一次对比。&lt;/p&gt;
&lt;p&gt;参数对比的序列化的框架如下，将对 &lt;code&gt;序列化数据字节大小&lt;/code&gt;、&lt;code&gt;序列化\反序列化平均耗时&lt;/code&gt;、&lt;code&gt;序列化\反序列化吞吐量&lt;/code&gt; 这三个维度进行对比。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该测试结果可能因为机器原因、框架使用方式、样本数据问题，导致结果不准确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工程代码见 &lt;a href=&#34;https://github.com/moyada/java-serializers&#34;&gt;https://github.com/moyada/java-serializers&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;avro&lt;/td&gt;
&lt;td&gt;1.8.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hessian&lt;/td&gt;
&lt;td&gt;4.0.60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jackson&lt;/td&gt;
&lt;td&gt;2.9.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fastjson&lt;/td&gt;
&lt;td&gt;1.2.57&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gson&lt;/td&gt;
&lt;td&gt;2.8.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kryo&lt;/td&gt;
&lt;td&gt;4.0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protobuf&lt;/td&gt;
&lt;td&gt;3.7.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protostuff&lt;/td&gt;
&lt;td&gt;1.5.9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里我对所有框架再进行了一次封装，更方便接入测试，也是一般开发中的正常操作，在序列化框架的使用上主要是参考官方文档。&lt;/p&gt;
&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;
&lt;p&gt;JDK 版本为 1.8.0_191，使用 &lt;code&gt;BenchMark&lt;/code&gt; 进行测试，环境参数为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# VM options: -server -Xms2048m -Xmx2048m -XX:+UseTLAB -XX:+UseG1GC
# Warmup: 3 iterations, 40 s each
# Measurement: 5 iterations, 60 s each
# Timeout: 10 min per iteration
# Threads: 10 threads, will synchronize iterations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试的数据结构如下，数据统一为 &lt;code&gt;{&amp;quot;id&amp;quot;: 34501231422, &amp;quot;name&amp;quot;: &amp;quot;moyada&amp;quot;, &amp;quot;age&amp;quot;: 18, &amp;quot;gender&amp;quot;: true, &amp;quot;scope&amp;quot;: 33.23, &amp;quot;identifies&amp;quot;: [&amp;quot;moyada&amp;quot;, &amp;quot;people&amp;quot;, &amp;quot;person&amp;quot;, &amp;quot;animal&amp;quot;], &amp;quot;info&amp;quot;: {&amp;quot;haha&amp;quot;: &amp;quot;666&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;111&amp;quot;}}&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User implements Serializable {
    private long id;
    private String name;
    private int age;
    private boolean gender;
    private Double scope;
    private List&amp;lt;String&amp;gt; identifies;
    private Map&amp;lt;String, String&amp;gt; info;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;序列化后数据对比&#34;&gt;序列化后数据对比&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;字节大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Avro&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protobuf&lt;/td&gt;
&lt;td&gt;76&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protostuff&lt;/td&gt;
&lt;td&gt;79&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kryo&lt;/td&gt;
&lt;td&gt;109&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hessian&lt;/td&gt;
&lt;td&gt;140&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gson&lt;/td&gt;
&lt;td&gt;140&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FastJson&lt;/td&gt;
&lt;td&gt;140&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jackson&lt;/td&gt;
&lt;td&gt;153&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;平均耗时对比&#34;&gt;平均耗时对比&lt;/h2&gt;
&lt;h3 id=&#34;序列化平均耗时&#34;&gt;序列化平均耗时&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;耗时&lt;/th&gt;
&lt;th&gt;方差&lt;/th&gt;
&lt;th&gt;单位时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Avro&lt;/td&gt;
&lt;td&gt;11189.699&lt;/td&gt;
&lt;td&gt;228.857&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fastjson&lt;/td&gt;
&lt;td&gt;8859.637&lt;/td&gt;
&lt;td&gt;58.009&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gson&lt;/td&gt;
&lt;td&gt;14581.029&lt;/td&gt;
&lt;td&gt;59.314&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hessian&lt;/td&gt;
&lt;td&gt;16504.562&lt;/td&gt;
&lt;td&gt;85.219&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jackson&lt;/td&gt;
&lt;td&gt;8795.401&lt;/td&gt;
&lt;td&gt;48.109&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kryo&lt;/td&gt;
&lt;td&gt;12437.866&lt;/td&gt;
&lt;td&gt;52.945&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protobuf&lt;/td&gt;
&lt;td&gt;10775.097&lt;/td&gt;
&lt;td&gt;147.737&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protostuff&lt;/td&gt;
&lt;td&gt;6027.095&lt;/td&gt;
&lt;td&gt;33.662&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/ser-avgt.png&#34; alt=&#34;ser-avgt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;反序列化平均耗时&#34;&gt;反序列化平均耗时&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;耗时&lt;/th&gt;
&lt;th&gt;方差&lt;/th&gt;
&lt;th&gt;单位时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Avro&lt;/td&gt;
&lt;td&gt;25422.477&lt;/td&gt;
&lt;td&gt;658.969&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fastjson&lt;/td&gt;
&lt;td&gt;8736.501&lt;/td&gt;
&lt;td&gt;81.286&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gson&lt;/td&gt;
&lt;td&gt;10366.847&lt;/td&gt;
&lt;td&gt;941.759&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hessian&lt;/td&gt;
&lt;td&gt;9293.557&lt;/td&gt;
&lt;td&gt;543.865&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jackson&lt;/td&gt;
&lt;td&gt;9594.744&lt;/td&gt;
&lt;td&gt;103.369&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kryo&lt;/td&gt;
&lt;td&gt;9190.082&lt;/td&gt;
&lt;td&gt;243.400&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protobuf&lt;/td&gt;
&lt;td&gt;5455.168&lt;/td&gt;
&lt;td&gt;120.927&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protostuff&lt;/td&gt;
&lt;td&gt;4861.520&lt;/td&gt;
&lt;td&gt;31.993&lt;/td&gt;
&lt;td&gt;ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/deser-avgt.png&#34; alt=&#34;deser-avgt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;平均耗时综合对比&#34;&gt;平均耗时综合对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/avgt.png&#34; alt=&#34;avgt&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;吞吐量对比&#34;&gt;吞吐量对比&lt;/h2&gt;
&lt;h3 id=&#34;序列化吞吐量&#34;&gt;序列化吞吐量&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;吞吐量&lt;/th&gt;
&lt;th&gt;方差&lt;/th&gt;
&lt;th&gt;单位时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Avro&lt;/td&gt;
&lt;td&gt;951.174&lt;/td&gt;
&lt;td&gt;15.053&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fastjson&lt;/td&gt;
&lt;td&gt;1160.132&lt;/td&gt;
&lt;td&gt;11.835&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gson&lt;/td&gt;
&lt;td&gt;711.199&lt;/td&gt;
&lt;td&gt;8.525&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hessian&lt;/td&gt;
&lt;td&gt;620.666&lt;/td&gt;
&lt;td&gt;4.321&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jackson&lt;/td&gt;
&lt;td&gt;1215.150&lt;/td&gt;
&lt;td&gt;19.994&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kryo&lt;/td&gt;
&lt;td&gt;836.276&lt;/td&gt;
&lt;td&gt;16.079&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protobuf&lt;/td&gt;
&lt;td&gt;1103.661&lt;/td&gt;
&lt;td&gt;18.079&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protostuff&lt;/td&gt;
&lt;td&gt;1756.591&lt;/td&gt;
&lt;td&gt;27.101&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/ser-thrpt.png&#34; alt=&#34;ser-thrpt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;反序列化吞吐量&#34;&gt;反序列化吞吐量&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;框架&lt;/th&gt;
&lt;th&gt;吞吐量&lt;/th&gt;
&lt;th&gt;方差&lt;/th&gt;
&lt;th&gt;单位时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Avro&lt;/td&gt;
&lt;td&gt;389.745&lt;/td&gt;
&lt;td&gt;24.479&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fastjson&lt;/td&gt;
&lt;td&gt;1103.777&lt;/td&gt;
&lt;td&gt;29.458&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gson&lt;/td&gt;
&lt;td&gt;977.951&lt;/td&gt;
&lt;td&gt;38.406&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hessian&lt;/td&gt;
&lt;td&gt;1153.816&lt;/td&gt;
&lt;td&gt;44.385&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jackson&lt;/td&gt;
&lt;td&gt;1072.346&lt;/td&gt;
&lt;td&gt;12.922&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kryo&lt;/td&gt;
&lt;td&gt;1098.548&lt;/td&gt;
&lt;td&gt;33.257&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protobuf&lt;/td&gt;
&lt;td&gt;1847.549&lt;/td&gt;
&lt;td&gt;43.935&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Protostuff&lt;/td&gt;
&lt;td&gt;2055.013&lt;/td&gt;
&lt;td&gt;61.317&lt;/td&gt;
&lt;td&gt;ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/deser-thrpt.png&#34; alt=&#34;deser-thrpt&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;吞吐量综合对比&#34;&gt;吞吐量综合对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/serializer/thrpt.png&#34; alt=&#34;thrpt&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;综合对比下来，抛开未采样的内存占用及 cpu 消耗，大部分序列化框架效率还是比较不错的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Avro&lt;/code&gt; 在反序列化时耗时比较严重，怀疑是否因为多线程而导致的，并且在反序列化后 map 数据还发生了顺序变化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Protostuff&lt;/code&gt; 在各方面都优于其他框架，但是需要预先定义类，不过比起 &lt;code&gt;Protobuf&lt;/code&gt;、&lt;code&gt;Thrift&lt;/code&gt; 等预先定义数据格式已经方便很多了。&lt;/p&gt;
&lt;p&gt;如果传输量不是很大，但是对数据的可视化有要求的，那么 &lt;code&gt;Fastjson&lt;/code&gt; 和 &lt;code&gt;Jackson&lt;/code&gt; 是不错的选择，而且 &lt;code&gt;json&lt;/code&gt; 格式在跨语言上也天然有优势。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Prometheus &#43; Grafana 搭建监控系统</title>
      <link>https://moyada.github.io/post/prometheus-grafana/</link>
      <pubDate>Sat, 23 Mar 2019 15:18:30 +0000</pubDate>
      <guid>https://moyada.github.io/post/prometheus-grafana/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;系统监控是中大型企业中必不可少的组件，在线上服务器遇到负载问题时通过监控便能够查看系统状态快照，还能够通过监控系统开发其他效能组件，进一步提高系统的可用性。&lt;/p&gt;
&lt;h2 id=&#34;监控应用程序&#34;&gt;监控应用程序&lt;/h2&gt;
&lt;p&gt;通常情况下，要想获得应用的负载情况就需要改造原有工程，提供 pull 或 push 的方式将应用状况进行上报。&lt;/p&gt;
&lt;p&gt;Prometheus 使用的是 pull 模式，在应用中开放端口提供系统状态信息，监控系统可以定时从应用中拉取记录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 SpringBoot 应用中引入依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- prometheus --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- endpoint --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置暴露的 endpoint 及系统标识&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;management.metrics.tags.application=${spring.application.name}
# 开放全部监控，或选择配置，如 prometheus, health
management.endpoints.web.exposure.include=*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动完成后通过 &lt;code&gt;{host}:{port}/actuator/prometheus&lt;/code&gt; 可以查看暴露的度量指标&lt;/p&gt;
&lt;h2 id=&#34;监控中心&#34;&gt;监控中心&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/getting_started/&#34;&gt;https://prometheus.io/docs/prometheus/latest/getting_started/&lt;/a&gt; 下载合适的 Prometheus 版本&lt;/p&gt;
&lt;p&gt;解压后修改 &lt;code&gt;prometheus.yml&lt;/code&gt; 配置，增加目标应用的监控配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...

scrape_configs:
  - job_name: &#39;targetProject&#39;
    scrape_interval: 5s
    metrics_path: &#39;/actuator/prometheus&#39;
    static_configs:
    - targets: [&#39;127.0.0.1:8080&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改后通过命令 &lt;code&gt;./prometheus -config.file=prometheus.yml&lt;/code&gt; 启动 Prometheus，并进入管理页面 http://127.0.0.1:9090 检查 Endpoint 状态。&lt;/p&gt;
&lt;h2 id=&#34;grafana-数据可视化&#34;&gt;Grafana 数据可视化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;a href=&#34;http://docs.grafana.org/installation/&#34;&gt;http://docs.grafana.org/installation/&lt;/a&gt; 选择合适的版本安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问 http://127.0.0.1:3000 ，默认账号 admin/admin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 Prometheus 数据源，进入 &lt;code&gt;Configuration/DataSources&lt;/code&gt; 配置监控中心地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导入 Dashboard，对数据的采集展示配置可通过 &lt;a href=&#34;https://grafana.com/dashboards&#34;&gt;https://grafana.com/dashboards&lt;/a&gt; 获取已有配置，填写 dashboardId 导入 (如 8919/4701)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;也可通过 &lt;code&gt;Add panel&lt;/code&gt; 增加监控面板，再选择 &lt;code&gt;Add Query&lt;/code&gt; 设置监控主体，监控语句可通过 http://127.0.0.1:9090/graph 获取。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Spring 自定义配置加载</title>
      <link>https://moyada.github.io/post/spring-configure/</link>
      <pubDate>Sat, 23 Feb 2019 20:31:04 +0000</pubDate>
      <guid>https://moyada.github.io/post/spring-configure/</guid>
      <description>&lt;p&gt;Spring 工程中一般以 xml (spring-framework) 和 yml (spring-boot) 做为配置文件，配置除了框架提供的也支持增加其他配置，它们是以同样的形式注册到 Spring 中的。&lt;/p&gt;
&lt;h2 id=&#34;1-xml-配置&#34;&gt;1. xml 配置&lt;/h2&gt;
&lt;p&gt;这是早期 Spring 提供的配置方式，需要与 &lt;code&gt;xsd&lt;/code&gt; 文件配合使用。&lt;/p&gt;
&lt;p&gt;文件的解析是需要通过实现 &lt;code&gt;org.springframework.beans.factory.xml.NamespaceHandlerSupport&lt;/code&gt; 提供解析器，在 &lt;code&gt;init&lt;/code&gt; 方法中调用 &lt;code&gt;registerBeanDefinitionParser&lt;/code&gt; 将 xsd元素名称 与 元素解析器 进行绑定。&lt;/p&gt;
&lt;p&gt;对于 xsd元素 所绑定的解析器是 &lt;code&gt;org.springframework.beans.factory.xml.BeanDefinitionParser&lt;/code&gt;，实现元素到 &lt;code&gt;BeanDefinition&lt;/code&gt; 的转换，并交由 Spring 容器进行实例注册。&lt;/p&gt;
&lt;p&gt;最后需要将完成的解析器与 xsd文件 通过 &lt;code&gt;META-INF/spring.handlers&lt;/code&gt; 和 &lt;code&gt;META-INF/spring.schemas&lt;/code&gt; 进行映射，在 spring.schemas 中以 &lt;code&gt;命名空间地址 = xsd文件路径&lt;/code&gt; 的形式配置，在 spring.handlers 中以 &lt;code&gt;命名空间地址 = 解析器类全路径&lt;/code&gt; 的形式配置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 yml 配置的便捷性导致了 xml 配置方式在开发中逐渐被替换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-yml-配置&#34;&gt;2. yml 配置&lt;/h2&gt;
&lt;p&gt;跟随 spring-boot 一起出现的配置模式，相较于 xml 显得尤其简便。同时也舍弃了 xml 的解析器，使用等同于 &lt;code&gt;@Conditional&lt;/code&gt; 的注册 Configuration 在 Spring 的生命周期进行容器管理。&lt;/p&gt;
&lt;h3 id=&#34;enable-注解&#34;&gt;Enable 注解&lt;/h3&gt;
&lt;p&gt;这种方式主要是提供注解使用，并在注解内配置 &lt;code&gt;@Import&lt;/code&gt; 显式的注册 Configuration。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;, &lt;code&gt;@EnableScheduling&lt;/code&gt;, &lt;code&gt;@EnableMBeanExport&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;自动装配&#34;&gt;自动装配&lt;/h3&gt;
&lt;p&gt;通过创建 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 文件，配置需要装配的 Configuration 即可。其原理是使用了 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 注解，通过注册的 &lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt; 扫描所有依赖 jar 包内的 &lt;code&gt;META-INF/spring.factories&lt;/code&gt;，将配置的 Configuration 进行注册。与显式注解形式配置有所不同，这种方式配置的 Configuration 还可以使用 &lt;code&gt;@AutoConfigureAfter&lt;/code&gt; 和 &lt;code&gt;@AutoConfigureBefore&lt;/code&gt; 控制执行顺序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种是最为常见的使用方式，一般还需构建 &lt;code&gt;spring-boot-starter&lt;/code&gt; 提供使用，具体使用见
&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;动态注册配置&#34;&gt;动态注册配置&lt;/h3&gt;
&lt;p&gt;结合了 &lt;code&gt;Enable 注解&lt;/code&gt; 和 &lt;code&gt;自动装配&lt;/code&gt; 的方式，能够更加灵活的配置 Configuration。实现方式为提供 Enable注解，并且在注解内配置 @Import &lt;code&gt;ImportSelector&lt;/code&gt;，通过 ImportSelector 返回 Configuration 列表提供给 Spring 注册，可以根据条件控制返回的 Configuration，又或是提供类似 自动装配 的功能。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;, &lt;code&gt;@EnableAsync&lt;/code&gt;, &lt;code&gt;@EnableCaching&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 注解处理器</title>
      <link>https://moyada.github.io/post/java-annotation-processor/</link>
      <pubDate>Tue, 15 Jan 2019 19:40:15 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-annotation-processor/</guid>
      <description>&lt;h2 id=&#34;工作流程&#34;&gt;工作流程&lt;/h2&gt;
&lt;p&gt;注解处理器是一种应用于编译期间的模块，在编译完源文件后，编译器会解析类信息，转换成抽象语法树，接着执行注册的注解处理器，解析语法树是否发生了变化并重新生成源文件，接着调用下一个注解处理器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器具体处理过程可查看 OpenJDK 官方文档: &lt;a href=&#34;https://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html&#34;&gt;https://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义注解
创建注解处理器的第一步就是需要定义相关注解，并且在注解上定义 &lt;code&gt;@Retention&lt;/code&gt;，当指定为 &lt;code&gt;RetentionPolicy.SOURCE&lt;/code&gt; 时，该注解即在编译结束后会被擦除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建处理器
接着就需要创建处理器了，一般可通过继承 &lt;code&gt;javax.annotation.processing.AbstractProcessor&lt;/code&gt; 定义处理器，由于注解处理器是通过反射获取的，所以需要提供无参构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置解析注解
重写 &lt;code&gt;getSupportedAnnotationTypes&lt;/code&gt; 或定义 &lt;code&gt;@SupportedAnnotationTypes&lt;/code&gt; 将先前定义的注解类名加入解析目标，也可以使用 &lt;code&gt;*&lt;/code&gt; 通配符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定支持版本
对于存在源文件版本需求的处理器，则可以通过重写 &lt;code&gt;SupportedSourceVersion&lt;/code&gt; 或定义 &lt;code&gt;@SupportedSourceVersion&lt;/code&gt; 来指定版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化处理器
注解处理器拥有许多可供使用的工具类，但是这些工具类需要通过 &lt;code&gt;init&lt;/code&gt; 方法的 &lt;code&gt;ProcessingEnvironment&lt;/code&gt; 才可获取，一般做法也是重写此方法，提取所需工具对象保存至处理器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现处理流程
注解处理器的核心流程为 &lt;code&gt;process&lt;/code&gt; 方法，可通过参数 &lt;code&gt;RoundEnvironment&lt;/code&gt; 获取被注解标记的元素，实现想提供的功能，一般为 &lt;code&gt;动态创建源文件&lt;/code&gt; 或 &lt;code&gt;修改语法树&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册处理器
注册注解处理器的方式可以在编译时通过 &lt;code&gt;javac -processor&lt;/code&gt; 指定。
也可以配置自动加载，依照 &lt;code&gt;ServiceLoader&lt;/code&gt; 形式，在 &lt;code&gt;META-INF/services&lt;/code&gt; 下创建名为 &lt;code&gt;javax.annotation.processing.Processor&lt;/code&gt; 的文件，将创建的注解处理器全类名填入，由于注解处理器是作用于编译期的，在编译时需要增加参数 &lt;code&gt;-proc:none&lt;/code&gt; 以不使用注解处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;创建文件&#34;&gt;创建文件&lt;/h2&gt;
&lt;p&gt;文件的创建需要通过 &lt;code&gt;javax.annotation.processing.Filer&lt;/code&gt; 来实现，可通过 &lt;code&gt;init&lt;/code&gt; 方法获取。
通过 Filer 可以新建源文件并获取 &lt;code&gt;JavaFileObject&lt;/code&gt;，以 Java 代码的方法将内容写入源文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapStruct&lt;/code&gt; 和 &lt;code&gt;JavaPoet&lt;/code&gt; 就是利用这个功能开发的工具。&lt;/p&gt;
&lt;h2 id=&#34;修改语法树&#34;&gt;修改语法树&lt;/h2&gt;
&lt;p&gt;对比创建文件，修改语法树则是十分复杂且麻烦的工作，同样要通过 &lt;code&gt;init&lt;/code&gt; 获取语法树构造器 &lt;code&gt;com.sun.source.util.Trees&lt;/code&gt;。
通过 Trees 可以将元素转换为语法树，并接受 &lt;code&gt;Visitor&lt;/code&gt; 以进行语法树节点扫描和修改，一般监视器的实现可以通过继承 &lt;code&gt;TreeTranslator&lt;/code&gt; 或 &lt;code&gt;TreeScanner&lt;/code&gt;，对需要的方法进行重写。&lt;/p&gt;
&lt;p&gt;而语法树操作的难点在于其他方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文档的缺少，这是无疑是对开发人员不友好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不稳定 api，有可能这个版本还能用的，在下一个版本就无效了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未知的异常，可能由于操作失误而引发的，而且通过异常信息无法准确定位问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法很好的控制注解处理器之间的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Lombok&lt;/code&gt; 就是一种修改语法树的工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是我开发的一款通过修改语法树增加方法校验功能的工具: &lt;a href=&#34;https://moyada.github.io/medivh/&#34;&gt;https://moyada.github.io/medivh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>synchronized 原理总结</title>
      <link>https://moyada.github.io/post/java-synchronized/</link>
      <pubDate>Sun, 13 Jan 2019 21:39:24 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-synchronized/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在 Java 中 &lt;code&gt;synchronized&lt;/code&gt; 是用于并发环境下使用临界区的原语。&lt;/p&gt;
&lt;p&gt;它是通过获取对象头的 Mark Word 来实现互斥功能的，当使用方式不同时所操作的对象也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明在方法内时，锁对象由开发者所指定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明在方法上，锁对象则为当前类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明在静态方法上，锁对象就是由类加载器所加载的 Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里简单记录 &lt;code&gt;synchronized&lt;/code&gt; 代码块在虚拟机内部的运转，版本为 OpenJDK11。&lt;/p&gt;
&lt;h2 id=&#34;获取同步锁&#34;&gt;获取同步锁&lt;/h2&gt;
&lt;p&gt;当线程进入临界区时，会根据是否开启了偏向锁选择进入 &lt;code&gt;ObjectSynchronizer::fast_enter&lt;/code&gt; 方法或者 &lt;code&gt;ObjectSynchronizer::slow_enter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&#34;objectsynchronizerfast_enter&#34;&gt;ObjectSynchronizer::fast_enter&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查当前 Mark Word 的锁状态是否为偏向锁，否则进入 &lt;code&gt;slow_enter&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查虚拟机当前是否处于安全点，是则先进行检查是否需要撤销偏向锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查对象头是否为偏向锁模式，否则使用 CAS 修改 Mark Word 存储的线程 id，并初始化获取锁时间点和年龄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当已经处于偏向锁模式时，并且当前占有锁的时间已过期，则可以使用 CAS 进行锁替换或者更新年龄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当任意 CAS 操作失败时，则表明存在其他线程已对锁状态进行了修改，需要执行 &lt;code&gt;slow_enter&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新对象头信息，检查是否需要撤销偏向锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;objectsynchronizerslow_enter&#34;&gt;ObjectSynchronizer::slow_enter&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断 Mark Word 的锁状态是否为无锁或偏向锁，是则使用 CAS 修改对象头，成功后对当前 Region 栈锁进行释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则判断 Mark Word 的锁状态是否为轻量级锁，并且对对象头的 BasicLock 进行加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失败时将修改对象头使其不可重入，并将锁膨胀为重量级锁，修改 Mark Word。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;ObjectMonitor&lt;/code&gt; 管理当前线程，当对象头为轻量级锁时，获取空闲 ObjectMonitor 使用，并配置至对象头内。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ObjectMonitor 的获取方式为依次从 &lt;code&gt;线程空间中查找空闲监视器&lt;/code&gt;、&lt;code&gt;全局空间中查找空闲监视器&lt;/code&gt;、&lt;code&gt;重新创建监视器&lt;/code&gt; 选取尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待与唤醒&#34;&gt;等待与唤醒&lt;/h2&gt;
&lt;h3 id=&#34;wait&#34;&gt;wait&lt;/h3&gt;
&lt;p&gt;当处于临界区内的线程由于某种原因选择将自身挂起时，将执行 &lt;code&gt;ObjectSynchronizer::wait&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断当前 Mark Word 是否为偏向锁，是则对其进行撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放临界区占用锁，获取管理当前线程的的 &lt;code&gt;ObjectMonitor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将线程封装为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 加入至 &lt;code&gt;_WaitSet&lt;/code&gt; 队尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 LoadLoad 内存屏障，防止重排序问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断是否该等待线程是否已经存在，是否重新启动该线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭非运行线程与重入锁的响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断线程是否已被中断，是则抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;notifynotifyall&#34;&gt;notify/notifyAll&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查等待队列 &lt;code&gt;_WaitSet&lt;/code&gt;，为空则直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;_WaitSetLock&lt;/code&gt; 保护操作等待队列不被其他线程干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据策略选择从等待队列中获取元素加入到阻塞队列 &lt;code&gt;_EntryList&lt;/code&gt; 或 &lt;code&gt;_cxq&lt;/code&gt; 或 直接唤醒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置被移动线程为可与重入锁响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放 &lt;code&gt;_WaitSetLock&lt;/code&gt; 锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;阻塞线程&#34;&gt;阻塞线程&lt;/h2&gt;
&lt;h3 id=&#34;enter&#34;&gt;enter&lt;/h3&gt;
&lt;p&gt;当进入临界区的线程获取锁失败时，将交由锁对象的 &lt;code&gt;objectMonitor&lt;/code&gt; 来管理，调用 &lt;code&gt;enter&lt;/code&gt; 方法修改该线程状态为阻塞，并封装为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 加入到名为 &lt;code&gt;_EntryList&lt;/code&gt; 的链表中。&lt;/p&gt;
&lt;h3 id=&#34;exit&#34;&gt;exit&lt;/h3&gt;
&lt;p&gt;当有线程离开临界区，将会调用 objectMonitor 的 &lt;code&gt;exit&lt;/code&gt; 方法，根据 QMode 的不同的选择从 阻塞队列 或 等待队列 中获取 &lt;code&gt;ObjectWaiter&lt;/code&gt;，也可能将等待队列的部分或全部加入阻塞队列后从阻塞队列中获取。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>发布 jar 包至 maven 官方中央仓库</title>
      <link>https://moyada.github.io/post/maven-central/</link>
      <pubDate>Wed, 02 Jan 2019 16:03:12 +0000</pubDate>
      <guid>https://moyada.github.io/post/maven-central/</guid>
      <description>&lt;p&gt;当项目准备发布至 maven 中央仓库时，基本上按照官方指南操作就行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://central.sonatype.org/pages/ossrh-guide.html&#34;&gt;https://central.sonatype.org/pages/ossrh-guide.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;创建发布需求&#34;&gt;创建发布需求&lt;/h2&gt;
&lt;p&gt;在创建问题时需要注意，如果 &lt;code&gt;groupId&lt;/code&gt; 选择的是私有域名时，那么管理员会要求验证域名的归属，而对于 &lt;code&gt;github&lt;/code&gt; 的子域名则无需验证。&lt;/p&gt;
&lt;p&gt;接下来管理员会要求你进行第一次的发布操作，在发布前你需要使用 &lt;code&gt;gpg&lt;/code&gt; 创建你的秘钥。&lt;/p&gt;
&lt;h2 id=&#34;创建秘钥&#34;&gt;创建秘钥&lt;/h2&gt;
&lt;p&gt;Mac 下可以通过 &lt;code&gt;brew&lt;/code&gt; 下载安装，使用命令 &lt;code&gt;gpg --gen-key&lt;/code&gt; 生成，完成后通过 &lt;code&gt;gpg --list-keys&lt;/code&gt; 即可查看已创建秘钥。&lt;/p&gt;
&lt;p&gt;接下来需要将秘钥发布到远程服务器上，如 &lt;code&gt;gpg --keyserver hkp://keyserver.ubuntu.com:11371 --send-keys &amp;lt;sec_key&amp;gt;&lt;/code&gt;，发布后可以使用 &lt;code&gt;gpg --keyserver hkp://keyserver.ubuntu.com:11371 --recv-keys &amp;lt;sec_key&amp;gt;&lt;/code&gt; 进行验证。&lt;/p&gt;
&lt;h2 id=&#34;发布项目&#34;&gt;发布项目&lt;/h2&gt;
&lt;p&gt;发布完成后就可以进行项目的配置了，注意 &lt;code&gt;&amp;lt;gpg.executable&amp;gt;gpg&amp;lt;/gpg.executable&amp;gt;&lt;/code&gt; 这项配置填写的是你实际操作秘钥的程序。&lt;/p&gt;
&lt;p&gt;发布时需要验证秘钥的密码，可以选择添加参数 &lt;code&gt;-Dgpg.passphrase&lt;/code&gt; 或者验证时手动输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果发生错误提示 &lt;code&gt;gpg: signing failed: Inappropriate ioctl for device&lt;/code&gt; 是由于 gpg 无法在当前终端弹出密码输入页面，执行 &lt;code&gt;export GPG_TTY=$(tty)&lt;/code&gt; 以支持弹窗。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果进行本地安装则可以使用 &lt;code&gt;Dgpg.skip&lt;/code&gt; 参数或在 &lt;code&gt;maven-gpg-plugin&lt;/code&gt; 插件下增加配置 &lt;code&gt;&amp;lt;configuration&amp;gt;&amp;lt;skip&amp;gt;true&amp;lt;/skip&amp;gt;&amp;lt;/configuration&amp;gt;&lt;/code&gt; 跳过验证步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;验证发布&#34;&gt;验证发布&lt;/h2&gt;
&lt;p&gt;发布成功后还需要回到需求问题下回复管理员，待管理员回复后一会可在中央仓库查看到自己的项目了。&lt;/p&gt;
&lt;p&gt;后续版本的发布则直接进行发布就可以了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JMX 简介</title>
      <link>https://moyada.github.io/post/java-management/</link>
      <pubDate>Sun, 16 Dec 2018 14:11:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-management/</guid>
      <description>&lt;p&gt;JMX 的全称为 Java Management Extensions，是一种监控、管理正在运行的 Java 应用程序的机制，并且支持开发人员自定义 MBean 监视器。&lt;/p&gt;
&lt;h2 id=&#34;常用-mxbean&#34;&gt;常用 MXBean&lt;/h2&gt;
&lt;p&gt;通过查询 &lt;code&gt;java.lang.management.PlatformManagedObject&lt;/code&gt; 的继承接口能够得知当前 JDK 版本提供的所有 MXBean。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.CompilationMXBean&lt;/td&gt;
&lt;td&gt;编译器的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.ClassLoadingMXBean&lt;/td&gt;
&lt;td&gt;类加载模块的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.BufferPoolMXBean&lt;/td&gt;
&lt;td&gt;堆外内存和映射内存的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryManagerMXBean&lt;/td&gt;
&lt;td&gt;内存管理器的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryMXBean&lt;/td&gt;
&lt;td&gt;虚拟机的内存系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryPoolMXBean&lt;/td&gt;
&lt;td&gt;内存池的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.OperatingSystemMXBean&lt;/td&gt;
&lt;td&gt;操作系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.GarbageCollectorMXBean&lt;/td&gt;
&lt;td&gt;垃圾回收的管理接口，继承至 &lt;code&gt;MemoryManagerMXBean&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.RuntimeMXBean&lt;/td&gt;
&lt;td&gt;虚拟机的运行时系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.ThreadMXBean&lt;/td&gt;
&lt;td&gt;线程的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.PlatformLoggingMXBean&lt;/td&gt;
&lt;td&gt;日志模块的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;javax.management.DynamicMBean&lt;/td&gt;
&lt;td&gt;扩展管理接口，用于自定义管理器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 &lt;code&gt;com.sun.management&lt;/code&gt; 包下，还提供了部分 MXBean 的扩展接口，对原来管理器的功能进行了增强。&lt;/p&gt;
&lt;h2 id=&#34;管理方式&#34;&gt;管理方式&lt;/h2&gt;
&lt;p&gt;监视器的获取方式分为 &lt;code&gt;本地&lt;/code&gt;、&lt;code&gt;远程&lt;/code&gt;、&lt;code&gt;代理&lt;/code&gt;，通常情况下使用远程方式进行管理。&lt;/p&gt;
&lt;h3 id=&#34;本地&#34;&gt;本地&lt;/h3&gt;
&lt;p&gt;对于运行在本机的程序直接使用 &lt;code&gt;java.lang.ManagementFactory&lt;/code&gt; 的静态方法便可以获取。&lt;/p&gt;
&lt;h3 id=&#34;远程&#34;&gt;远程&lt;/h3&gt;
&lt;p&gt;远程模式可以通过建立与其他虚拟机的连接后对其进行操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;String url = &amp;quot;service:jmx:rmi:///jndi/rmi://&amp;quot; + host + &amp;quot;:&amp;quot;+ port + &amp;quot;/&amp;quot; + extend;
JMXServiceURL serviceURL = new JMXServiceURL(url);
JMXConnector conn = JMXConnectorFactory.connect(serviceURL);
MBeanServerConnection connection;
try {
    connection = conn.getMBeanServerConnection();
} catch(IOException e) {
	e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;监听管理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;MemoryMXBean memBean = ManagementFactory.getPlatformMXBean(connection, MemoryMXBean.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代理&#34;&gt;代理&lt;/h3&gt;
&lt;p&gt;由于 Mbean 在注册的时候有 ObjectName 的存在，对于自定义 MBean 则必须使用此方式指定 ObjectName 方可获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MemoryMXBean memBean = ManagementFactory.newPlatformMXBeanProxy(connection, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);

// 指定 MBean 的特定属性值
ObjectName objectName = new ObjectName(&amp;quot;domain:type=name&amp;quot;);
// 对应 getUser 或者 setUser 操作
connection.setAttribute(objectName, new Attribute(&amp;quot;User&amp;quot;,&amp;quot;remote&amp;quot;));
DynamicMBean dynamicMBean = MBeanServerInvocationHandler.newProxyInstance(connection, objectName, DynamicMBean.class, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注册方式&#34;&gt;注册方式&lt;/h2&gt;
&lt;h3 id=&#34;自定义-mbean&#34;&gt;自定义 MBean&lt;/h3&gt;
&lt;p&gt;Java 规范对注册的 MBean 的命名有严格的规范，要求必须是以 MBean 结尾的接口 (MXBean 也行，不过为了与 JDK 的区分，一般使用 MBean)。&lt;/p&gt;
&lt;p&gt;注册的方法也是有标准的，以 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 开头并且参数规范的方法将会被隐藏，对于参数只支持 基本类型、数组、void。隐藏的方法可以通过 &lt;code&gt;属性&lt;/code&gt; 来访问，属性将由 JDK 解析方法名生成。&lt;/p&gt;
&lt;p&gt;为了方便 &lt;code&gt;ManagementFactory&lt;/code&gt; 调用，可以使用提供的 &lt;code&gt;DynamicMBean&lt;/code&gt; 接口进行实现，或者使用更简便的 &lt;code&gt;com.sun.jmx.mbeanserver.StandardMBeanSupport&lt;/code&gt; 进行构建。&lt;/p&gt;
&lt;h3 id=&#34;注册&#34;&gt;注册&lt;/h3&gt;
&lt;p&gt;MBean 的注册管理是通过 &lt;code&gt;javax.management.MBeanServer&lt;/code&gt; 来进行的，并且指定名称 &lt;code&gt;javax.management.ObjectName&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StandardMBeanSupport mbean = new StandardMBeanSupport(new Object(), Interface.class);
MBeanServer beanServer = ManagementFactory.getPlatformMBeanServer();

try {
    final ObjectName objectName;
    try {
        objectName = ObjectName.getInstance(&amp;quot;domain:type=name&amp;quot;);
    } catch (MalformedObjectNameException e) {
        e.printStackTrace();
        return;
    }

    // 跳过 ManagementPermission 的权限校验
    AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Void&amp;gt;() {
        public Void run() throws MBeanRegistrationException, NotCompliantMBeanException {
            try {
                if (beanServer.isRegistered(objectName)) {
                    beanServer.unregisterMBean(objectName); 
                }
                beanServer.registerMBean(mbean, objectName);
                return null;
            } catch (InstanceAlreadyExistsException | InstanceNotFoundException var2) {
                return null;
            }
        }
    });
} catch (PrivilegedActionException e) {
    e.printStackTrace();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;开放端口&#34;&gt;开放端口&lt;/h3&gt;
&lt;p&gt;当需要通过远程进行 Java 应用管理时，就需要通过提供端口以供访问了，通过先前的 MBeanServer 构建 JMX 连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
    LocateRegistry.createRegistry(port);
} catch (RemoteException e) {
    return;
}

try {
    JMXServiceURL url = new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:&amp;quot; + port + &amp;quot;/&amp;quot; + extend);
    JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, beanServer);
    cs.start();
} catch (IOException e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;
&lt;p&gt;对远程开放端口可设置 SSL、权限校验，只需对 JMXConnectorServer 增加配置选项即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; env = new HashMap&amp;lt;String, Object&amp;gt;();
// 对 env 增加配置
...

JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
cs.start(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;开启-ssl-连接&#34;&gt;开启 SSL 连接&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, new SslRMIClientSocketFactory()); 
env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, new SslRMIServerSocketFactory(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;设置权限认证&#34;&gt;设置权限认证&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
SimpleAuthenticator auth = new SimpleAuthenticator();
evn.put(JMXConnectorServer.AUTHENTICATOR, auth);
env.put(&amp;quot;jmx.remote.sasl.callback.handler&amp;quot;, new CallbackHandler() {...}); 


class SimpleAuthenticator implements JMXAuthenticator {

    private final Map&amp;lt;String, Auth&amp;gt; authRole;

    public SimpleAuthenticator() {
        authRole = new HashMap&amp;lt;&amp;gt;();
    }

    public boolean addAuth(String username, String password) {
        return addAuth(username, password, true);
    }

    public boolean addAuth(String username, String password, boolean readOnly) {
        if (authRole.containsKey(username)) {
            return false;
        }
        authRole.put(username, new Auth(password, readOnly));
        return true;
    }

    public boolean removeAuth(String username) {
        return authRole.remove(username) != null;
    }

    @Override
    public Subject authenticate(Object credentials) {
        if (!(credentials instanceof String[])) {
            throw new SecurityException(&amp;quot;Authentication failed!&amp;quot;);
        }
        String[] credentialsInfo = (String[]) credentials;
        if (credentialsInfo.length != 2) {
            throw new SecurityException(&amp;quot;Authentication failed!&amp;quot;);
        }
        String userName = credentialsInfo[0];
        Auth auth = authRole.get(userName);
        if (auth == null) {
            throw new SecurityException(&amp;quot;Invalid Authentication!&amp;quot;);
        }
        String password = credentialsInfo[1];
        if (auth.password.equals(password)) {
            return new Subject(auth.readOnly, Collections.singleton(new JMXPrincipal(userName)), 
                Collections.EMPTY_SET, Collections.EMPTY_SET);
        }
        throw new SecurityException(&amp;quot;Invalid Authentication!&amp;quot;);
    }

    class Auth {
        String password;
        boolean readOnly;

        Auth(String password, boolean readOnly) {
            this.password = password;
            this.readOnly = readOnly;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// Client
String[] credentials = new String[] { &amp;quot;username&amp;quot; , &amp;quot;password&amp;quot; }; 
env.put(JMXConnectorServer.AUTHENTICATOR, credentials);
env.put(&amp;quot;jmx.remote.sasl.callback.handler&amp;quot;, new CallbackHandler() {...}); 
JMXConnector conn = JMXConnectorFactory.connect(serviceURL, env);

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;协议扩展&#34;&gt;协议扩展&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
Security.addProvider(new com.sun.security.sasl.Provider());
env.put(&amp;quot;jmx.remote.profiles&amp;quot;, &amp;quot;TLS SASL/PLAIN&amp;quot;); 
env.put(&amp;quot;jmx.remote.x.access.file&amp;quot;, &amp;quot;config&amp;quot; + File.separator + &amp;quot;access.properties&amp;quot;); 

JMXServiceURL url = new JMXServiceURL(&amp;quot;jmxmp&amp;quot;, null, 5555); 
JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, beanServer); 
cs.start(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// Client
Security.addProvider(new com.sun.security.sasl.Provider());
env.put(&amp;quot;jmx.remote.profiles&amp;quot;, &amp;quot;TLS SASL/PLAIN&amp;quot;); 
JMXServiceURL url = new JMXServiceURL(&amp;quot;jmxmp&amp;quot;, null, port); 
JMXConnector jmxc = JMXConnectorFactory.connect(url, env); 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;详细步骤可见: &lt;a href=&#34;https://docs.oracle.com/cd/E19698-01/816-7609/6mdjrf86r/index.html&#34;&gt;https://docs.oracle.com/cd/E19698-01/816-7609/6mdjrf86r/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;监听&#34;&gt;监听&lt;/h3&gt;
&lt;p&gt;主要用于 JMX 连接状态和 MXBean 调用的监听。&lt;/p&gt;
&lt;p&gt;通过实现 &lt;code&gt;javax.management.NotificationListener&lt;/code&gt; 创建监听处理器，加入到 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 的实现类下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmxConnector.addNotificationListener((notification, handback) -&amp;gt; {...}, null, handback);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要自定义监听广播可以继承 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 或 &lt;code&gt;NotificationEmitterSupport&lt;/code&gt;，其内部已经实现了 addNotificationListener、removeNotificationListener 方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>跨代引用</title>
      <link>https://moyada.github.io/post/card-table/</link>
      <pubDate>Sat, 15 Dec 2018 01:21:34 +0000</pubDate>
      <guid>https://moyada.github.io/post/card-table/</guid>
      <description>&lt;p&gt;在 JVM 虚拟机的内存管理中，有可能存在老年代对象引用新生代的情况，在 &lt;code&gt;Major GC&lt;/code&gt; 时，为了标记这些引用的新生代对象，需要通过扫描老年代来间接标记。&lt;/p&gt;
&lt;p&gt;然而，正常扫描全部老年代来获取的做法效率太低下了，由此便产生了称为 &lt;code&gt;CardTable&lt;/code&gt; (卡表) 的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Card Table&lt;/code&gt; 保存了所在由老年代所引用的新生代对象的集合，同时利用写屏障，在引用对象变化时，对引用记录标记为 &amp;ldquo;脏&amp;rdquo; ，那么当下次 GC 到来时，只用扫描脏页 (&lt;code&gt;Dirty Page&lt;/code&gt;) 便可以标记出由老年代引用的新生代存活对象。并且在 GC 后，由于复制算法导致了数据的迁移，根据迁移的位置决定是否对引用记录再次进行标记。&lt;/p&gt;
&lt;p&gt;在 G1 中，除了 &lt;code&gt;Card Table&lt;/code&gt; 还存在 &lt;code&gt;Remembered Set&lt;/code&gt;，更好的解决了跨代引用的问题。&lt;/p&gt;
&lt;p&gt;它记录了新生代被老生代引用的记录，存活于 &lt;code&gt;Region&lt;/code&gt; 中，对比 &lt;code&gt;Card Table&lt;/code&gt;，&lt;code&gt;Remembered Sets&lt;/code&gt; 只需通过自身就能得知是否存在跨代引用，无需借助老年代。&lt;/p&gt;
&lt;p&gt;配合 G1 回收算法，在对 &lt;code&gt;Region&lt;/code&gt; 进行回收时，无需借助外部数据就能获取全部存活对象，更大的提高了 GC 的效率。&lt;/p&gt;
&lt;p&gt;其实在 G1 中，&lt;code&gt;Remembered Sets&lt;/code&gt; 是借助 &lt;code&gt;Card Table&lt;/code&gt; 来实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html&#34;&gt;http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java安全机制</title>
      <link>https://moyada.github.io/post/java-security/</link>
      <pubDate>Tue, 11 Dec 2018 14:20:10 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-security/</guid>
      <description>&lt;p&gt;Java 安全机制是针对程序在操作本地资源时的权限限制，避免在执行有害代码时 (例如网络上下载的 jar 包)导致不可预估的损失。&lt;/p&gt;
&lt;p&gt;这里简单介绍下使用方法。&lt;/p&gt;
&lt;h2 id=&#34;配置安全策略&#34;&gt;配置安全策略&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建以 &lt;code&gt;.policy&lt;/code&gt; 结尾的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置授权规则，可以参考 Java 默认的策略文件 &lt;code&gt;${java.home}/jre/lib/security/java.policy&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下面配置文件的语法为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant codebase &amp;quot;file:${user.dir}/-&amp;quot; {
    permission java.io.FilePermission &amp;quot;${user.home}/*&amp;quot;, &amp;quot;write&amp;quot;;
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中定义了一条对 &lt;code&gt;${user.dir}/permission/&lt;/code&gt; 路径下所有文件的权限，规定对 &lt;code&gt;${user.home}&lt;/code&gt; 路径下一层级的文件拥有写入权限。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;codebase &amp;quot;url&amp;quot;&lt;/code&gt; 为可选项，表示权限规则的授予目标，不设置则对所有文件生效。也可使用 
&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html##FileSyntax&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;其他目标语法&lt;/a&gt;，或者自定义语法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;permission&lt;/code&gt; 表示一条权限规则，后面需跟随 继承 &lt;code&gt;Permission&lt;/code&gt; 类的全路径类名、构造方法参数，以 &lt;code&gt;;&lt;/code&gt; 结尾，可设置多条规则。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;设置策略文件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;追加策略文件 -Djava.security.policy=my.policy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替换策略文件 -Djava.security.policy==my.policy&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开启安全机制&#34;&gt;开启安全机制&lt;/h2&gt;
&lt;p&gt;一般开启安全机制的方式有两种，设置 JVM 参数，或者通过代码配置。&lt;/p&gt;
&lt;h3 id=&#34;配置-jvm-options&#34;&gt;配置 JVM Options&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-Djava.security.manager 
-Djava.security.policy=my.policy
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码设置&#34;&gt;代码设置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;static {
    String dir = System.getProperty(&amp;quot;user.dir&amp;quot;);
    System.setProperty(&amp;quot;java.security.policy&amp;quot;, dir + &amp;quot;/my.policy&amp;quot;);
    if (System.getSecurityManager() == null) {
        System.setSecurityManager(new SecurityManager());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意在使用代码时会与 &lt;code&gt;JVM Options&lt;/code&gt; 方式冲突，抛出 &lt;code&gt;java.security.AccessControlException: access denied&lt;/code&gt; 异常信息，需要配置权限规则解决，可以选择追加在 Java 策略文件里。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grant {
	permission java.lang.RuntimePermission &amp;quot;setSecurityManager&amp;quot;;
	permission java.util.PropertyPermission &amp;quot;java.security.policy&amp;quot;, &amp;quot;write&amp;quot;;
	permission java.util.PropertyPermission &amp;quot;os.name&amp;quot;, &amp;quot;read&amp;quot;;
	permission java.util.PropertyPermission &amp;quot;user.home&amp;quot;, &amp;quot;read&amp;quot;;
	permission java.util.PropertyPermission &amp;quot;user.dir&amp;quot;, &amp;quot;read&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;跳过权限检查&#34;&gt;跳过权限检查&lt;/h2&gt;
&lt;p&gt;对于开启了安全策略后又不想定义权限规则时，则可以使用 &lt;code&gt;AccessController&lt;/code&gt; 类的 &lt;code&gt;doPrivileged&lt;/code&gt; 方法，跳过 &lt;code&gt;checkPermission&lt;/code&gt; 步骤，直接调用方法体。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
    @Override
    public Object run() {
        ...
        return null;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么你可能会想，这样在其他依赖中也调用此方法不是绕过了安全机制。其实并不会，Java 在打包时会对实现了 &lt;code&gt;PrivilegedAction&lt;/code&gt; 接口的元类信息进行清除，强制调用则会抛出 &lt;code&gt;java.lang.NoClassDefFoundError&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;第三方工具&#34;&gt;第三方工具&lt;/h2&gt;
&lt;p&gt;如果觉得默认的策略规则配置太繁琐了，那么可以使用 &lt;code&gt;pro-grade&lt;/code&gt; 这个第三方依赖，他通过自定义语法简化了规则的配置，具体步骤可以参考
&lt;a href=&#34;http://pro-grade.sourceforge.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;net.sourceforge.pro-grade&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;pro-grade&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.3&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>领域驱动设计学习</title>
      <link>https://moyada.github.io/post/domain-driven-design/</link>
      <pubDate>Sun, 28 Oct 2018 19:54:02 +0000</pubDate>
      <guid>https://moyada.github.io/post/domain-driven-design/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;一个应用系统常常包含许多模块，有基础组件、业务逻辑、数据操作、外部依赖、服务提供等等。但软件系统发展到一定程度时，其复杂性也随之增长，给后期的开发和维护带来难度。&lt;/p&gt;
&lt;p&gt;而领域驱动设计则是针对 &lt;code&gt;复杂性&lt;/code&gt; 的一个解决手段，使架构能够自我进化。同时由于领域驱动设计强调领域模型的重要性，与微服务思想恰到好处，自然被越来越多的架构设计所采纳。&lt;/p&gt;
&lt;p&gt;软件的复杂性，其源头主要是由于对业务需求的抽象设计不足所导致的，按照我在日常开发流程中的接触，认为主要原因是 &lt;code&gt;分工&lt;/code&gt; 所导致的认识不全面，开发人员只关注于需求，没有梳理出项目所需的业务知识。&lt;/p&gt;
&lt;p&gt;一个完整的领域驱动设计周期需要包括 
&lt;a href=&#34;#%e5%bb%ba%e6%a8%a1&#34;&gt;建立业务领域模型&lt;/a&gt;、
&lt;a href=&#34;#%e5%88%86%e6%9e%90%e5%9c%ba%e6%99%af&#34;&gt;分析领域场景&lt;/a&gt;、
&lt;a href=&#34;#%e5%bb%ba%e7%ab%8b%e7%bb%9f%e4%b8%80%e8%af%ad%e8%a8%80&#34;&gt;建立统一语言&lt;/a&gt;、
&lt;a href=&#34;#%e9%99%90%e7%95%8c%e4%b8%8a%e4%b8%8b%e6%96%87&#34;&gt;识别限界上下文&lt;/a&gt;、
&lt;a href=&#34;#%e5%88%86%e5%b1%82%e6%9e%b6%e6%9e%84&#34;&gt;设计分层架构&lt;/a&gt; 这几个阶段。&lt;/p&gt;
&lt;h2 id=&#34;建模&#34;&gt;建模&lt;/h2&gt;
&lt;p&gt;领域建模是领域驱动设计周期中最重要的一个阶段，一个良好的模型设计能使得系统结构清晰整洁、分层合理，对日后的变化达到可进化性、可扩展性、可定制性。&lt;/p&gt;
&lt;p&gt;这个阶段需要先与项目的相关人员都进行沟通，基于对象事件进行分析说明，解决存在困惑，使得成员对业务期望有普遍理解，初步达成领域知识的共识。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，需要对业务建立逻辑模型与物理模型，识别业务需求，将业务逻辑与技术实现进行隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对业务逻辑进行分治、抽象、封装，做到化繁为简，降低系统的复杂性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析识别问题域，根据需求目标的重要性确定其优先级（主要功能与基础功能先之、外部协作功能次之）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Event_storming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;事件风暴&lt;/a&gt; 是一个常用且高效的领域事件建模方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分析场景&#34;&gt;分析场景&lt;/h2&gt;
&lt;p&gt;通过分析业务逻辑提炼场景，才能更好的完善领域模型，常用的方式有 用例、用户故事、测试驱动开发，每个方式的关注点也大相径庭。&lt;/p&gt;
&lt;h2 id=&#34;用例&#34;&gt;用例&lt;/h2&gt;
&lt;p&gt;用例是软件开发中最熟悉的设计方法，它以 &lt;code&gt;领域&lt;/code&gt; 为核心，通过梳理整个流程，抽象出业务领域模型。&lt;/p&gt;
&lt;h2 id=&#34;用户故事&#34;&gt;用户故事&lt;/h2&gt;
&lt;p&gt;相比与用例的抽象，用户故事则是具体的。它将接收特定的事件并根据一定的条件转化为结果进行输出，强调 &lt;code&gt;业务规则&lt;/code&gt; 与 &lt;code&gt;业务流程&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;测试驱动开发&#34;&gt;测试驱动开发&lt;/h2&gt;
&lt;p&gt;测试驱动开发的目的在于对职责进行 &lt;code&gt;拆分&lt;/code&gt;，模拟现实场景分解任务，保证测试任务的粒度足够细。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.jdon.com/mda/archetypes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;四色原型&lt;/a&gt; 是对事件分析的手段，也叫 彩色UML。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;建立统一语言&#34;&gt;建立统一语言&lt;/h2&gt;
&lt;p&gt;统一语言是领域驱动设计之中十分重要的一个环节，其核心价值在于 &lt;code&gt;理解&lt;/code&gt;。在进行需求沟通时，为避免不一致的理解所产生的认识障碍，需要建立出团队中各个成员都理解的的术语进行交流，这一过程就是建立统一语言。&lt;/p&gt;
&lt;p&gt;统一语言体现在两个方面：统一的领域术语、领域行为描述&lt;/p&gt;
&lt;h2 id=&#34;统一的领域术语&#34;&gt;统一的领域术语&lt;/h2&gt;
&lt;p&gt;领域术语的设立目的是为了规避那些表达含义混淆的术语，提高沟通和交流的效率。&lt;/p&gt;
&lt;p&gt;正确的术语建立需要业务人员通过对模型需求进行分析，提炼出概念一致的中英文语言及解释，甚至提供详细的案例说明来确保能够做到表达明确，并通过 &lt;code&gt;术语表&lt;/code&gt; 进行维护。&lt;/p&gt;
&lt;h2 id=&#34;领域行为描述&#34;&gt;领域行为描述&lt;/h2&gt;
&lt;p&gt;领域行为描述是对业务过程的详细解释，遵守且延伸于领域术语，侧重于体现完整的业务需求以及复杂的业务规则。&lt;/p&gt;
&lt;p&gt;根据领域行为描述中的前置条件、业务规则、流程状态、执行结果，并且直接融入编码实现，使得代码逻辑清晰可读，自身就能对领域行为进行描述。&lt;/p&gt;
&lt;h2 id=&#34;限界上下文&#34;&gt;限界上下文&lt;/h2&gt;
&lt;p&gt;限界上下文的含义是保证目标业务流程不受外部因素干扰，即项目的系统架构与组织结构都是可控的。要正确理解限界上下文，就需要对 &lt;code&gt;上下文&lt;/code&gt; 和 &lt;code&gt;边界&lt;/code&gt; 有清晰的认识。&lt;/p&gt;
&lt;h2 id=&#34;上下文&#34;&gt;上下文&lt;/h2&gt;
&lt;p&gt;上下文划分的价值主要体现在三个方面，领域逻辑层面、团队合作层面、技术实现层面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;领域逻辑层面
限界上下文确定了领域模型的业务边界，维护了模型的完整性与一致性，从而降低系统的业务复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;团队合作层面
限界上下文确定了开发团队的工作边界，建立了团队之间的合作模式，避免团队之间的沟通变得混乱，从而降低系统的管理复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术实现层面
限界上下文确定了系统架构的应用边界，保证了系统层和上下文领域层各自的一致性，建立了上下文之间的集成方式，从而降低系统的技术复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;边界&#34;&gt;边界&lt;/h2&gt;
&lt;p&gt;边界的职责是确定限界上下文的 &lt;code&gt;控制力&lt;/code&gt;，体现了高内聚低耦合的思想，主要包括以下几个要素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最小完备
要求限界上下文的控制权在其自身，无需依赖其他上下文的信息，整个业务流程是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自我履行
自我履行是指对外部的请求能够很好的判断该请求是否属性当前上下文的职责范围内，还是应该交付给其他上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定空间
稳定空间就是要对限界上下文拥有掌控权，对外部交互以接口的形式进行抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立进化
指的是当限界上下文发生变化时，不会对外界造成影响，意在服务演化中的兼容性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分层架构&#34;&gt;分层架构&lt;/h2&gt;
&lt;p&gt;软件设计中的分层架构已经成为了开发人员心中的规范了，领域驱动设计也有一套分层的依据与原则。&lt;/p&gt;
&lt;p&gt;分层的方式一般是对系统整体进行水平切分，目的在于打造出抽象层次不同的架构，将业务与技术分离开。&lt;/p&gt;
&lt;p&gt;根据关注点可分为面向用户、面向应用、面向业务、面向资源，业务相关性由低至高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据业务特性，设计适当的分层架构。例如 六边形架构、洋葱圈架构、事件驱动模型、函数式编程、QCRS模式 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;面向资源&#34;&gt;面向资源&lt;/h2&gt;
&lt;p&gt;该层为基础设施层，主要提供了具体的外部资源获取方式，可能有数据库、文件系统、远程通信，属于最稳定的一组服务。&lt;/p&gt;
&lt;h2 id=&#34;面向业务&#34;&gt;面向业务&lt;/h2&gt;
&lt;p&gt;该层为业务流程的拆分，将职责的抽象与实现剥离，提供抽象的接口，隐藏内部的实现。&lt;/p&gt;
&lt;h2 id=&#34;面向应用&#34;&gt;面向应用&lt;/h2&gt;
&lt;p&gt;该层为业务流程的合成，根据业务规则将抽象接口进行组装，通过依赖注入实现接口，提供完整的业务功能。&lt;/p&gt;
&lt;h2 id=&#34;面向用户&#34;&gt;面向用户&lt;/h2&gt;
&lt;p&gt;该层的职责主要提供了外部进程访问领域资源的手段，这里的用户可以是前端接口、远程通信服务。&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/moyada/domain-driven-design-archetype&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于个人理解的六边形架构的 maven archetype 实现&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jdon.com/ddd.html&#34;&gt;https://www.jdon.com/ddd.html&lt;/a&gt;
&lt;a href=&#34;https://www.jianshu.com/p/b6ec06d6b594&#34;&gt;https://www.jianshu.com/p/b6ec06d6b594&lt;/a&gt;
&lt;a href=&#34;https://tech.meituan.com/DDD%20in%20practice.html&#34;&gt;https://tech.meituan.com/DDD%20in%20practice.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java 基准测试框架(JMH)</title>
      <link>https://moyada.github.io/post/jmh/</link>
      <pubDate>Sat, 13 Oct 2018 15:23:53 +0000</pubDate>
      <guid>https://moyada.github.io/post/jmh/</guid>
      <description>&lt;p&gt;在对不同工具做性能对比测试时，由于jvm的运行期优化可能导致结果的偏差。
所以，为了在大程度上避免这种偏差问题，则会用到OpenJDK的性能基准测试项目
&lt;a href=&#34;http://openjdk.java.net/projects/code-tools/jmh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JMH&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;项目构建&#34;&gt;项目构建&lt;/h2&gt;
&lt;p&gt;可以通过maven命令构建项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn archetype:generate \
  -DinteractiveMode=false \
  -DarchetypeGroupId=org.openjdk.jmh \
  -DarchetypeArtifactId=jmh-java-benchmark-archetype \
  -DgroupId=&amp;lt;you_groupId&amp;gt; \
  -DartifactId=&amp;lt;you_artifactId&amp;gt; \
  -Dversion=1.0-SNAPSHOT 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在已有项目中引入依赖包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${jmh.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-generator-annprocess&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${jmh.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;
&lt;h3 id=&#34;注解&#34;&gt;注解&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@State&lt;/td&gt;
&lt;td&gt;配置每个实例的生命周期&lt;/td&gt;
&lt;td&gt;类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@BenchmarkMode&lt;/td&gt;
&lt;td&gt;测试的维度，有吞吐量、平时时间、随机取样、单次运行&lt;/td&gt;
&lt;td&gt;方法、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@OutputTimeUnit&lt;/td&gt;
&lt;td&gt;输出结果的时间单位&lt;/td&gt;
&lt;td&gt;方法、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Warmup&lt;/td&gt;
&lt;td&gt;预热迭代，以保证即时编译的工作&lt;/td&gt;
&lt;td&gt;方法、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Measurement&lt;/td&gt;
&lt;td&gt;设置执行测试迭代的参数&lt;/td&gt;
&lt;td&gt;方法、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Fork&lt;/td&gt;
&lt;td&gt;使用额外虚拟机测试数量&lt;/td&gt;
&lt;td&gt;方法、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Setup&lt;/td&gt;
&lt;td&gt;测试前置执行逻辑&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@TearDown&lt;/td&gt;
&lt;td&gt;测试结束执行逻辑&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Benchmark&lt;/td&gt;
&lt;td&gt;标记该方法需要进行测试，并生成class类&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@Param&lt;/td&gt;
&lt;td&gt;指定参数的测试范围&lt;/td&gt;
&lt;td&gt;属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@CompilerControl&lt;/td&gt;
&lt;td&gt;设置即时编译的效果&lt;/td&gt;
&lt;td&gt;构造器、类、方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;启动&#34;&gt;启动&lt;/h3&gt;
&lt;p&gt;编写 main 方法编译启动或打包成 jar 包运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws RunnerException {
	Options opt = new OptionsBuilder()
	    .include(MyBenchmark.class.getSimpleName())
		.jvmArgs(&amp;quot;-server&amp;quot;, &amp;quot;-Xms2048m&amp;quot;, &amp;quot;-Xmx2048m&amp;quot;)
		.addProfiler(GCProfiler.class)
		.addProfiler(StackProfiler.class)
		.build();

	new Runner(opt).run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lxbjkben/article/details/79410740&#34;&gt;https://blog.csdn.net/lxbjkben/article/details/79410740&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Git 历史记录清洗</title>
      <link>https://moyada.github.io/post/git-filter/</link>
      <pubDate>Tue, 25 Sep 2018 10:11:51 +0000</pubDate>
      <guid>https://moyada.github.io/post/git-filter/</guid>
      <description>&lt;p&gt;当在公网环境下使用 git 仓库不小心把敏感信息提交上去时，则可以使用 &lt;code&gt;filter-branch&lt;/code&gt; 对代码仓库进行清洗。&lt;/p&gt;
&lt;h2 id=&#34;1-先对本地历史进行清洗&#34;&gt;1. 先对本地历史进行清洗&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch &amp;lt;file_path&amp;gt;&#39; --prune-empty --tag-name-filter cat -- --all
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;filter-branch 是让git重写每个分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ndash;force 假如遇到冲突也让git强制执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ndash;index-filter 选项指定重写的时候应该执行什么命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ndash;prune-empty 选项告诉git，如果因为重写导致某些commit变成了空（比如修改的文件全部被删除），那么忽略掉这个commit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ndash;tag-name-filter 表示对每一个tag如何重命名，重命名的命令紧跟在后面，当前的tag名会从标注输入送给后面的命令，用cat就表示保持tag名不变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其后的 &amp;ndash; 表示分割符，最后的 &amp;ndash;all 表示对所有的文件都考虑在内&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-然后更新仓库源引用为刚才的结果&#34;&gt;2. 然后更新仓库源引用为刚才的结果&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git for-each-ref --format=&amp;quot;%(refname)&amp;quot; refs/original/ | xargs -n 1 git update-ref -d

git reflog expire --expire=now --all
git gc --prune=now
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-更新标签&#34;&gt;3. 更新标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git push --all --force
git push --tags --force
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/11822884b924&#34;&gt;https://www.jianshu.com/p/11822884b924&lt;/a&gt;
&lt;a href=&#34;https://blog.csdn.net/lwfcgz/article/details/49453375&#34;&gt;https://blog.csdn.net/lwfcgz/article/details/49453375&lt;/a&gt;
&lt;a href=&#34;https://www.cnblogs.com/developer-ios/p/6211903.html&#34;&gt;https://www.cnblogs.com/developer-ios/p/6211903.html&lt;/a&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/7654822/remove-refs-original-heads-master-from-git-repo-after-filter-branch-tree-filte&#34;&gt;https://stackoverflow.com/questions/7654822/remove-refs-original-heads-master-from-git-repo-after-filter-branch-tree-filte&lt;/a&gt;
&lt;a href=&#34;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-References&#34;&gt;https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-References&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Git 文件忽略</title>
      <link>https://moyada.github.io/post/git-ignore/</link>
      <pubDate>Tue, 25 Sep 2018 09:21:26 +0000</pubDate>
      <guid>https://moyada.github.io/post/git-ignore/</guid>
      <description>&lt;h2 id=&#34;删除仓库文件&#34;&gt;删除仓库文件&lt;/h2&gt;
&lt;p&gt;当不小心提交了不应提交的文件后，可以用此方法处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;git rm -r --cached &amp;lt;file_path&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 &lt;code&gt;.gitignore&lt;/code&gt; 添加忽略文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样本地文件不会删除，但是 git 仓库里的文件则会被标记删除，&lt;/p&gt;
&lt;h2 id=&#34;停止跟踪文件&#34;&gt;停止跟踪文件&lt;/h2&gt;
&lt;p&gt;当有一份文件，只需要一份基础版本，每个机器独自增加配置时，则可以使用
&lt;code&gt;git update-index --assume-unchanged &amp;lt;file_path&amp;gt;&lt;/code&gt;，忽略文件后续的变更。&lt;/p&gt;
&lt;p&gt;当需要对这个基础版本再此迭代时，可以使用&lt;code&gt;git update-index --no-assume-unchanged &amp;lt;file_path&amp;gt;&lt;/code&gt;，重新跟踪文件的修改。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HashMap 在并发环境下的死循环问题</title>
      <link>https://moyada.github.io/post/hashmap-problem/</link>
      <pubDate>Thu, 16 Aug 2018 12:58:33 +0000</pubDate>
      <guid>https://moyada.github.io/post/hashmap-problem/</guid>
      <description>&lt;p&gt;因为 HashMap 是非线程安全的，在并发环境下应避免使用，改为 ConcurrentHashMap。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然在 jdk8 修复了该问题，但仍然还存在其他并发问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其产生的主要原因是扩容时元素的&lt;code&gt;循环引用&lt;/code&gt;，在这里简单描述下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// jdk7 中造成问题的核心代码
void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry&amp;lt;K,V&amp;gt; e : table) {
            while(null != e) {
                Entry&amp;lt;K,V&amp;gt; next = e.next; // 1
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i]; // 2
                newTable[i] = e;
                e = next;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例如 HashMap 中有A, B两个元素，并且哈希值都相等，同处于下标为 &lt;code&gt;0&lt;/code&gt; 的链表中，顺序为 A -&amp;gt; B -&amp;gt; null。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时添加元素C将触发扩容操作，但由于有两个线程同时添加了元素，所以将同时触发两次扩容操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设 &lt;code&gt;线程1&lt;/code&gt; 先进行了扩容操作，但是由于某种原因，在 &lt;code&gt;代码 1&lt;/code&gt; 位置处代码执行完被阻塞了，此时 e = A，next = B。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着 &lt;code&gt;线程2&lt;/code&gt; 顺利的进行了扩容操作，由于重组方式采用的是&lt;code&gt;头插法 (代码 2)&lt;/code&gt;，所以新的链表顺序为 B -&amp;gt; A -&amp;gt; null，将B的next设置为A。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当线程2结束后 &lt;code&gt;线程1&lt;/code&gt; 也恢复了扩容操作，由于当时现场的e = A，next = B，并且 线程2 将 B 的next 设置为了A，所以相比&lt;code&gt;线程2&lt;/code&gt;的扩容将多进行一次 A -&amp;gt; B的操作，这样就造成了 &lt;code&gt;A -&amp;gt; B -&amp;gt; A -&amp;gt; ...&lt;/code&gt; 的环路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当获取一个下标相同但不存在的key时，将发生死循环现象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;用大白话来说，就是你在一堆抽完又放回的扑克牌中取一张不存在的牌。&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://tech.meituan.com/java_hashmap.html&#34;&gt;https://tech.meituan.com/java_hashmap.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>java8 default method 的使用见解</title>
      <link>https://moyada.github.io/post/default-method/</link>
      <pubDate>Thu, 09 Aug 2018 23:58:11 +0000</pubDate>
      <guid>https://moyada.github.io/post/default-method/</guid>
      <description>&lt;p&gt;oracle 在 jdk8 中引入了接口的默认方法，用 &lt;code&gt;default&lt;/code&gt; 关键字标识。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public inteface Listener {
	default void start() {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该原语特性能将接口的 &lt;code&gt;default&lt;/code&gt; 方法以 &lt;code&gt;public&lt;/code&gt; 可见范围赋予所有实现类，同时允许重写。&lt;/p&gt;
&lt;p&gt;由于默认方法是定义在接口上的方法，只能使用接收参数和接口方法，并且是 public 可见范围，导致了使用的局限性。&lt;/p&gt;
&lt;p&gt;在实际开发中的常见场景为，一个功能的主流程固定，并且需由数个方法组成，而方法根据场景可能会有多种实现 (可以对照 &lt;code&gt;Map&lt;/code&gt; 接口理解)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://stackoverflow.com/questions/19998454/interface-with-default-methods-vs-abstract-class-in-java-8&#34;&gt;https://stackoverflow.com/questions/19998454/interface-with-default-methods-vs-abstract-class-in-java-8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java GC过程</title>
      <link>https://moyada.github.io/post/jvm-gc/</link>
      <pubDate>Sun, 15 Jul 2018 12:06:05 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-gc/</guid>
      <description>&lt;p&gt;由于JVM分代设计，GC也根据原因不同而产生不同效果的GC，并且在Java的发展过程中根据不同的GC策略也有不同的过程实现。&lt;/p&gt;
&lt;h2 id=&#34;stop-the-world&#34;&gt;Stop-the-World&lt;/h2&gt;
&lt;p&gt;在 HotSpot 虚拟机中，Stop-the-World 也被称之为 safepoint，在此阶段内，所有运行 Java 代码与 JVM 交互的应用线程将会被挂起。&lt;/p&gt;
&lt;p&gt;以便在执行 GC 复制算法、栈上替换代码、JIT 去优化、清除 code cache、重定义 Class、偏向锁的去除、debug 操作等任务时保证数据的一致性。&lt;/p&gt;
&lt;h2 id=&#34;younggc&#34;&gt;YoungGC&lt;/h2&gt;
&lt;p&gt;发生在新生代的GC称为 &lt;code&gt;Young GC&lt;/code&gt;，也叫 YGC，是 JVM 运行过程中最频繁的GC。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;YoungGC 的产生原因主要是eden区内存不足以分配新对象或者剩余空间达到GC触发条件。
在发生 GC 时，虚拟机会将 &lt;code&gt;eden&lt;/code&gt; 区和 &lt;code&gt;survival from&lt;/code&gt; 区中存活的对象拷贝进 &lt;code&gt;survival to&lt;/code&gt; 区，清理其余对象。&lt;/p&gt;
&lt;h3 id=&#34;parnew&#34;&gt;ParNew&lt;/h3&gt;
&lt;p&gt;需要STW暂停，找出活跃对象，标记为 &lt;code&gt;reachable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;GC ROOTs&lt;/code&gt; 找出活跃的对象，还要根据 &lt;code&gt;CardTable&lt;/code&gt; 的 &lt;code&gt;Dirty&lt;/code&gt; 标记 (晋升至老年代，并且引用新生代对象) 找出老年代引用的新生代对象。&lt;/p&gt;
&lt;p&gt;首先检查老年代的连续可用空间是否可容纳存活对象，如果小于或者不允许担保失败，则需要进行 Full GC。&lt;/p&gt;
&lt;p&gt;检查空间足够则将存活对象进行复制，初始化 MarkWork，将根据年龄选择拷贝对象的目标空间。&lt;/p&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;大体步骤与ParNew类似，也需要 SWT 暂停。
不同的是，G1的 survivor 只有一个区域，并且使用 &lt;code&gt;RegionSet&lt;/code&gt; 来维护块之间的引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1存在一种 &lt;code&gt;Mixed GC&lt;/code&gt;，除了回收新生代之外，还会回收压缩部分老年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;old-gc&#34;&gt;Old GC&lt;/h2&gt;
&lt;p&gt;属于老年代GC的统称，也叫 &lt;code&gt;Old GC&lt;/code&gt;，一般都是伴随着 &lt;code&gt;Young GC&lt;/code&gt; ，主要目的是释放老年代空间，并将相邻对象进行压缩，防止过多的内存碎片。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程-1&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;OldGC的产生原因为YoungGC所需的堆内存空间不足、方法区空间不足、堆内空间达到回收阀值，也有可能人为触发。
发生GC时，标记所有存活对象，可将存活对象进行压缩，对不再使用的类及其子类进行卸载，清理CodeCache，清理弱引用，常量池的清理。&lt;/p&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
暂停所有应用线程，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出老年代边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找所有可到达对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新标记
并发地对上一阶段中引用关系变化的对象进行再标记，然后再暂停应用线程，最后检查是否有发生引用变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发清理
对未标记的对象进行收集，释放空间至空闲列表，此阶段可能将卸载此类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发重置
重新计算堆空间，清理数据，为下一次 GC 周期做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&#34;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;G1 的收集虽然也分为新生代和老年代，但在步骤上其实是有交叉的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
需要暂停应用线程，标记出 &lt;code&gt;Roots&lt;/code&gt;，暂停时间较短，可能会根据 Region 优先级选择执行，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根区域扫描
从标记的存活区域中查找出老年代的引用并进行标记，为了保证数据的正确，在下一次新生代 GC 可能发生之前此阶段必须完成.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找出所有可到达对象，有可能被 &lt;code&gt;Young GC&lt;/code&gt; 打断。过程中还会涉及 &lt;code&gt;SATB&lt;/code&gt;，记录引用关系变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次标记
需要 STW，将上一阶段中引用关系发生变化的对象进行再标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清理
整理对象、更新 &lt;code&gt;RSets&lt;/code&gt; 和将部分老年代加入下次回收周期，需要暂停应用线程，对于清空 Region 加入空闲列表的操作可以并发进行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&#34;&gt;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&lt;/a&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&#34;&gt;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;full-gc&#34;&gt;Full GC&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Full GC&lt;/code&gt; 是对整个堆进行清理的回收算法，包括新生代和老年代。&lt;/p&gt;
&lt;p&gt;在 CMS 中可指定使用并发的 &lt;code&gt;Full GC&lt;/code&gt;，在 JDK10 中 G1 对 &lt;code&gt;Full GC&lt;/code&gt; 也改进为了并发模式。&lt;/p&gt;
&lt;p&gt;除手动触发因素外，&lt;code&gt;Full GC&lt;/code&gt; 的产生通常是由老年代空间不足、方法区空间不足所引起。&lt;/p&gt;
&lt;p&gt;所有的垃圾回收算法都会在 Full GC 时暂停应用线程，因此在对延迟要求高的程序中，Full GC 是应该尽力避免的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>volatile 浅析</title>
      <link>https://moyada.github.io/post/volatile/</link>
      <pubDate>Sat, 14 Jul 2018 18:01:17 +0000</pubDate>
      <guid>https://moyada.github.io/post/volatile/</guid>
      <description>&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;volatile原语保障了多线程下变量的原子性、可见性、有序性。&lt;/p&gt;
&lt;h2 id=&#34;原子性&#34;&gt;原子性&lt;/h2&gt;
&lt;p&gt;在32位虚拟机下对&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;类型的赋值操作会拆分位高位、低位两步完成修改，而volatile可使用内存屏障来达到原子性，保证不存在中间值，但是由于读取的一刻其他线程也有可能改变值，所以复合操作无法达到原子性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;64位下不存在该问题，并且近代jdk中普通操作也能达到原子性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;可见性&#34;&gt;可见性&lt;/h2&gt;
&lt;p&gt;其目的是使多线程环境下对共享变量的修改能被其他线程立即查看到。&lt;/p&gt;
&lt;p&gt;由于线程对变量的读取是先从线程的工作内存(cpu缓存)中获取，不存在才从主内存中获取。&lt;/p&gt;
&lt;p&gt;那么在多线程环境下多普通共享变量的修改操作就会由于cpu缓存中已存在而导致的数据不一致。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，处理器会对编译后指令增加lock指令前缀，大部分处理器架构采用了&lt;code&gt;RingBus&lt;/code&gt; + &lt;code&gt;MESI协议&lt;/code&gt;的方式来解决，部分老版本cpu架构则采用锁总线来达到效果。&lt;/p&gt;
&lt;p&gt;原理是在修改数据时候更新cpu缓存之后立即写回主存、并且通知到使用相同变量线程，将该变量设置为无效，当读取变量时再从主存或者寄存器中获取。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于volatile的可见性，也可用来完成轻量锁的实现，例如线程的终止判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;有序性&#34;&gt;有序性&lt;/h2&gt;
&lt;p&gt;操作系统为了使cpu流水线的各个阶段不存在空闲内核，往往会多当前编译好的指令进行重排序，但是只会保证单条线程的程序正确性，并不保障并发环境下的正确性。&lt;/p&gt;
&lt;p&gt;JVM为了保证volatile域的可见性(happens-before)，会在编译时对指令前后都加入内存屏障指令lock前缀，使得不会将后面的指令重排序到内存屏障之前的位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。&lt;/li&gt;
&lt;li&gt;当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。&lt;/li&gt;
&lt;li&gt;当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;最经典的场景有double check单例，由于重排序，可能出现对象尚未创建成功，但是对象引用缺被赋值使用，造成空指针异常。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java 锁机制</title>
      <link>https://moyada.github.io/post/java-lock/</link>
      <pubDate>Tue, 12 Jun 2018 10:20:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-lock/</guid>
      <description>&lt;h2 id=&#34;synchronized&#34;&gt;synchronized&lt;/h2&gt;
&lt;p&gt;在 jdk1.6 之后,&lt;code&gt;synchronized&lt;/code&gt; 原语通过引入偏向锁、轻量锁进行了优化。&lt;/p&gt;
&lt;p&gt;synchronized 是通过 &lt;code&gt;monitor_enter&lt;/code&gt; 和 &lt;code&gt;monitor_exit&lt;/code&gt; 来控制的，通过 javap 反编译能观察到。&lt;/p&gt;
&lt;p&gt;线程在进入 synchronized 代码块时，将通过获取对象头内 &lt;code&gt;Mark Work&lt;/code&gt; 的锁标记来决定是否进入 临界区。&lt;/p&gt;
&lt;h2 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h2&gt;
&lt;p&gt;没有多线程竞争环境，如果没有设置 &lt;code&gt;-XX:-UseBiasedLocking&lt;/code&gt; 关闭偏向锁的话将会通过 CAS 获取锁，并设置持有锁的线程 id，当该线程再次尝试获取锁时，如果锁内线程为当前线程则直接判断获取锁标记。&lt;/p&gt;
&lt;h2 id=&#34;轻量锁&#34;&gt;轻量锁&lt;/h2&gt;
&lt;p&gt;在多个线程尝试获取偏向锁时，当线程获取偏向锁失败时将会膨胀为轻量锁，通过CAS操作来获取锁标记进入临界区。&lt;/p&gt;
&lt;h2 id=&#34;重量锁&#34;&gt;重量锁&lt;/h2&gt;
&lt;p&gt;如果轻量锁的 CAS 操作失败时，将会升级为重量级锁。&lt;/p&gt;
&lt;p&gt;重量锁依赖底层的 &lt;code&gt;Mutex Lock&lt;/code&gt; 总线锁，需要将用户态切换为内核态，成本较大。&lt;/p&gt;
&lt;h2 id=&#34;重入锁&#34;&gt;重入锁&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;synchronized&lt;/code&gt; 偏向锁和 &lt;code&gt;ReentrantLock&lt;/code&gt; 中都设计了重入锁，&lt;/p&gt;
&lt;h2 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h2&gt;
&lt;p&gt;当多线程环境下，线程获取锁标记或立马释放时，自旋锁就有其意义。&lt;/p&gt;
&lt;p&gt;在 Java 源码的&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 中，线程的出现竞争时就是先是尝试进行自旋锁，之后再进行锁升级。&lt;/p&gt;
&lt;p&gt;自旋锁消除了用户态切换至内核态的上下文切换，但是也增加cpu的消耗。&lt;/p&gt;
&lt;h2 id=&#34;锁降级&#34;&gt;锁降级&lt;/h2&gt;
&lt;p&gt;在jvm进入安全点时，会检测空闲的 &lt;code&gt;monitor&lt;/code&gt; 并对其进行锁降级以提高下次获取锁时的效率。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 jdk9 下使用 Lombok</title>
      <link>https://moyada.github.io/post/lombok-java9/</link>
      <pubDate>Wed, 06 Jun 2018 20:51:56 +0000</pubDate>
      <guid>https://moyada.github.io/post/lombok-java9/</guid>
      <description>&lt;p&gt;由于jdk9中对lombok所依赖的类进行了迁移，所以使用lombok的程序无法直接升级。需按照如下方式升级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;升级lombok依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;lombok.version&amp;gt;1.18.0&amp;lt;/lombok.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;


&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
        &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
        &amp;lt;annotationProcessorPaths&amp;gt;
            &amp;lt;path&amp;gt;
                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt;
            &amp;lt;/path&amp;gt;
        &amp;lt;/annotationProcessorPaths&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;升级maven编译插件及配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;java.version&amp;gt;9&amp;lt;/java.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;source&amp;gt;${java.version}&amp;lt;/source&amp;gt;
        &amp;lt;target&amp;gt;${java.version}&amp;lt;/target&amp;gt;
        &amp;lt;showDeprecation&amp;gt;true&amp;lt;/showDeprecation&amp;gt;
        &amp;lt;showWarnings&amp;gt;true&amp;lt;/showWarnings&amp;gt;
        &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;
        &amp;lt;compilerargs&amp;gt;
            &amp;lt;arg&amp;gt;-Werror&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-Xlint:all&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED&amp;lt;/arg&amp;gt;
            &amp;lt;arg&amp;gt;-J--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED&amp;lt;/arg&amp;gt;
        &amp;lt;/compilerargs&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://github.com/rzwitserloot/lombok/issues/985&#34;&gt;https://github.com/rzwitserloot/lombok/issues/985&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap 原理分析</title>
      <link>https://moyada.github.io/post/concurrenthashmap/</link>
      <pubDate>Sat, 26 May 2018 14:32:42 +0000</pubDate>
      <guid>https://moyada.github.io/post/concurrenthashmap/</guid>
      <description>&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是 jdk 提供的针对并发环境下的集合类容器，是为了解决 &lt;code&gt;HashMap&lt;/code&gt; 在并发环境下的线程安全问题。&lt;/p&gt;
&lt;h2 id=&#34;jdk7&#34;&gt;JDK7&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用分段锁(Segment)和 &lt;code&gt;ReentrantLock&lt;/code&gt; 类实现并发控制的，类中维护了一组 Segment，通过对 key 进行 hash 获取相应的 Segment，Segment 内部维护了一组 HashEntry，类似 HashMap 结构，并且在并发修改阶段对管程进行加锁控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size()&lt;/code&gt; 方法使用的是遍历 Segment 加锁获取，在获取大小的时候会影响数据的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jdk8&#34;&gt;JDK8&lt;/h2&gt;
&lt;p&gt;而 jdk8 中 ConcurrentHashMap 具体的变化有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不在使用分段锁，而是恢复成与 HashMap 相似的结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 hash 算法进行改进，使用高位移到低位异或，避免哈希碰撞。原因是 jdk 的哈希寻址是使用低位，而有些数据的哈希值差异主要在高位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用链表加红黑树的数据结构进行存储，哈希碰撞时使用链表，当链表长度大于 &lt;code&gt;8&lt;/code&gt; 时，将当前链表的数据结构变形为红黑树，这样做的目的是为了解决当链表长度过大而造成的查询开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数据的修改使用了 CAS 和 &lt;code&gt;sychronized&lt;/code&gt; 进行并发控制，原因是 sychronized 在近代 JVM中 已经经过大量优化，性能与 ReentrantLock 差距不大，放弃使用 ReentrantLock 一方面能够节省的内存开销，另一方面能够降低开发成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用了类似 &lt;code&gt;LongAdder&lt;/code&gt; 的数据结构存储大小，并使用了缓存行填充。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免初始开销，延迟加载数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用 Eclipse Memory Analyzer (MAT) 分析内存泄漏</title>
      <link>https://moyada.github.io/post/mat/</link>
      <pubDate>Wed, 23 May 2018 10:18:19 +0000</pubDate>
      <guid>https://moyada.github.io/post/mat/</guid>
      <description>&lt;p&gt;使用MAT分析内存泄漏主要是检测对象是否可达，是否无用。&lt;/p&gt;
&lt;p&gt;通过jmap -dump:format=b,file=[file_name]] [pid] 生成&lt;code&gt;hprof&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;在Eclipse Marketplace安装 Memory Analyzer，打开dump文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意: dump 导出后的内存跟实际监控看到的内存大小不一致的时候, 有可能是使用了&lt;code&gt;堆外内存&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;overview-面板&#34;&gt;Overview 面板&lt;/h2&gt;
&lt;p&gt;Remainder(剩余) 应用 Heap 可分配的内存, 如果可分配内存很小, 则可以考虑加大或者进行优化&lt;/p&gt;
&lt;h2 id=&#34;histogram-面板-类-的角度&#34;&gt;Histogram 面板 (类 的角度)&lt;/h2&gt;
&lt;p&gt;可以查看内存中实例的数量以及占用内存的大小&lt;/p&gt;
&lt;h2 id=&#34;dominator-tree-面板-对象实例-的角度&#34;&gt;Dominator Tree 面板 (对象实例 的角度)&lt;/h2&gt;
&lt;p&gt;按照占用内存由大到小的顺序列举了对象列表情况&lt;/p&gt;
&lt;h2 id=&#34;top-consumers-面板-按类和包进行分组分析大消耗对象&#34;&gt;Top Consumers 面板 (按类和包进行分组分析大消耗对象)&lt;/h2&gt;
&lt;h2 id=&#34;leak-suspects-面板-内存泄漏分析报表&#34;&gt;Leak Suspects 面板 (内存泄漏分析报表)&lt;/h2&gt;
&lt;h2 id=&#34;shallow-size-是指对象本身占用内存的大小-不包含对其他对象的引用&#34;&gt;Shallow size 是指对象本身占用内存的大小, 不包含对其他对象的引用&lt;/h2&gt;
&lt;h2 id=&#34;retained-size-是指-shallow-size--该对象能直接或者间接访问到的对象的-shallow-size-之和也就是指-该对象被-gc-之后所能回收的内存的总和&#34;&gt;Retained size 是指 Shallow size + 该对象能直接或者间接访问到的对象的 Shallow size 之和，也就是指 该对象被 GC 之后所能回收的内存的总和&lt;/h2&gt;
&lt;h2 id=&#34;list-objects&#34;&gt;List Objects&lt;/h2&gt;
&lt;h3 id=&#34;with-incoming-references&#34;&gt;with incoming references&lt;/h3&gt;
&lt;p&gt;查看这个对象持有的外部对象引用&lt;/p&gt;
&lt;h3 id=&#34;with-outcoming-references&#34;&gt;with outcoming references&lt;/h3&gt;
&lt;p&gt;查看这个对象被哪些外部对象引用&lt;/p&gt;
&lt;h2 id=&#34;path-to-gc-roots&#34;&gt;Path To GC Roots&lt;/h2&gt;
&lt;h3 id=&#34;exclude-weak-references&#34;&gt;exclude weak references&lt;/h3&gt;
&lt;p&gt;排除 软引用&lt;/p&gt;
&lt;h3 id=&#34;exclude-soft-references&#34;&gt;exclude soft references&lt;/h3&gt;
&lt;p&gt;排除 弱引用&lt;/p&gt;
&lt;h3 id=&#34;exclude-weaksoft-references&#34;&gt;exclude weak/soft references&lt;/h3&gt;
&lt;p&gt;排除 软／弱引用&lt;/p&gt;
&lt;h3 id=&#34;exclude-all-phantimweaksoft-etc-references&#34;&gt;exclude all phantim/weak/soft etc. references&lt;/h3&gt;
&lt;p&gt;查看 强引用&lt;/p&gt;
&lt;h2 id=&#34;gc-root-unreachable&#34;&gt;GC root Unreachable&lt;/h2&gt;
&lt;p&gt;没有引用标记, 会被回收, 不会产生 leak, 由于没有 GC 发生所以没有被释放&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档:

&lt;a href=&#34;http://www.jianshu.com/p/c8e0f8748ac0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MAT 使用进阶&lt;/a&gt;

&lt;a href=&#34;https://tech.meituan.com/linux-jvm-memory.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;美团技术  Linux 与 JVM 的内存关系&lt;/a&gt;

&lt;a href=&#34;http://www.javatang.com/archives/2017/11/08/11582145.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java内存泄漏分析&lt;/a&gt;

&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21741364&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;追踪 Netty 异常占用堆外内存的经验分享&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java 虚拟机总结</title>
      <link>https://moyada.github.io/post/jvm/</link>
      <pubDate>Sat, 19 May 2018 19:15:57 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm/</guid>
      <description>&lt;h2 id=&#34;jvmjava虚拟机&#34;&gt;JVM(Java虚拟机)&lt;/h2&gt;
&lt;p&gt;JVM 是 JRE 包含的 Java 程序运行所需的程序，屏蔽各种硬件和操作系统的内存访问差异，通用一份 jar 包。
另外，JVM还提供了内存管理的功能，使得开发人员无需关心底层内存如何管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZBJ0u9MaKtM&#34;&gt;https://www.youtube.com/watch?v=ZBJ0u9MaKtM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h2&gt;
&lt;p&gt;Java虚拟机的类加载有加载 (load)、链接 (link)、初始化 (initialize) 三个步骤&lt;/p&gt;
&lt;p&gt;当一个类被实例化时或者类中静态方法被调用时将进行类加载&lt;/p&gt;
&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;
&lt;p&gt;将不同的类数据源以字节码的形式加载到内存中以供类加载器使用，数据的来源可以是 jar 包、class 类、网络数据，一个类数据有且只有一个存在于一个类加载器中。&lt;/p&gt;
&lt;p&gt;正常的类加载是以双亲委任机制，不同的类加载器是以继承的方式链接的，当通过某个类加载器加载一个类数据时，当这个类加载器存在父类加载器时，那么它会先从父类加载器中寻找类数据，不存在再在自身中寻找，并且父类也是遵循这个机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tomcat的类加载器重写了这个加载机制，会优先在自身中查找，这跟Tomcat所加载类的所在位置有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;
&lt;p&gt;链接包含了验证、准备、解析三个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;验证确保了类加载的正确性，它校验了字节码数据是符合Class类规范，常量类型是否支持，语义分析，分析数据流和控制流校验程序语义，符号引用校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备环节是为一个类的静态域分配内存空间，并赋予零值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析负责转化类中的符号引用，将类引用转换为直接引用，将类中的常量值转换为常量池中引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果类字段的字段属性为 &lt;code&gt;ConstantValue&lt;/code&gt;，即同时被 &lt;code&gt;final&lt;/code&gt; 、&lt;code&gt;static&lt;/code&gt; 修饰的基础类型数据，并且在定义时即赋值，如 &lt;code&gt;static final String CONSTANT_COMPILE = &amp;quot;java&amp;quot;;&lt;/code&gt;，那么在准备阶段变量就会被初始化为属性所指定的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;p&gt;对类的静态域赋予正确的初始值，执行静态代码块为赋值静态域。&lt;/p&gt;
&lt;h3 id=&#34;异常&#34;&gt;异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ClassNotFoundException
这种错误是发生在加载环节，当一个类在双亲委任机制中无法获取到时，便会抛出此异常。常见情景是依赖包的冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NoClassDefFoundError
这个错误主要是发生在链接环节的解析中，当一个类的静态域引用至另一个类中的属性，而这个类无法获取时，那么虚拟机就会抛出此异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运行时数据区域&#34;&gt;运行时数据区域&lt;/h2&gt;
&lt;p&gt;Java 虚拟机在运行程序的过程中把内存数据划分为不同的区域&lt;/p&gt;
&lt;h3 id=&#34;线程隔离的指令区&#34;&gt;线程隔离的(指令区)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序计数器：指向线程下一个执行的指令的地址(&lt;code&gt;本地指针&lt;/code&gt;或者&lt;code&gt;起始指令的偏移量&lt;/code&gt;)，当执行的是本地方法时为 undefined。
许多操作都需要依赖程序计数器来完成，例如在时间片抢占后切换线程能够恢复到正确的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈：包含了线程生命周期的方法调用，一个 Java 方法调用即为一个栈帧，根据调用顺序压入线程栈空间。
栈帧存储当前线程运行方法所需要的局部变量表（基本数据类型、对象引用）、操作数栈、动态链接、方法返回地址，保证了多线程下调用方法的隔离性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法区：与虚拟机栈作用相似，区别是执行 native 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程共享的数据区&#34;&gt;线程共享的(数据区)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法区／元空间 (MetaSpace)：存放类信息、静态域数据(对象实例存于堆中)、类编译期间生成的各种字面量和符号引用、字节码、JIT 编译后的机器码、动态代理产生的数据，使用本地内存存储，几乎不会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆 (Heap)：运行时常量池、对象实例域，是垃圾收集管理的主要区域。可分为新生代、老年代。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接内存：用于 NIO 数据交换的内存空间，只受实际内存及 JVM 参数限制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存溢出&#34;&gt;内存溢出&lt;/h3&gt;
&lt;p&gt;内存溢出是由于虚拟机空间分配失败所导致的致命性错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法栈 (StackOverFlowError)
常见原因有递归或大循环调用方法导致栈帧数量过多、线程内定义大量的本地变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆 (OutOfMemoryError)
常量池溢出、线程持续占有对象都将可能导致堆溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区 (OutOfMemoryError)
主要原因为动态创建大量的类，并且卸载无法满足新的元类存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;执行引擎&#34;&gt;执行引擎&lt;/h2&gt;
&lt;h3 id=&#34;解释器-interpreter&#34;&gt;解释器 (Interpreter)&lt;/h3&gt;
&lt;p&gt;解释字节码，执行相应的命令&lt;/p&gt;
&lt;h3 id=&#34;分析器-hotspot-profiler&#34;&gt;分析器 (Hotspot profiler)&lt;/h3&gt;
&lt;p&gt;将频繁调用的热点方法编译成与本地平台相关的机器码&lt;/p&gt;
&lt;h3 id=&#34;jit-即时编译器&#34;&gt;JIT (即时编译器)&lt;/h3&gt;
&lt;p&gt;优化解释器，将字节码翻译成本地平台相关的机器码执行
常见的 JIT 有 C1、C2，在 Java10 引入 Graal&lt;/p&gt;
&lt;p&gt;常见的 JIT 优化手段有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;公共子表达式消除
当一个大表达式已经被计算过后，再次出现已经包含了的表达式则不必重新计算，直接用结果代替。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组边界检查消除
消除大循环体内对元素越界检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法内联
将频繁调用方法替换为调用方法代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逃逸分析
当开启了标量替换 (-XX:+EliminateAllocations) 和逃逸分析 (-XX:+DoEscapeAnalysis) 后，会对线程栈内的对象进行分析，将只存活于栈帧内的可分解对象进行基础类型数据替换处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步消除 (-XX:+EliminateLocks)
在开启逃逸分析和 -server 模式后，将会对无多线程竞争的锁进行消除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化技术&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译器策略：延迟编译，分层编译，栈上替换，延迟优化，程序依赖图表示，静态单赋值表示。&lt;/p&gt;
&lt;p&gt;基于性能监控的优化技术：乐观空值断言，乐观类型断言，乐观类型增强，乐观数组增强，裁剪未被选择的分支，乐观的多态内联。分支频率预测，调用频率预测&lt;/p&gt;
&lt;p&gt;基于证据的优化技术：精确性推断，内存值推断，内存值跟踪，常量折叠，重组，操作符退化，空值检查消除。类型检测退化，类型检测消除，代数化简，公共子表达式消除&lt;/p&gt;
&lt;p&gt;数据流敏感重写：条件常量传播，基于六承载的类型缩减转换，无用代码消除&lt;/p&gt;
&lt;p&gt;语言相关的优化技术：类型继承关系分析，去虚拟机化，符号常量传播，自动装箱，消除逃逸分析，锁消除，锁膨胀，消除反射&lt;/p&gt;
&lt;p&gt;内存及代码位置交换：表达式提升，表达式下沉，冗余存储消除，相邻存储合并，交汇点分离&lt;/p&gt;
&lt;p&gt;循环变换：循环展开，循环剥离，安全点消除，迭代分离，范围检查消除&lt;/p&gt;
&lt;p&gt;局部代码调整：内联，全局代码提升，基于热度的代码分离，Switch 调整&lt;/p&gt;
&lt;p&gt;控制流图变换：本地代码编排，本独代码封包，延迟槽填充，着色图寄存器分配，线性扫描寄存器分配，复写聚合，常量分裂，复写移除，地址模式匹配。指令窥孔优化，基于确定有限状态机的代码生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graal [jdk10]
启动方式 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc垃圾收集器策略&#34;&gt;GC(垃圾收集器)策略&lt;/h2&gt;
&lt;p&gt;Java虚拟机在运行时会产生大量的对象，有些对象将不会再被使用，为了使内存不被这些无用的对象占用，垃圾收集器就需要分析出已经死亡的对象，将其所用空间回收。&lt;/p&gt;
&lt;p&gt;虚拟机从一部分称为 &lt;code&gt;GC Roots&lt;/code&gt; 的节点开始搜索引用链，找出存活的引用 (并非特指对象)，对其余对象标记为虚引用，准备下一阶段进行回收释放内存空间。对重写了 finilize() 方法对象封装并放入队列中，在 GC 结束后单线程执行方法后移除。&lt;/p&gt;
&lt;h3 id=&#34;serial&#34;&gt;Serial&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;标记清除整理&lt;/code&gt; 算法，单线程进行垃圾回收，无上下文切换开销，但 cpu 利用率较低，并且无法与应用线程并行进行。&lt;/p&gt;
&lt;h3 id=&#34;parallel&#34;&gt;Parallel&lt;/h3&gt;
&lt;p&gt;基于吞吐量优先的并行收集器，对年轻代使用 &lt;code&gt;标记复制&lt;/code&gt; 算法，对老年代使用 &lt;code&gt;标记清除整理&lt;/code&gt; 算法，适用于多核处理器，有效利用系统资源。&lt;/p&gt;
&lt;h3 id=&#34;cmsconcurrent-mark-sweep&#34;&gt;CMS(Concurrent Mark Sweep)&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;标记清除&lt;/code&gt; 算法为基础，以响应时间优先的并发收集器，对年轻代使用 &lt;code&gt;标记复制&lt;/code&gt; 算法，对老年代使用 &lt;code&gt;标记清除&lt;/code&gt; 算法。
使用 &lt;code&gt;空闲空间列表&lt;/code&gt; 来管理老年代内存，在老年代 GC 阶段大部分工作可以与应用线程并发执行，并且可在老年代空间内存利用率达到阀值时触发 CMS GC。&lt;/p&gt;
&lt;p&gt;收集工作分为数个阶段：初始标记、并发标记、并发预清理、并发可取消的预清理、最终标记、并发清除、并发重置&lt;/p&gt;
&lt;p&gt;CMS 由于不进行内存整理容易造成老年代内存碎片，并且当堆内存较大时，可能产生不可预估的暂停时间。&lt;/p&gt;
&lt;h3 id=&#34;g1garbage-first&#34;&gt;G1(Garbage-First)&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;复制&lt;/code&gt; 算法为基础，为了能够得到良好的停顿时间而产生的一款实时收集器。
将内存空间以块 (Region) 进行分配空间，一般划分 2048 个，优先回收大垃圾的回收机制。使用空闲空间列表来管理所有内存。&lt;/p&gt;
&lt;p&gt;虚拟机在分配空间时会选定一个 Region(TLAB将分别指定一个Region)，当 Region 的剩余空间不足以分配对象或者小于最小可空间时，将重新指定下一个 Region 分配空间。&lt;/p&gt;
&lt;h4 id=&#34;hregion&#34;&gt;HRegion&lt;/h4&gt;
&lt;p&gt;当分配对象的大小大于 Region 空间的一半，将会分配一个 Humongous Region 直接进入老年代，省略年轻代的内存复制过程，这个 Humongous Region 的大小将为能容纳对象的最小 Region 空格倍数。&lt;/p&gt;
&lt;h4 id=&#34;satb-snapshot-at-the-beginning&#34;&gt;SATB (snapshot-at-the-beginning)&lt;/h4&gt;
&lt;p&gt;对象初始化时的快照，引用变化时使用 &lt;code&gt;write barrier&lt;/code&gt; 进行更新，在 GC 中利用了此列表进行扫描。&lt;/p&gt;
&lt;h4 id=&#34;rset&#34;&gt;RSet&lt;/h4&gt;
&lt;p&gt;与 CMS 不同，G1 使用了记录 Region 引用关系的 &lt;code&gt;Remembered Set&lt;/code&gt; 来记录，内部为多个 &lt;code&gt;Card Table&lt;/code&gt; ，并且是用于记录 &lt;code&gt;被引用&lt;/code&gt; 的对象集合。
使用 &lt;code&gt;三色标记法&lt;/code&gt; + &lt;code&gt;写屏障(write barrier)&lt;/code&gt; 来更新其引用关系。&lt;/p&gt;
&lt;p&gt;G1 解决了 CMS 中的各种疑难问题, 包括暂停时间的可预测性, 并终结了堆内存的碎片化。&lt;/p&gt;
&lt;h3 id=&#34;zgc&#34;&gt;ZGC&lt;/h3&gt;
&lt;p&gt;是一个可伸缩的低延迟垃圾收集器，暂停时间不超过10毫秒，暂停时间不会随堆或实时设置大小而增加&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/renfufei/article/details/54885190&#34;&gt;https://blog.csdn.net/renfufei/article/details/54885190&lt;/a&gt;
&lt;a href=&#34;https://www.zhihu.com/question/53613423/answer/135743258&#34;&gt;https://www.zhihu.com/question/53613423/answer/135743258&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存模型jmm&#34;&gt;内存模型(JMM)&lt;/h2&gt;
&lt;p&gt;heap 根据空间利用率、垃圾回收存活年龄分为年轻代、老年代，永久代。&lt;/p&gt;
&lt;h3 id=&#34;年轻代&#34;&gt;年轻代&lt;/h3&gt;
&lt;p&gt;年轻代又可细分为 Eden空间、S0空间 (From Survivor)、S1空间 (To Survivor)
Eden Space 中存在线程私有的空间 TLAB，是每个线程的缓冲区，存放一些用过即丢弃的对象。&lt;/p&gt;
&lt;h3 id=&#34;老年代&#34;&gt;老年代&lt;/h3&gt;
&lt;p&gt;当新生代的对象超过设定年龄，或者同龄对象达到幸存区的一半，这些对象将被划入老年代(Old Space)。
只有当老年代空间不足分配发生 Full GC 时 (CMS 中可以为 CMS GC)，才会对老年代的数据进行回收。&lt;/p&gt;
&lt;h3 id=&#34;永久代&#34;&gt;永久代&lt;/h3&gt;
&lt;p&gt;用于存放元类数据，在并发标记时和类加载器卸载时将会对相关数据进行回收。
当一个类加载器死亡时，相对应的元数据也被销毁，释放其块空间。&lt;/p&gt;
&lt;h4 id=&#34;permgenspace&#34;&gt;PermgenSpace&lt;/h4&gt;
&lt;p&gt;java8 之前的永久代实现，也称为方法区，为一块固定空间大小，当空间不足时会进行Full GC。
由于区空间大小固定，在大量动态创建类的程序中容易造成OOM。&lt;/p&gt;
&lt;h4 id=&#34;metaspace&#34;&gt;MetaSpace&lt;/h4&gt;
&lt;p&gt;源自 JRockit，在 Java8 与 Hotspot 合并，将 native method area 概念加入 Hotspot，由此得来 MetaSpace 替换原有的 PermGen，容量仅受可用的本地内存限制。&lt;/p&gt;
&lt;p&gt;MetaSpace 的空间是以块 (Chunk) 为单位，这个块的大小取决与申请空间的类加载器类型。&lt;/p&gt;
&lt;p&gt;当类加载器加载类时，从块分配器中获取一份块内存空间存在类元数据，并映射此地址。&lt;/p&gt;
&lt;p&gt;由于每个类加载器申请的块大小不一致，MetaspaceVM 也还未使用压缩技术，这就容易导致内存碎片的产生。&lt;/p&gt;
&lt;h3 id=&#34;tlab&#34;&gt;TLAB&lt;/h3&gt;
&lt;p&gt;当大量线程申请空间时，JVM 需要对并发操作保障不会发生指针碰撞，这样便增加了复杂性，降低性能。&lt;/p&gt;
&lt;p&gt;因此，在 jdk1.6 以后便引入了 TLAB 技术。&lt;/p&gt;
&lt;p&gt;TLAB 全名 Thread-local allocation buffers，是在线程初始化的时候在堆中新生代申请一块线程私有的分配空间(允许所有线程访问)，减少同步开销，使用参数 &lt;code&gt;-XX:UseTLAB&lt;/code&gt; 开启。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/cd85098cca39&#34;&gt;https://www.jianshu.com/p/cd85098cca39&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;plab&#34;&gt;PLAB&lt;/h3&gt;
&lt;p&gt;全名 promotion-local allocation buffers，用于 Young GC 时的空间分配及复制。&lt;/p&gt;
&lt;p&gt;其他还有 CLAB，全名 core-local allocation buffers，用于全局的空间分配。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM 参数</title>
      <link>https://moyada.github.io/post/jvm-param/</link>
      <pubDate>Tue, 24 Apr 2018 21:25:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-param/</guid>
      <description>&lt;style&gt;
table th:nth-of-type(1) {
    width: 250px;
}

table th:nth-of-type(2) {
    width: 30px;
}

table th:nth-of-type(3) {
    width: 300px;
}

table th:nth-of-type(4) {
    width: 150px;
}
&lt;/style&gt;
&lt;h2 id=&#34;空间&#34;&gt;空间&lt;/h2&gt;
&lt;h3 id=&#34;通用&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xms&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 初始化的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmx&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmn&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新生代的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 GC 下建议不设置该参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xss&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;线程栈的大小，默认 1M&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxDirectMemorySize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 NIO 的直接缓存最大容量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SurvivorRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Eden 和 Survior(from和to) 大小比例，默认是 8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:AutoBoxCacheMax=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置自动装箱池缓存大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;server模式专有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveGCBoundary&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态化使用资源&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态调整各个代区的内存大小，每次 minor gc 后会重新计算 eden，from 和 to 的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的初始大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxNewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代和老年代的比例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.noInflation=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时是否使用代理类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.inflationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时生成代理类调用的次数，之后使用 JNI 字节码调用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRAM=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinRAMFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存除数，默认为 4，即堆空间内 MaxRAM 的四分之一&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErgoHeapSizeLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;限制堆内存上限&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之前&#34;&gt;Java8之前&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxPermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之后&#34;&gt;Java8之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxMetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增，初始大小是 21M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java9之后&#34;&gt;Java9之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapRegionSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个区域块大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1M-32M 之间,必须是2的幂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1NewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最小值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MaxNewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最大值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 60%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;
&lt;h3 id=&#34;通用-1&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;虚拟机会以 server 模式运行，该模式与 C2 编译器共同运行，更注重编译的质量，启动速度慢，但是运行效率高，适合用在服务器环境下，针对生产环境进行了优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JVM 启动时就会先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过快速对象分配模式在 TLAB（Thread-local allocation buffers）中进行分配对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以避免大量的线程通信所导致的性能下降&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TLABSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 TLAB 的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-ResizeTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用自动调整 TLAB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseLargePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用最大值内存页&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTransparentHugePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对大对象分配使用大内存页分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseNUMA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象分配优先使用 NUMA 本地内存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PerfDisableSharedMem&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 日志指向 /dev/shm，避免 IO 造成的 JVM 停顿&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShowHiddenFrames&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;展示虚拟机隐藏的栈信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ObjectAlignmentInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 java 对象的内存对齐，默认是 8 字节，指定的值必须是 2 的幂次，且必须在 8 和 256 之间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PageAlignDirectMemory&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置堆外内存使用内存对齐&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedOops&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 64 位环境下，压缩对象头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;原始类型的快速优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastEmptyMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastJNIAccessors&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用类或 int 的成员方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LargePageSizeInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 中内存页的最大值，参数必须是 2 的幂，不可设置过大&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseBiasedLocking&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用偏向锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在存在大量锁对象的创建并高度并发的环境下禁用偏向锁能够带来一定的性能优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:BiasedLockingStartupDelay=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;延迟(秒钟)启用偏向锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XXtlaSize:min=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;,preferred=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调整 TLA，每个线程私有的空间的默认最小大小和默认首选大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysAtomicAccesses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;实现对所有 Access 的原子性保证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启标量替换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DoEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;进行逃逸分析之后，创建的可分解的对象都将由栈上分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;标量替换，栈上分配，受限于栈的空间大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看逃逸分析结果&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateLocks&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分析并且消除无线程竞争下的锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同步消除，必须开启 -XX:+DoEscapeAnalysis 和 -server 模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看标量的替换情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;max number of live nodes in a method&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PositiveIdentityHash&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只允许分配正数的哈希值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EnableJVMCI&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用 Graal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseJVMCICompiler&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Graal JIT编译器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TieredCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用分层编译策略，根据编译器编译、优化的规模与耗时，划分出不同的编译层次&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TieredStopAtLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JIT 编译的最高层级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCodeCacheFlushing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当代码缓存被填满时让 JVM 放弃一些编译代码&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitialCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置初始代码缓存的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ReservedCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置代码缓存的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompileThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发标准的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InterpreterBackwardBranchLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发 OSR 形式的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HugeMethodLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JIT 编译字节码大小超过 size 字节的方法就是巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DontCompileHugeMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不编译巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseCounterDecay&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止 JIT 调用计数器衰减&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CompileCommand=&lt;code&gt;command,method[,option]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定制编译需求，比如过滤某个方法不做 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+InlineSynchronizedMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对同步方法进行内联&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行方法内联前，方法的最多嵌套调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 325&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTrivialSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;归属于不重要的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinInliningThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法被内联的最小调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 250&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRecursiveInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对方法的递归调用做内联优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法内最大存活的 JIT IR 节点数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 20000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ActiveProcessorCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 jvm 使用 cpu 个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseContainerSupport&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;支持容器化功能，默认开启&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCGroupMemoryLimitForHeap&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 CGroup Namespace&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk10 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;gc&#34;&gt;GC&lt;/h2&gt;
&lt;h3 id=&#34;通用-2&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedClassPointers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启压缩类指针&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64 位平台上默认打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代为多线程收集&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以和 CMS GC 一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ParallelRefProcEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并行的处理对象标记过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定并行处理 GC 的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 GC 线程数为 CPU 的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParGCCardsPerStrideChunk=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个线程每次扫描的 Card 数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CardTable 用来标记老年代的某一块内存区域中的对象是否持有新生代对象的引用,卡表的数量取决于老年代的大小和每张卡对应的内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinHeapFreeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定堆内存在使用率以下进行收缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisableExplicitGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止代码中显示调用 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CMS 下可使用 -XX:+ExplicitGCInvokesConcurrent 替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+GCLockerInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的执行 GC Lock&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ConcGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置并行GC的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTenuringThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代经过多少次YGC晋升到老生代&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PretenureSizeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;晋升老年代对象年龄&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无默认值，Paralle Scavenge收集器无法识别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompressedClassSpaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置指针压缩空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;字符串concat优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;选择垃圾收集器为并行收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能和 CMS GC 一起使用,系统吨吐量优先&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCTimeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置吞吐量大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SoftRefLRUPolicyMSPerMB=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每兆空间中软引用的生命周期 (多少毫秒后清除)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xnoclassgc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不对 Class 元数据进行 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseConcMarkSweepGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用 CMS 低停顿垃圾收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelRemarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启并行标记&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;命令JVM无论什么时候调用系统 GC，都执行 CMS GC，而不是 Full GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent &lt;br/&gt; AndUnloadsClasses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保证当有系统 GC 调用时，永久代也被包括进 CMS 垃圾回收的范围内&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSConcurrentMTEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的 CMS 阶段将以多线程执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelInitialMarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启初始标记过程中的并行化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelCMSThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设定 CMS 的线程数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 老年代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingPermOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 永久代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只使用 CMSInitiatingOccupancyFraction 设置的回收阈值，否则交由 JVM 动态调整&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSTriggerRatio&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 CMSInitiatingOccupancyFraction 错误时的生成策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSScavengeBeforeRemark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;重新标记之前对年轻代做一次 Minor GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSClassUnloadingEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 &lt;code&gt;CMS GC&lt;/code&gt; 时对永久代进行垃圾回收(类卸载)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 时会扫描 MetaSpace/PermGen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSFullGCsBeforeCompaction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定进行多少次Full GC之后，执行内存空间整理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 的时候，对年老代的压缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能会影响性能，但是可以消除碎片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseG1GC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用G1垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitiatingHeapOccupancyPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发并发标记周期时的堆内存占用率阈值. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;值为 0 则表示一直执行 GC 循环，默认值为 45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1UseAdaptiveIHOP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启自适应并发标记控制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ConcRefinementThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 Remenbered Set 的工作线程数目&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxGCPauseMillis=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每次年轻代垃圾回收的最长时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseStringDeduplication&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用字符串去重机制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 收集器下生效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCLiveThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动混合垃圾回收周期的老年代占用率阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认占用率为 65%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapWastePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置允许浪费的堆百分比，如果触发回收百分比小于该百分比，JVM 则不会启动混合垃圾回收周期&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCCountTarget=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置标记周期完成后，执行混合垃圾回收老年代的目标次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1OldCSetRegionThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置混合垃圾回收期间要回收的最大旧区域数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ReservePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置作为预留存活区在 heap 中的百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeConcMark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1PrintHeapRegions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 G1 收集器收集的区域&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeRSetStats&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印标记过程引用信息(Print RSet processing information)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1SummarizeRSetStatsPeriod=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 GC 周期频率报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-G1EagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用 G1 优先尝试回收大对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1TraceEagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 在每个 &lt;code&gt;Young GG&lt;/code&gt; 周期都会回收消亡的 Humongous 对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1ConcRegionFreeingVerbose&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Debug JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;zgc&#34;&gt;ZGC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseZGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 ZGC 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java11，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/zgc/Main&#34;&gt;https://wiki.openjdk.java.net/display/zgc/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;shenandoah-gc&#34;&gt;Shenandoah GC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseShenandoahGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Shenandoah 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk12，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahInitFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发垃圾回收的初始阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahMinFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无条件触发垃圾回收的最小空间阀值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocSpikeFactor=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置预留堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahGarbageThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置一个 Region 被视为 &lt;code&gt;可回收&lt;/code&gt; 的垃圾对象所需百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动垃圾回收的空闲堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置上一次垃圾回收周期的分配内存百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahPacing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;根据垃圾回收效率分配应用程序的线程与可用空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahPacingMaxDelay=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在最大延迟时间之前，将不干预应用程序的分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahDegeneratedGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当程序遇到分配失败时，Shenandoah 将会暂停应用线程，直到完成后续垃圾回收工作&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerify&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检测垃圾回收异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahGCHeuristics=[ passive | aggressive ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;暂停应用线程执行垃圾回收 或 执行紧凑的垃圾回收并疏散所有非空 Region&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerifyOptoBarriers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;验证 C2 模式&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;b&gt;Java9之后&lt;/b&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;jvm日志使用 &lt;code&gt;-Xlog[&amp;lt;what&amp;gt;][:[&amp;lt;output&amp;gt;][:[&amp;lt;decorators&amp;gt;][:&amp;lt;output-options&amp;gt;]]]&lt;/code&gt; 记录
可以使用 &lt;code&gt;java -Xlog:help&lt;/code&gt; 查看帮助文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;-Xlog:disable -Xlog:gc+liveness=info,rt*=off:file=../logs/gc_%t.log:time,uptimemillis,pid:filecount=5,filesize=1024
先关闭所有日志，打开 gc 和存活对象的日志，关闭包含 rt 的日志级别，输出日志至文件，额外包含时间、耗时、进程 id，以 5 个 1M 的文件循环保存历史日志文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考:
&lt;a href=&#34;http://www.cnblogs.com/IcanFixIt/p/7259712.html&#34;&gt;http://www.cnblogs.com/IcanFixIt/p/7259712.html&lt;/a&gt;
&lt;a href=&#34;https://juejin.im/post/5a981f056fb9a028bf04bec4&#34;&gt;https://juejin.im/post/5a981f056fb9a028bf04bec4&lt;/a&gt;
&lt;a href=&#34;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&#34;&gt;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/jeps/158&#34;&gt;http://openjdk.java.net/jeps/158&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用-3&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xloggc=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如 -Xloggc=/data/application/logs/gc.log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+verbosegc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCCause&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 GC 的原因&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDetails&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印GC日志详情&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;建议开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCTimeStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以基准时间的形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDateStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以日期的形式，如 2013-05-04T21:53:59.234+0800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErrorFile=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 JVM 出现致命错误时，生成错误文件，包括了导致 jvm crash 的重要信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationStoppedTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 的停顿时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationConcurrentTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 在两次停顿之间的正常运行时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 OutOfMemoryError 时拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpBeforeFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 前拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpAfterFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 后拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HeapDumpPath=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定导出堆的存放路径&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseGCLogFileRotation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启日志文件的循环&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NumberOfGCLogfiles=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;配置日志循环文件个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCLogfileSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定日志文件大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NativeMemoryTracking=[off | summary | detail]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看 JVM 本地方法使用情况&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;p&gt;jcmd &lt;pid&gt; VM.native_memory [summary &amp;amp;##124; detail &amp;amp;##124; baseline &amp;amp;##124; summary.diff &amp;amp;##124; detail.diff &amp;amp;##124; shutdown] [scale= KB &amp;amp;##124; MB &amp;amp;##124; GB] &lt;p/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintNMTStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 JVM 退出时打印 NMT 报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:class&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在程序运行的时候有多少类被加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;verbose:class 来监视 java -verbose:class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:gc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在虚拟机发生内存回收时在输出设备显示信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:jni&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 native 方法调用的相关情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintHeapAtGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行 GC 的前后打印出堆的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsInitial&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示所有可设置参数及默认值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsFinal&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示可以获取到所有设置后参数及值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockDiagnosticVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁对 JVM 进行诊断的选项参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCommandLineFlags&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示出 JVM 初始化完毕后所有跟最初的默认值不同的参数及它们的值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintTenuringDistribution&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内存模型各代信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisplayVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 输出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;记录 JVM 输出到日志&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintJNIGCStalls&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印进入临界区 (JVM 传向 JNI) 的线程信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFLSStatistics=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 前后输出内存的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 &lt;code&gt;size &amp;gt; 1&lt;/code&gt; 时还会输出 IndexedFreeLists 统计信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatisticsCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印自适应收集的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintReferenceGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;跟踪系统内的软引用,弱引用,虚引用和 finallize 队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintClassHistogram&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印出实例的数量以及空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit-1&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInlining&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内联优化的方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简单的输出一些关于从字节码转化成本地代码的编译过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 JIT 的编译信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过使用外部的 disassembler.so 库打印汇编的字节码和 native 方法来辅助分析&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要和-XX:UnlockDiagnosticVMOptions一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassLoading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassUnloading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的卸载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInterpreter&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印解释过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;exclude，跳过编译指定的方法; compileonly，只编译指定的方法; inline/dontinline，设置是否内联指定方法; print，打印生成的汇编代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印JIT编译过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无法使用该参数可以用 -XX:+PrintOptoAssembly 来代替&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1LogLevel=fine, finer, finest&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志包含信息以及每个工作线程的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintStringDeduplicationStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印字符串去重的影响&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否支持远程 JMX 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定远程监控端口号，随机分配 RMI 端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.ssl=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否对连接开启 SSL 加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.authenticate=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否需要开启用户认证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.rmi.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 与远程监控端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.rmi.server.hostname=&lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 服务的对应主机名&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.net.preferIPv4Stack=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;优先使用 IPv4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.security.egd=file:/dev/./urandom&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用非阻塞的随机数与熵池策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.util.concurrent.ForkJoinPool.common.parallelism=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改 ForkJoinPool 的默认线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockExperimentalVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 实验性参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 商业特性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对商业特性进行日志记录&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+FlightRecorder&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 JFR 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FlightRecorderOptions=&lt;code&gt;&amp;lt;parameter&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JFR 监控参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生不可恢复的错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnOutOfMemoryError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生内存溢出错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AggressiveOpts&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用预设的优化參數&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.awt.headless=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用计算能力模拟外设功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如创建图片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>通过 CROS 协议解决跨域问题</title>
      <link>https://moyada.github.io/post/cros/</link>
      <pubDate>Sun, 23 Jul 2017 21:21:48 +0000</pubDate>
      <guid>https://moyada.github.io/post/cros/</guid>
      <description>&lt;p&gt;在前后端交互的开发中可能会遇到跨域的问题，如果只是简单的 GET 请求的话可以利用 Json 来解决。&lt;/p&gt;
&lt;p&gt;对于非 GET 请求的话就可以采用 &lt;code&gt;CORS&lt;/code&gt; 协议来解决了。CORS 是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;rdquo;（Cross-origin resource sharing）。
它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而解决了只能同源使用的限制，具体详解参考
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/04/cors.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跨域资源共享 CORS 详解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要信息的绝对安全，不要依赖 CORS 当中的权限制度，应当使用更多其它的措施来保障，比如 OAuth2。&lt;/p&gt;
&lt;p&gt;对于 Java 服务器的话，常用的解决方案就是自定义个 Filter 来添加相应头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class CorsFilter implements Filter {
	private static final Logger logger = LoggerFactory.getLogger(CorsFilter.class);

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String origin = (String) servletRequest.getRemoteHost()+&amp;quot;:&amp;quot;+servletRequest.getRemotePort();
        logger.info(&amp;quot;orgin: {} request cors resource.&amp;quot;, origin);
        response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;POST, GET, OPTIONS, DELETE&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;3600&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;x-requested-with,Authorization&amp;quot;);
        response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;,&amp;quot;true&amp;quot;);
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {

    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OPTIONS 是预请求必须允许。
Authorization 是做了 OAuth2 登录响应所必须的。
预请求在实际请求之前发出的请求，为了保证实际请求能够完成的权限请求，通过预请求的响应将能够确定实际请求是否的完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 预请求
OPTIONS /cors HTTP/1.1
Origin: http://api.alice.com
// 实际请求类型
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-Custom-Header
Host: api.bob.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...


// 预请求响应
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials（可选）- 表示是否允许cookies
Access-Control-Max-Age（可选） – 以秒为单位的缓存时间，允许时应当尽可能缓存。
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt; 
	&amp;lt;filter-name&amp;gt;cors&amp;lt;/filter-name&amp;gt; 
	&amp;lt;filter-class&amp;gt;CorsFilter&amp;lt;/filter-class&amp;gt; 
&amp;lt;/filter&amp;gt;

&amp;lt;filter-mapping&amp;gt;
	&amp;lt;filter-name&amp;gt;cors&amp;lt;/filter-name&amp;gt;
	&amp;lt;url-pattern&amp;gt;/api/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Spring 中提供了更为简单便捷的方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;@CrossOrigin&lt;/code&gt; 注解来设置跨域访问所允许的域名&lt;/li&gt;
&lt;li&gt;继承 &lt;code&gt;WebMvcConfigurerAdapter&lt;/code&gt; 设置跨域相关配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class CorsConfigurerAdapter extends WebMvcConfigurerAdapter {

	@Override public void addCorsMappings(CorsRegistry registry) {
	 registry.addMapping(&amp;quot;/api/*&amp;quot;).allowedOrigins(&amp;quot;*&amp;quot;); 
	 } 
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;详细参考
&lt;a href=&#34;http://spring.io/guides/gs/rest-service-cors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Maven 基本操作</title>
      <link>https://moyada.github.io/post/maven/</link>
      <pubDate>Fri, 31 Mar 2017 01:42:17 +0000</pubDate>
      <guid>https://moyada.github.io/post/maven/</guid>
      <description>&lt;h2 id=&#34;pom配置文件&#34;&gt;pom配置文件&lt;/h2&gt;
&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mvn clean: 清除target目录&lt;/li&gt;
&lt;li&gt;mvn compile: 编译主程序&lt;/li&gt;
&lt;li&gt;mvn test-compile: 编译测试程序&lt;/li&gt;
&lt;li&gt;mvn test: 执行测试&lt;/li&gt;
&lt;li&gt;mvn package: 打包项目输出到target目录下&lt;/li&gt;
&lt;li&gt;mvn install: 安装项目到本地仓库
安装本地jar包: mvn install:install-file -Dfile=a.jar -DgroupId=com.a -DartifactId=a -Dversion=0.0.1 -Dpackaging=jar&lt;/li&gt;
&lt;li&gt;mvn deploy: 将打包好的包上传到远程仓库,&lt;code&gt;[-N]&lt;/code&gt;跳过子模块&lt;/li&gt;
&lt;li&gt;mvn site: 生成站点&lt;/li&gt;
&lt;li&gt;mvn dependency: 操作依赖
获取远端依赖: mvn dependency:resolve
获取单个远端依赖: mvn dependency:get -Dartifact=&lt;code&gt;&amp;lt;groupId&amp;gt;:&amp;lt;artifactId&amp;gt;:&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳过测试用例 -Dmaven.test.skip=true&lt;/p&gt;
&lt;h3 id=&#34;依赖&#34;&gt;依赖&lt;/h3&gt;
&lt;h4 id=&#34;坐标&#34;&gt;坐标&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;groupid&amp;gt;&lt;/code&gt; 项目坐标: 一般为公司域名倒写+项目名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;artifactId&amp;gt;&lt;/code&gt; 模块坐标: 项目子模块名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; 版本: 带SNAPSHOT表示为一个不稳定的版本，REALEASE表示为一个正式的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;依赖的范围&#34;&gt;依赖的范围&lt;/h4&gt;
&lt;p&gt;依赖的范围可以通过&lt;code&gt;&amp;lt;scope&amp;gt;&lt;/code&gt;标签来指定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;compile: 主程序范围的依赖，对主程序有效，对测试程序有效，参与打包&lt;/li&gt;
&lt;li&gt;test: 测试范围的依赖，只对测试程序有效，不参与打包，比如junit&lt;/li&gt;
&lt;li&gt;provided: 不参与打包，只在开发阶段有效，比如servlet-api.jar&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;依赖的排除&#34;&gt;依赖的排除&lt;/h4&gt;
&lt;p&gt;对于不需要的传递性依赖，可以通过&lt;code&gt;&amp;lt;exclusions&amp;gt;&lt;/code&gt;标签来排除依赖引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	...
	&amp;lt;exclusions&amp;gt;
		&amp;lt;exclusion&amp;gt;
			&amp;lt;groupid&amp;gt;com.xxx&amp;lt;/groupid&amp;gt;
			&amp;lt;artifactid&amp;gt;xxxx&amp;lt;/artifactid&amp;gt;
		&amp;lt;/exclusion&amp;gt;
	&amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;版本号管理&#34;&gt;版本号管理&lt;/h4&gt;
&lt;p&gt;对于多个同版本号的依赖可以通过&lt;code&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;配置来统一管理，在&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;以${标签名}引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
	&amp;lt;com.spring.version&amp;gt;4.3.0-REALEASE&amp;lt;/com.spring.version&amp;gt;
&amp;lt;/properties&amp;gt;
...
&amp;lt;version&amp;gt;${com.spring.version}&amp;lt;/version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，还可以通过&lt;code&gt;&amp;lt;properties&amp;gt;&lt;/code&gt;配置项目默认配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置项目字符集配置 --&amp;gt;
&amp;lt;properties&amp;gt;
	&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;继承&#34;&gt;继承&lt;/h3&gt;
&lt;p&gt;继承功能可以统一管理各个模块工程中对依赖的版本，配置继承后要先安装父工程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 子工程中声明父工程 --&amp;gt;
&amp;lt;parent&amp;gt;
   &amp;lt;groupid&amp;gt;com.xxx&amp;lt;/groupid&amp;gt;
   &amp;lt;artifactId&amp;gt;xxxx&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;!-- 以当前工程的pom.xml为基准的父工程pom.xml路径 --&amp;gt;
   &amp;lt;relativePath&amp;gt;../xxxx/pom.xml&amp;lt;/relativePath&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 父工程依赖管理 --&amp;gt;
&amp;lt;dependencyManagement&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      ...
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;聚合&#34;&gt;聚合&lt;/h3&gt;
&lt;p&gt;聚合用于统一安装子工程模块，在父工程的pom.xml文件中配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;modules&amp;gt;
  &amp;lt;!-- 指定子工程的相对路径 --&amp;gt;
  &amp;lt;module&amp;gt;../xxx&amp;lt;/module&amp;gt;
&amp;lt;/modules&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构建&#34;&gt;构建&lt;/h3&gt;
&lt;p&gt;maven通过命令mvn package 可以将项目打包，对于多模块的项目，
可以使用mvn package -pl 子项目名 -am 或 mvn package &amp;ndash;projects 子项目名 &amp;ndash;also-make
将父项目和子项目一起进行打包同时构建所需依赖&lt;/p&gt;
&lt;p&gt;maven 还可以使用org.codehaus.cargo这个插件直接将项目打包部署到远程服务器上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置构建过程 --&amp;gt;
&amp;lt;build&amp;gt;
  &amp;lt;finalName&amp;gt;工程名&amp;lt;/finalName&amp;gt;
  &amp;lt;!-- 插件 --&amp;gt;
  &amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
      &amp;lt;!-- cargo是启动/停止/配置servlet容器插件 --&amp;gt;
      &amp;lt;groupid&amp;gt;org.codehaus.cargo&amp;lt;/groupid&amp;gt;
      &amp;lt;artifactId&amp;gt;cargo-maven2-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
      &amp;lt;configuration&amp;gt;  
        &amp;lt;container&amp;gt;  
            &amp;lt;containerId&amp;gt;tomcat7x&amp;lt;/containerId&amp;gt;  
            &amp;lt;home&amp;gt;/usr/local/devtools/apache-tomcat-7.0.55&amp;lt;/home&amp;gt;  
        &amp;lt;/container&amp;gt;  
        &amp;lt;configuration&amp;gt;  
            &amp;lt;type&amp;gt;existing&amp;lt;/type&amp;gt;  
            &amp;lt;home&amp;gt;/usr/local/devtools/apache-tomcat-7.0.55&amp;lt;/home&amp;gt;  
            &amp;lt;properties&amp;gt;  
                &amp;lt;!-- 更改监听端口 --&amp;gt;  
                &amp;lt;cargo.servlet.port&amp;gt;8088&amp;lt;/cargo.servlet.port&amp;gt;  
            &amp;lt;/properties&amp;gt;  
        &amp;lt;/configuration&amp;gt; 
      &amp;lt;/configuration&amp;gt;
      &amp;lt;!-- 配置声明周期阶段 --&amp;gt;
      &amp;lt;executions&amp;gt;  
        &amp;lt;execution&amp;gt;  
            &amp;lt;id&amp;gt;cargo-run&amp;lt;/id&amp;gt;  
            &amp;lt;!-- 声明周期的阶段 --&amp;gt;
            &amp;lt;phase&amp;gt;install&amp;lt;/phase&amp;gt;
            &amp;lt;!-- 插件的目标 --&amp;gt;
            &amp;lt;goals&amp;gt;  
                &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;  
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;  
        &amp;lt;execution&amp;gt;  
            &amp;lt;id&amp;gt;clean-deployer&amp;lt;/id&amp;gt;  
            &amp;lt;!-- 声明周期的阶段 --&amp;gt;
            &amp;lt;phase&amp;gt;deploy&amp;lt;/phase&amp;gt;
            &amp;lt;!-- 插件的目标 --&amp;gt;
            &amp;lt;goals&amp;gt;  
                &amp;lt;goal&amp;gt;deployer-undeploy&amp;lt;/goal&amp;gt;  
            &amp;lt;/goals&amp;gt;  
        &amp;lt;/execution&amp;gt;    
      &amp;lt;/executions&amp;gt;  
    &amp;lt;/plugin&amp;gt;
  &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Goals&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:start&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Start a container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:run&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Start a container and wait for the user to press CTRL + C to stop.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Stop a container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:restart&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Stop and start again a container. If the container was not running before calling cargo:restart, it will simply be started.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:configure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Create the configuration for a local container, without starting it. Note that the cargo:start and cargo:run goals will also install the container automatically (but will not call cargo:install).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:package&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Package the local container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:daemon-start&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Start a container via the daemon.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:daemon-stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Stop a container via the daemon.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-deploy (aliased to cargo:deploy)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Deploy a deployable to a running container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-undeploy(aliased to cargo:undeploy)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Undeploy a deployable from a running container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-start&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Start a deployable already installed in a running container.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Stop a deployed deployable without undeploying it.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-redeploy(aliased to cargo:redeploy)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Undeploy and deploy again a deployable. If the deployable was not deployed before calling cargo:deployer-redeploy (or its alias cargo:redeploy) it will simply be deployed.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:uberwar&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Stop a deployed deployable without undeploying it.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:deployer-stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Merge several WAR files into one.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:install&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Installs a container distribution on the file system. Note that the cargo:start goal will also install the container automatically (but will not call cargo:install).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;cargo:help&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Get help (list of available goals, available options, etc.).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;仓库&#34;&gt;仓库&lt;/h2&gt;
&lt;h3 id=&#34;本地仓库&#34;&gt;本地仓库&lt;/h3&gt;
&lt;h3 id=&#34;远程仓库&#34;&gt;远程仓库&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;私服: 搭建在局域网环境中，为局域网范围内的所有Maven工程服务&lt;/li&gt;
&lt;li&gt;中央仓库: 架设在Internet上，为全世界所有Maven工程服务&lt;/li&gt;
&lt;li&gt;中央仓库镜像: 架设在各大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;settingxml配置文件&#34;&gt;setting.xml配置文件&lt;/h2&gt;
&lt;h3 id=&#34;配置maven的本地仓库目录&#34;&gt;配置maven的本地仓库目录&lt;/h3&gt;
&lt;p&gt;localRepository标签&lt;/p&gt;
&lt;h3 id=&#34;设置默认jdk版本&#34;&gt;设置默认jdk版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;profiles&amp;gt;
    &amp;lt;profile&amp;gt;
      &amp;lt;id&amp;gt;jdk-1.8&amp;lt;/id&amp;gt;
      &amp;lt;activation&amp;gt;
        &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
        &amp;lt;jdk&amp;gt;1.8&amp;lt;/jdk&amp;gt;
      &amp;lt;/activation&amp;gt;
      &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;maven.compiler.compilerVersion&amp;gt;1.8&amp;lt;/maven.compiler.compilerVersion&amp;gt;
      &amp;lt;/properties&amp;gt;
    &amp;lt;/profile&amp;gt;
&amp;lt;/profiles&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git的基本操作</title>
      <link>https://moyada.github.io/post/git/</link>
      <pubDate>Sat, 25 Feb 2017 12:53:10 +0000</pubDate>
      <guid>https://moyada.github.io/post/git/</guid>
      <description>&lt;h2 id=&#34;设置基本配置&#34;&gt;设置基本配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;让Git显示颜色，会让命令输出看起来更醒目：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git config \-\-global color.ui true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;设置全局用户信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git config \-\-global user.name &amp;quot;Your Name&amp;quot;
$ git config \-\-global user.email &amp;quot;email@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;记录用户密码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git config credential.helper store
## 设置过期时间
git config credential.helper &#39;cache \-\-timeout=3600&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;增加删除信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git config \-\-list \-\-global
$ git config \-\-global \-\-add user.name xyk
$ git config \-\-get user.name
$ git config \-\-global \-\-unset user.name xyk
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;设置命令别名&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;设置checkout别名为co
$ git config \-\-global alias.co checkout
设置stash别名为sh
$ git config \-\-global alias.co checkout
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简单使用&#34;&gt;简单使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;初始化一个Git仓库，可以使用$ git init命令。
或者$ git clone [-b branch_name] &amp;ldquo;repository_url&amp;rdquo; 从远程仓库拉取&lt;/li&gt;
&lt;li&gt;添加文件到Git仓库，分两步：
第一步，使用命令$ git add &lt;file&gt; 添加文件到暂存区里。
第二步，使用命令$ git commit [-a] -m &amp;ldquo;message&amp;rdquo;，将暂存区的文件提交到本地仓库里。
要随时掌握工作区的状态，使用git status命令。
如果$ git status告诉你有文件被修改过，用$ git diff可以查看修改内容。&lt;/li&gt;
&lt;li&gt;如果需要丢弃未暂存的文件，可以使用$ git checkout [--] &lt;file&gt; 丢弃工作区的文件&lt;/li&gt;
&lt;li&gt;如果需要丢弃已暂存的文件，可以使用$ git reset [HEAD] &lt;file&gt; 丢弃暂存区的文件
移除文件: $ git rm --cached &lt;file&gt;
移动重命名文件: $ git mv &lt;file&gt; &amp;lt;new_file&amp;gt;
将暂存区的文件添加到本地仓库里的最后一次提交: $ git commit --amend&lt;/li&gt;
&lt;li&gt;$ git push origin &amp;lt;branch_name&amp;gt; 提交到远程仓库&lt;/li&gt;
&lt;li&gt;如果本地仓库与远程仓库不属于同一祖先的话，先git pull &amp;lt;remote_name&amp;gt; &lt;branch&gt; --allow-unrelated-histories 同步分支后在提交&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;忽略文件&#34;&gt;忽略文件&lt;/h2&gt;
&lt;p&gt;如果有不需要参与提交的文件，可以创建文件.gitignore，以正则表达式的形式，将不需要的文件表达加入进去:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*~&lt;/td&gt;
&lt;td&gt;将vim中间文件，排除git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.class&lt;/td&gt;
&lt;td&gt;将以class结尾的文件，排除git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*.[ab]&lt;/td&gt;
&lt;td&gt;将以a或b结尾的文件，排除git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;target/&lt;/td&gt;
&lt;td&gt;将第一级的target文件夹，排除git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;**/log&lt;/td&gt;
&lt;td&gt;将所有的log文件夹，排除git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!git.class&lt;/td&gt;
&lt;td&gt;将git.class文件纳入到git管理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;分支&#34;&gt;分支&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;查看分支：$ git branch
创建分支：$ git branch &amp;lt;branch_name&amp;gt;
创建远端分支: $ git checkout -b &amp;lt;branch_name&amp;gt; origin/&amp;lt;branch_name&amp;gt; 或 git fetch origin &amp;lt;branch_name&amp;gt;:&amp;lt;branch_name&amp;gt;
建立远端映射关系: $ git branch -u origin/&amp;lt;branch_name&amp;gt;
切换分支：$ git checkout &amp;lt;branch_name&amp;gt;
创建+切换分支：$ git checkout -b &amp;lt;branch_name&amp;gt;
删除分支：$ git branch -d &amp;lt;branch_name&amp;gt;
删除远端分支: $ git branch -r -d origin/&amp;lt;branch_name&amp;gt;, git push origin :&amp;lt;branch_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要丢弃一个没有被合并过的分支，可以通过$ git branch -D &amp;lt;branch_name&amp;gt;强行删除。&lt;/p&gt;
&lt;h2 id=&#34;贮藏工作现场&#34;&gt;贮藏工作现场&lt;/h2&gt;
&lt;p&gt;Git提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git stash save [-a &amp;quot;stash_name&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用$ git stash list命令可以查看所有工作现场。
恢复有两个办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是用$ git stash apply恢复，但是恢复后，stash内容并不删除，你需要用$ git stash drop &amp;lt;stash_name&amp;gt;来删除；&lt;/li&gt;
&lt;li&gt;另一种方式是用$ git stash pop，恢复的同时把stash内容也删了。
当想要一次性清理全部stash时，可以通过命令$ git stash clear来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;p&gt;标签可以用于给分支打上多个tag，作为版本的标明
从版本tag上新建分支bug分支，用于修复历史版本存在bug。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后通过命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git tag [tagname]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个标签，默认为HEAD，也可以指定一个tag name。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要对历史提交打标签，则需要在后面添加对应的commit id，敲入命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git tag &amp;lt;tagname&amp;gt; &amp;lt;commit_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git tag -a &amp;lt;tagname&amp;gt; -m &amp;quot;version 0.1 released&amp;quot; 3628164
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;还可以通过-s用私钥签名一个标签：
$ git tag -s &lt;tagname&gt;  -m &amp;ldquo;signed version 0.2 released&amp;rdquo; fec145a
签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看所有标签可以用命令: $ git tag&lt;/p&gt;
&lt;p&gt;查看标签信息可以用: $ git show &lt;tagname&gt;&lt;/p&gt;
&lt;p&gt;命令$ git push origin &lt;tagname&gt;可以推送一个本地标签；
命令$ git push origin --tags可以推送全部未推送过的本地标签；
命令$ git tag -d &lt;tagname&gt;可以删除一个本地标签；
命令$ git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。&lt;/p&gt;
&lt;h2 id=&#34;合并&#34;&gt;合并&lt;/h2&gt;
&lt;p&gt;在需要合并某分支到当前分支时:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge &amp;lt;branch_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。
如果想放弃此次合并的话，可以使用命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge \-\-abort
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当合并的分支衍生处在一条分支上时，Git会用Fast forward模式。
如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。&lt;/p&gt;
&lt;p&gt;使用--no-ff参数，可以禁用Fast forward：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge \-\-no-ff -m &amp;quot;merge with no-ff&amp;quot; &amp;lt;branch_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用$ git log --graph命令可以看到分支合并图。
用带参数的git log也可以看到分支的合并情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log \-\-graph \-\-oneline \-\-abbrev-commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;版本操作&#34;&gt;版本操作&lt;/h2&gt;
&lt;h3 id=&#34;查看历史&#34;&gt;查看历史&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查看所有分支的历史示意图:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git log \-\-oneline \-\-stat \-\-decorate \-\-graph \-\-all -p
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看工作区与历史提交之间的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看暂存区与历史提交之间的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff \-\-cached
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看工作区与历史提交之间的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff &amp;lt;commit_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看暂存区与历史提交之间的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff \-\-cached &amp;lt;commit_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看历史提交之间的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff &amp;lt;commit_id&amp;gt; &amp;lt;commit_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看工作区与历史提交的某个文件的单词差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git diff \-\-color-words [\-\-] &amp;lt;file&amp;gt;
$ git diff \-\-word-diff [\-\-] &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;撤销操作&#34;&gt;撤销操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;恢复暂存区某个文件的某个历史版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout &amp;lt;commit_id&amp;gt; [\-\-] &amp;lt;file&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;恢复工作区某个文件的某个历史版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ git reset &amp;lt;commit_id&amp;gt; [\-\-] &amp;lt;file&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;---
清除操作:
$ git clean
-n 查看准备移除工作区文件
-x 移除忽略文件内的表达式的文件
-X 移除忽略文件内的表达式的文件及工作区文件
-f 执行移除工作区文件&lt;/p&gt;
&lt;p&gt;---
移除某次提交的内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git revert &amp;lt;commit_id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改历史&#34;&gt;修改历史&lt;/h3&gt;
&lt;p&gt;替换最后一次提及
$ git commit --amend&lt;/p&gt;
&lt;p&gt;将当前分支设置为另一分支的衍生分支
$ git rebase &amp;lt;branch_name&amp;gt;&lt;/p&gt;
&lt;p&gt;要重返历史版本，可以用$ git reflog查看历史操作，以便确定要回到哪个版本。
版本回退:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HEAD指向的版本就是当前版本，Git允许我们在版本的历史之间穿梭，
~和^均可代表向上一个版本
$ git reset \-\-hard HEAD~  ## 回到上一个版本；
$ git reset \-\-hard HEAD^^  ## 回到上两个版本；
$ git reset \-\-hard &amp;lt;commit_tag&amp;gt;  ## 回退到指定版本。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--hard 使用某次提交的内容还原暂存区和工作区
--mixed 只使用某次提交的内容还原暂存区，并把HEAD和分支引用指向指定的commit
--soft 只把HEAD和分支引用指向指定的commit&lt;/p&gt;
&lt;h2 id=&#34;远程仓库&#34;&gt;远程仓库&lt;/h2&gt;
&lt;h3 id=&#34;创建ssh-key&#34;&gt;创建SSH Key&lt;/h3&gt;
&lt;p&gt;生成ssh密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存ssh密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ eval &amp;quot;$(ssh-agent -s)&amp;quot;
$ ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登陆GitHub，打开“Account settings”，“SSH Keys”页面
点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容
验证ssh密钥&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
Hi xueyikang! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;远程协作&#34;&gt;远程协作&lt;/h2&gt;
&lt;h3 id=&#34;从远程库克隆&#34;&gt;从远程库克隆&lt;/h3&gt;
&lt;p&gt;可以用命令git clone克隆一个本地库：
$ git clone &amp;lt;http_url | ssh_url&amp;gt;
或者建立本地仓库与远程仓库的联系
$ git remote add &amp;lt;origin | else_name&amp;gt; &amp;lt;http_url | ssh_url&amp;gt;&lt;/p&gt;
&lt;p&gt;查看所有远程库的配置信息：
$ git remote -v&lt;/p&gt;
&lt;p&gt;查看远程库的更详细的信息:
$ git remote shop &amp;lt;branch_name&amp;gt;&lt;/p&gt;
&lt;p&gt;重命名远程仓库
$ git remote rename &amp;lt;origin_name&amp;gt; &amp;lt;else_name&amp;gt;&lt;/p&gt;
&lt;p&gt;删除远程仓库
$ git remote rm &amp;lt;origin_name&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;远程库协作&#34;&gt;远程库协作&lt;/h3&gt;
&lt;p&gt;没有关联关系的话需要先要使用命令创建本地分支与远程origin的链接关系：
$ git checkout -b &amp;lt;local_branch_name&amp;gt; origin &amp;lt;remote_branch_name&amp;gt;&lt;/p&gt;
&lt;p&gt;把本地库的所有内容推送到远程库上：
$ git push [-u] origin &amp;lt;branch_name&amp;gt;
我们第一次推送新分支时，加上了-u参数，Git不但会把本地分支内容推送的远程新分支，还会把本地分支和远程分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p&gt;
&lt;p&gt;获取远程分支的最新代码到本地的远程分支上:
$ git fetch [origin [branch_name]&lt;/p&gt;
&lt;p&gt;获取远程分支的最新代码到本地的远程分支上并与本地分支合并:
$ git pull [origin [branch_name]
如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，
用命令建立:$ git branch --set-upstream &amp;lt;local_branch_name&amp;gt; origin &amp;lt;remote_branch_name&amp;gt;。&lt;/p&gt;
&lt;p&gt;如果是是两个不同的项目，则需要先 git pull --allow-unrelated-histories&lt;/p&gt;
&lt;p&gt;删除远程分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push \-\-delete origin &amp;lt;branch_name&amp;gt;
或者
$ git push origin :&amp;lt;branch_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;搭建git服务器&#34;&gt;搭建Git服务器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装git：
$ sudo apt-get install git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个git用户，用来运行git服务：
$ sudo adduser git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建证书登录：
收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化Git仓库：
先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：
$ sudo git init --bare sample.git
Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：
$ sudo chown -R git:git sample.git&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用shell登录：
出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：
git❌1001:1001:,,,:/home/git:/bin/bash
改为：
git❌1001:1001:,,,:/home/git:/usr/bin/git-shell
这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;克隆远程仓库：
现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：
$ git clone git@server:/srv/sample.gitCloning into &amp;lsquo;sample&amp;rsquo;&amp;hellip;warning: You appear to have cloned an empty repository.
剩下的推送就简单了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;管理公钥&#34;&gt;管理公钥&lt;/h2&gt;
&lt;p&gt;如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。
这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。
管理权限
有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。
这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mux.alimama.com/posts/711&#34;&gt;https://mux.alimama.com/posts/711&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
