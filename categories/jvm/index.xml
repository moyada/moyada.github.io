<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM | 不睡觉的猫头鹰</title>
    <link>https://moyada.github.io/categories/jvm/</link>
      <atom:link href="https://moyada.github.io/categories/jvm/index.xml" rel="self" type="application/rss+xml" />
    <description>JVM</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><copyright>© 2017 - 2020 moyada</copyright><lastBuildDate>Sun, 04 Aug 2019 13:30:02 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=true) shape:circle]</url>
      <title>JVM</title>
      <link>https://moyada.github.io/categories/jvm/</link>
    </image>
    
    <item>
      <title>Shenandoah GC 介绍</title>
      <link>https://moyada.github.io/post/shenandoah-gc/</link>
      <pubDate>Sun, 04 Aug 2019 13:30:02 +0000</pubDate>
      <guid>https://moyada.github.io/post/shenandoah-gc/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Shenandoah GC 是 OpenJDK 在 JDK12 推出的新一代 &lt;code&gt;标记整理&lt;/code&gt; 的垃圾回收器，它的目标时为了使大容量内存应用在垃圾回收时只进行短暂的应用暂停，使用 -XX:+UseShenandoahGC 开启。&lt;/p&gt;
&lt;p&gt;它能够在垃圾回收周期中进行 &lt;code&gt;并发整理&lt;/code&gt; 和 &lt;code&gt;并发更新&lt;/code&gt;，不暂停应用线程，并将垃圾回收分解为多个阶段，来达到极短的暂停时间，同时不会随着堆内存大小而影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=VCeHkcwfF9Q&#34;&gt;https://www.youtube.com/watch?v=VCeHkcwfF9Q&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=E1M3hNlhQCg&#34;&gt;https://www.youtube.com/watch?v=E1M3hNlhQCg&lt;/a&gt;
&lt;a href=&#34;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&#34;&gt;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&#34;&gt;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&#34;&gt;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;并发复制&#34;&gt;并发复制&lt;/h3&gt;
&lt;p&gt;Shenandoah GC 是如何做到并发复制的呢？这主要是利用了 &lt;code&gt;读屏障&lt;/code&gt; 和 &lt;code&gt;Brooks Pointers&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://rkennke.wordpress.com/2013/10/23/shenandoah-gc-brooks-pointers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brooks Pointers&lt;/a&gt; 是为了保证并发环境下数据一致性而设计的字段，它在对象地址中占用了 8 位地址来标识实际对象地址的偏移值。&lt;/p&gt;
&lt;p&gt;通常情况下它指向当前对象地址自身，当进入并发整理的对象拷贝阶段时，GC 将会利用 CAS 操作替换新的地址偏移值，并保证只进行一次成功的操作。&lt;/p&gt;
&lt;p&gt;当应用线程操作该对象时将会使用 &lt;code&gt;读屏障&lt;/code&gt; 获取 &lt;code&gt;brooks pointers&lt;/code&gt; 偏移值再计算得出实际地址返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hotspot/share/gc/shenandoah/shenandoahBrooksPointer.inline.hpp

inline oop ShenandoahBrooksPointer::forwardee(oop obj) {
  shenandoah_assert_correct(NULL, obj);
  return oop(*brooks_ptr_addr(obj));
}

inline HeapWord** ShenandoahBrooksPointer::brooks_ptr_addr(oop obj) {
  return (HeapWord**)((HeapWord*) obj + word_offset());
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于通常情况下并不需要使用读屏障来获取地址，Shenandoah GC 又引入了 &lt;code&gt;slow path&lt;/code&gt; 的设计。&lt;/p&gt;
&lt;p&gt;它的作用是，只有当垃圾回收进行中，并且对象处于 &lt;code&gt;collection set&lt;/code&gt; 中，那么程序才会使用 读屏障 来获取对象地址。&lt;/p&gt;
&lt;p&gt;同时 Shenandoah GC 还会对字节码进行优化，以确保程序正确的情况下减少用读屏障获取地址的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/concurrent-copy.png&#34; alt=&#34;concurrent-copy&#34; title=&#34;并发修改&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于需要使用额外的空间来存储 &lt;code&gt;brooks pointers&lt;/code&gt;，则必须使用 64 位地址，同时堆空间也会增加 3% ~ 15% 的开销，而 CAS 和 读屏障 则产生 2% ~ 20% 的吞吐量下降。&lt;/p&gt;
&lt;h3 id=&#34;空间划为&#34;&gt;空间划为&lt;/h3&gt;
&lt;p&gt;Shenandoah 与 G1 类似也是以 Region 来划分堆内存，但是不进行分代标记。&lt;/p&gt;
&lt;p&gt;每个 Region 对应一个数组用来表示有哪些 Region 存在对象指向自身 Region 中的对象，这就避免了 G1 在年轻代之间的引用关系需要扫描整个年轻代甚至是堆的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/region-incoming.png&#34; alt=&#34;region-incoming&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;numa&#34;&gt;NUMA&lt;/h3&gt;
&lt;p&gt;与 ZGC 相同，利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的 CPU 缓存，并且使 应用线程 与 GC线程 处于同一核心线程下，共享同一个 Region 的数据。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;从 &lt;code&gt;hotspot/share/gc/shenandoah/shenandoahControlThread.cpp::run_service()&lt;/code&gt; 可以观察到 Shenandoah GC 的垃圾收回触发策略，将会根据 内存分配情况 或 提交的垃圾回收事件 &lt;code&gt;_requested_gc_cause&lt;/code&gt; 来决定所执行的具体垃圾回收流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  switch (mode) {
    case none:
      break;
    case concurrent_traversal:
      service_concurrent_traversal_cycle(cause);
      break;
    case concurrent_normal:
      service_concurrent_normal_cycle(cause);
      break;
    case stw_degenerated:
      service_stw_degenerated_cycle(cause, degen_point);
      break;
    case stw_full:
      service_stw_full_cycle(cause);
      break;
    default:
      ShouldNotReachHere();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;Shenandoah 的回收过程与 G1 类似，都是基于 Region 的收集策略，一般情况下将垃圾回收声明周期分解成数个阶段执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/shenandoah-gc-cycle.png&#34; alt=&#34;shenandoah-gc-cycle&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，扫描 GC Roots。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;b&gt;并发标记&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与应用程序并发进行，通过上一阶段的 GC Roots 遍历堆，使用 STAB 算法描绘存活对象图谱。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，处理位于队列中的标记和更新操作，并预先进行下一阶段，可能与下一阶段同时完成。&lt;/p&gt;
&lt;p&gt;收集存在死亡对象的 Region&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将无存活对象的 Region 进行清理并加入空闲列表。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;b&gt;并发疏散&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将收集集合中的对象复制至空闲 Region 中，此阶段不会造成应用线程暂停。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;初始更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;短暂的暂停应用线程，只确保疏散操作均已完成。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;b&gt;并发更新引用&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历堆中对象，更新疏散对象的引用。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;最终更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，堆当前的 Root Set 进行更新，对收集集合的 Region 进行回收。&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回收无任何对象引用的 Region。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ZGC 介绍</title>
      <link>https://moyada.github.io/post/zgc/</link>
      <pubDate>Fri, 28 Jun 2019 20:12:10 +0000</pubDate>
      <guid>https://moyada.github.io/post/zgc/</guid>
      <description>&lt;h2 id=&#34;什么是-zgc&#34;&gt;什么是 ZGC&lt;/h2&gt;
&lt;p&gt;由于现在系统日趋增长的内存，传统的垃圾回收器在整理阶段需要花费更长的时间，为了提高 jvm 在大容量内存应用的回收效率，一款新的垃圾回收器 ZGC 在 JDK11 上正式公布问世。通过配置参数 -XX:+UseZGC 开启，目前仅支持 Linux x86 64位的系统。&lt;/p&gt;
&lt;p&gt;ZGC 全称 Z Garbage Collector，是一款 &lt;code&gt;低停顿&lt;/code&gt; 的标记整理垃圾收集器，它能够在大部分时间与应用线程并行运行。ZGC 在 Oracle 官方资料中表明能够保证垃圾回收中最高 &lt;code&gt;10毫秒&lt;/code&gt; 的停顿，而作为低停顿的代价也只是最多下降 15% 的总吞吐量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://openjdk.java.net/projects/zgc/&#34;&gt;https://openjdk.java.net/projects/zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7k_XfLGu-Ts&#34;&gt;https://www.youtube.com/watch?v=7k_XfLGu-Ts&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=kF_r3GE3zOo&#34;&gt;https://www.youtube.com/watch?v=kF_r3GE3zOo&lt;/a&gt;
&lt;a href=&#34;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&#34;&gt;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&#34;&gt;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&lt;/a&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&#34;&gt;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&#34;&gt;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7cWiwu7kYkE&#34;&gt;https://www.youtube.com/watch?v=7cWiwu7kYkE&lt;/a&gt;
&lt;a href=&#34;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&#34;&gt;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/gc-concurrent.png&#34; alt=&#34;gc-concurrent&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;基于-region-的并发收集模式&#34;&gt;基于 Region 的并发收集模式&lt;/h3&gt;
&lt;p&gt;ZGC 与 G1 类似，也是以 Region 划分堆内存结构的，不同的是，ZGC 中 Region 是以大小进行分组的，分别是 Small (2MB)、Medium (32MB)、Large (N*MB)，并且尚未进行分代。由于没有了分代，也就没有了 &lt;code&gt;CardTable&lt;/code&gt; 和 &lt;code&gt;RememberedSet&lt;/code&gt; 的开销。&lt;/p&gt;
&lt;h3 id=&#34;使用-numa架构技术httpsenwikipediaorgwikinon-uniform_memory_access高效的分配空间和进行对象的扫描&#34;&gt;使用 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Non-uniform_memory_access&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NUMA架构技术&lt;/a&gt;高效的分配空间和进行对象的扫描&lt;/h3&gt;
&lt;p&gt;利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的节点缓存，使线程在操作自身创建的对象时提高效率。&lt;/p&gt;
&lt;h3 id=&#34;设计颜色指针标记对象状态保障引用关系一致&#34;&gt;设计颜色指针标记对象状态，保障引用关系一致&lt;/h3&gt;
&lt;p&gt;颜色指针就好比状态机，ZGC 在对象地址的其中 4bit 的空间用于标记&lt;code&gt;颜色&lt;/code&gt;状态，这四个字节分别称之 &lt;code&gt;Finalizable&lt;/code&gt;、 &lt;code&gt;Remapped&lt;/code&gt; 、&lt;code&gt;Marked1&lt;/code&gt;、 &lt;code&gt;Marked0&lt;/code&gt;，通过在不同的收集阶段对指定标记的状态检测，从而采取不同的执行动作。&lt;/p&gt;
&lt;p&gt;由于需要额外的空间来存储标记，因此不支持 32 位平台和指针压缩。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Makred0、 Marked1 用于识别对象在垃圾回收周期中是否被标记存活，存在两个的原因是因为一个被标记的对象可能来自上一个回收周期并未重新映射，此类对象则只需进行映射而无需重定位。&lt;/li&gt;
&lt;li&gt;Remapped 表明该引用对象需要从地址映射表中获取新地址并转移。&lt;/li&gt;
&lt;li&gt;Finalizable 表示这是一个 finalizar 对象，只有 Finalizer 可以对其进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体逻辑见 &lt;code&gt;hotspot/share/gc/z/zAddress.hpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.cpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.inline.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;利用-读屏障-修改引用来提高对象的整理迁移功能&#34;&gt;利用 读屏障 修改引用来提高对象的整理迁移功能&lt;/h3&gt;
&lt;p&gt;对比 G1 使用 &lt;code&gt;写屏障&lt;/code&gt; 来保证引用关系一致，ZGC 则是使用 &lt;code&gt;读屏障&lt;/code&gt; 来达到。&lt;/p&gt;
&lt;p&gt;在应用线程与 GC 线程同时操作同一对象时，通过读屏障检测对象状态，通过 CAS 对重映射对象进行迁移。&lt;/p&gt;
&lt;p&gt;这种设计使得无需暂停应用线程就能保证引用正确，而读屏障的性能开销只有约 4%。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;hotspot/share/gc/z/zDirector.cpp&lt;/code&gt; 中可得知，ZGC 与其他 GC 的回收策略有所不同，是一种主动式的垃圾回收模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ZDirector::run_service() {
  // Main loop
  while (_metronome.wait_for_tick()) {  // 1
    sample_allocation_rate();
    const GCCause::Cause cause = make_gc_decision(); // 2
    if (cause != GCCause::_no_gc) {
      ZCollectedHeap::heap()-&amp;gt;collect(cause);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;wait_for_tick&lt;/code&gt; 中，JVM 会利用时钟计算等待时间，当到达唤醒时间并且不在安全点期间则执行后续逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make_gc_decision&lt;/code&gt; 是根据条件返回回收策略，包含 4 种可执行垃圾回收的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;** 定时执行 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断当前时间距离上次垃圾回收的差值，当时间差值大于设定的间隔时间时则触发垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 内存预热 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据堆内存使用率判断是否进行垃圾回收，当每突破一个 10% 值时进行垃圾回收，例如超过 20%、30% 时。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 吞吐量过大 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对比剩余空间所需分配时间与最久 GC 时间差值，当大于指定间距时 (默认 0.1) 则说明存在空间不足分配的可能性，需要进行垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 主动触发 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当距离上次垃圾回收已经过了 5 分钟同时堆空间上涨了 10%，并且距离上次 GC 的时间大于最久 GC 时间的 49 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当这些条件满足时 JVM 将会调用 Monitor (synchronized 底层线程安全模块) 唤醒线程，&lt;code&gt;异步&lt;/code&gt; 执行垃圾回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;ZGC 的回收过程几乎是完全并发进行的，只会在三个阶段进行短短的暂停: 标记开始(mark-start)、标记结束(mark-final)、迁移开始(relocate-start)，具体流程可见于 &lt;code&gt;src/hotspot/share/gc/z/zDriver.cpp::run_gc_cycle()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/phases.png&#34; alt=&#34;zgc-phases&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;【标记开始】&lt;/strong&gt; 开始标记时，会暂停所有应用线程，标记出堆中的 
&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/gcroots.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GC Roots&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-start.png&#34; alt=&#34;mark-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发标记】&lt;/strong&gt; 释放应用线程，通过 GC Roots 遍历堆中所有对象，找出存活的对象集合 (类似一个 bitmap)。应用线程利用&lt;code&gt;读屏障&lt;/code&gt;将对象的变化信息保存于线程中，之后转交由 GC 线程处理引用关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-mark.png&#34; alt=&#34;concurrent-mark&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;【标记结束】&lt;/strong&gt; 完成所有对象的标记后，短时暂停应用线程，完成标记阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-final.png&#34; alt=&#34;mark-final&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发准备】&lt;/strong&gt; 为下一阶段的重定位做准备，收集那些垃圾对象占比最大或最多的 page 加入 &lt;code&gt;relocate set&lt;/code&gt;，每个 page 都分配一个 &lt;code&gt;forwarding table&lt;/code&gt; 保存重定向地址，还进行一些其他数据的清理 (比如软弱虚引用、Finalizer 对象、字符串常量池、元数据)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/prepare.png&#34; alt=&#34;prepare&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;【迁移开始】&lt;/strong&gt; 暂停应用线程，扫描 GC Roots 的指向对象，对 &lt;code&gt;relocate set&lt;/code&gt; 内对象进行迁移并将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt;。将本地线程状态设置为 &lt;code&gt;bad mask&lt;/code&gt;，对应用线程内对迁移对象的引用标记为 &lt;code&gt;Remapped relocate&lt;/code&gt;。分配大块连续空间，以便能够存放要迁移的对象，申请一下阶段所需的工作线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/relocate-start.png&#34; alt=&#34;relocate-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发迁移】&lt;/strong&gt; 对 &lt;code&gt;relocate set&lt;/code&gt; 中 page 里剩余的存活对象进行迁移，将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt; 中。应用线程在操作 &lt;code&gt;Remapped relocate&lt;/code&gt; 对象时将通过读屏障进行重新映射地址，同时 GC线程 也对程序内的对象引用进行重映射。当映射地址与原地址一致时则表明所有引用均已重映射，标记 page 在之后清除释放空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-relocate.png&#34; alt=&#34;concurrent-relocate&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如未重映射对象在下一垃圾回收周期也被标记，则该对象则不会进行分配重定位地址，为了达到这一区别所以才有了 &lt;code&gt;Makred0&lt;/code&gt;、 &lt;code&gt;Marked1&lt;/code&gt; 两个标记标识。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;停顿时间不会随着堆空间的大小增长，但是与 GC Root 的数量是成正比，而 GC Root 的数量则与应用线程的数量有关。
在 GC 的周期内，标记开始和迁移开始操作会比较花费时间，但所有停顿时间总共也是小于 10 毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>synchronized 原理总结</title>
      <link>https://moyada.github.io/post/java-synchronized/</link>
      <pubDate>Sun, 13 Jan 2019 21:39:24 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-synchronized/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在 Java 中 &lt;code&gt;synchronized&lt;/code&gt; 是用于并发环境下使用临界区的原语。&lt;/p&gt;
&lt;p&gt;它是通过获取对象头的 Mark Word 来实现互斥功能的，当使用方式不同时所操作的对象也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明在方法内时，锁对象由开发者所指定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明在方法上，锁对象则为当前类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明在静态方法上，锁对象就是由类加载器所加载的 Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里简单记录 &lt;code&gt;synchronized&lt;/code&gt; 代码块在虚拟机内部的运转，版本为 OpenJDK11。&lt;/p&gt;
&lt;h2 id=&#34;获取同步锁&#34;&gt;获取同步锁&lt;/h2&gt;
&lt;p&gt;当线程进入临界区时，会根据是否开启了偏向锁选择进入 &lt;code&gt;ObjectSynchronizer::fast_enter&lt;/code&gt; 方法或者 &lt;code&gt;ObjectSynchronizer::slow_enter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&#34;objectsynchronizerfast_enter&#34;&gt;ObjectSynchronizer::fast_enter&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查当前 Mark Word 的锁状态是否为偏向锁，否则进入 &lt;code&gt;slow_enter&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查虚拟机当前是否处于安全点，是则先进行检查是否需要撤销偏向锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查对象头是否为偏向锁模式，否则使用 CAS 修改 Mark Word 存储的线程 id，并初始化获取锁时间点和年龄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当已经处于偏向锁模式时，并且当前占有锁的时间已过期，则可以使用 CAS 进行锁替换或者更新年龄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当任意 CAS 操作失败时，则表明存在其他线程已对锁状态进行了修改，需要执行 &lt;code&gt;slow_enter&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新对象头信息，检查是否需要撤销偏向锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;objectsynchronizerslow_enter&#34;&gt;ObjectSynchronizer::slow_enter&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断 Mark Word 的锁状态是否为无锁或偏向锁，是则使用 CAS 修改对象头，成功后对当前 Region 栈锁进行释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则判断 Mark Word 的锁状态是否为轻量级锁，并且对对象头的 BasicLock 进行加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失败时将修改对象头使其不可重入，并将锁膨胀为重量级锁，修改 Mark Word。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;ObjectMonitor&lt;/code&gt; 管理当前线程，当对象头为轻量级锁时，获取空闲 ObjectMonitor 使用，并配置至对象头内。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ObjectMonitor 的获取方式为依次从 &lt;code&gt;线程空间中查找空闲监视器&lt;/code&gt;、&lt;code&gt;全局空间中查找空闲监视器&lt;/code&gt;、&lt;code&gt;重新创建监视器&lt;/code&gt; 选取尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;等待与唤醒&#34;&gt;等待与唤醒&lt;/h2&gt;
&lt;h3 id=&#34;wait&#34;&gt;wait&lt;/h3&gt;
&lt;p&gt;当处于临界区内的线程由于某种原因选择将自身挂起时，将执行 &lt;code&gt;ObjectSynchronizer::wait&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断当前 Mark Word 是否为偏向锁，是则对其进行撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放临界区占用锁，获取管理当前线程的的 &lt;code&gt;ObjectMonitor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将线程封装为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 加入至 &lt;code&gt;_WaitSet&lt;/code&gt; 队尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 LoadLoad 内存屏障，防止重排序问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断是否该等待线程是否已经存在，是否重新启动该线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭非运行线程与重入锁的响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断线程是否已被中断，是则抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;notifynotifyall&#34;&gt;notify/notifyAll&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查等待队列 &lt;code&gt;_WaitSet&lt;/code&gt;，为空则直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;_WaitSetLock&lt;/code&gt; 保护操作等待队列不被其他线程干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据策略选择从等待队列中获取元素加入到阻塞队列 &lt;code&gt;_EntryList&lt;/code&gt; 或 &lt;code&gt;_cxq&lt;/code&gt; 或 直接唤醒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置被移动线程为可与重入锁响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放 &lt;code&gt;_WaitSetLock&lt;/code&gt; 锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;阻塞线程&#34;&gt;阻塞线程&lt;/h2&gt;
&lt;h3 id=&#34;enter&#34;&gt;enter&lt;/h3&gt;
&lt;p&gt;当进入临界区的线程获取锁失败时，将交由锁对象的 &lt;code&gt;objectMonitor&lt;/code&gt; 来管理，调用 &lt;code&gt;enter&lt;/code&gt; 方法修改该线程状态为阻塞，并封装为 &lt;code&gt;ObjectWaiter&lt;/code&gt; 加入到名为 &lt;code&gt;_EntryList&lt;/code&gt; 的链表中。&lt;/p&gt;
&lt;h3 id=&#34;exit&#34;&gt;exit&lt;/h3&gt;
&lt;p&gt;当有线程离开临界区，将会调用 objectMonitor 的 &lt;code&gt;exit&lt;/code&gt; 方法，根据 QMode 的不同的选择从 阻塞队列 或 等待队列 中获取 &lt;code&gt;ObjectWaiter&lt;/code&gt;，也可能将等待队列的部分或全部加入阻塞队列后从阻塞队列中获取。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JMX 简介</title>
      <link>https://moyada.github.io/post/java-management/</link>
      <pubDate>Sun, 16 Dec 2018 14:11:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/java-management/</guid>
      <description>&lt;p&gt;JMX 的全称为 Java Management Extensions，是一种监控、管理正在运行的 Java 应用程序的机制，并且支持开发人员自定义 MBean 监视器。&lt;/p&gt;
&lt;h2 id=&#34;常用-mxbean&#34;&gt;常用 MXBean&lt;/h2&gt;
&lt;p&gt;通过查询 &lt;code&gt;java.lang.management.PlatformManagedObject&lt;/code&gt; 的继承接口能够得知当前 JDK 版本提供的所有 MXBean。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.CompilationMXBean&lt;/td&gt;
&lt;td&gt;编译器的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.ClassLoadingMXBean&lt;/td&gt;
&lt;td&gt;类加载模块的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.BufferPoolMXBean&lt;/td&gt;
&lt;td&gt;堆外内存和映射内存的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryManagerMXBean&lt;/td&gt;
&lt;td&gt;内存管理器的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryMXBean&lt;/td&gt;
&lt;td&gt;虚拟机的内存系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.MemoryPoolMXBean&lt;/td&gt;
&lt;td&gt;内存池的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.OperatingSystemMXBean&lt;/td&gt;
&lt;td&gt;操作系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.GarbageCollectorMXBean&lt;/td&gt;
&lt;td&gt;垃圾回收的管理接口，继承至 &lt;code&gt;MemoryManagerMXBean&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.RuntimeMXBean&lt;/td&gt;
&lt;td&gt;虚拟机的运行时系统的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.ThreadMXBean&lt;/td&gt;
&lt;td&gt;线程的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;java.lang.management.PlatformLoggingMXBean&lt;/td&gt;
&lt;td&gt;日志模块的管理接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;javax.management.DynamicMBean&lt;/td&gt;
&lt;td&gt;扩展管理接口，用于自定义管理器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 &lt;code&gt;com.sun.management&lt;/code&gt; 包下，还提供了部分 MXBean 的扩展接口，对原来管理器的功能进行了增强。&lt;/p&gt;
&lt;h2 id=&#34;管理方式&#34;&gt;管理方式&lt;/h2&gt;
&lt;p&gt;监视器的获取方式分为 &lt;code&gt;本地&lt;/code&gt;、&lt;code&gt;远程&lt;/code&gt;、&lt;code&gt;代理&lt;/code&gt;，通常情况下使用远程方式进行管理。&lt;/p&gt;
&lt;h3 id=&#34;本地&#34;&gt;本地&lt;/h3&gt;
&lt;p&gt;对于运行在本机的程序直接使用 &lt;code&gt;java.lang.ManagementFactory&lt;/code&gt; 的静态方法便可以获取。&lt;/p&gt;
&lt;h3 id=&#34;远程&#34;&gt;远程&lt;/h3&gt;
&lt;p&gt;远程模式可以通过建立与其他虚拟机的连接后对其进行操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;String url = &amp;quot;service:jmx:rmi:///jndi/rmi://&amp;quot; + host + &amp;quot;:&amp;quot;+ port + &amp;quot;/&amp;quot; + extend;
JMXServiceURL serviceURL = new JMXServiceURL(url);
JMXConnector conn = JMXConnectorFactory.connect(serviceURL);
MBeanServerConnection connection;
try {
    connection = conn.getMBeanServerConnection();
} catch(IOException e) {
	e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;监听管理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;MemoryMXBean memBean = ManagementFactory.getPlatformMXBean(connection, MemoryMXBean.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代理&#34;&gt;代理&lt;/h3&gt;
&lt;p&gt;由于 Mbean 在注册的时候有 ObjectName 的存在，对于自定义 MBean 则必须使用此方式指定 ObjectName 方可获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MemoryMXBean memBean = ManagementFactory.newPlatformMXBeanProxy(connection, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);

// 指定 MBean 的特定属性值
ObjectName objectName = new ObjectName(&amp;quot;domain:type=name&amp;quot;);
// 对应 getUser 或者 setUser 操作
connection.setAttribute(objectName, new Attribute(&amp;quot;User&amp;quot;,&amp;quot;remote&amp;quot;));
DynamicMBean dynamicMBean = MBeanServerInvocationHandler.newProxyInstance(connection, objectName, DynamicMBean.class, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注册方式&#34;&gt;注册方式&lt;/h2&gt;
&lt;h3 id=&#34;自定义-mbean&#34;&gt;自定义 MBean&lt;/h3&gt;
&lt;p&gt;Java 规范对注册的 MBean 的命名有严格的规范，要求必须是以 MBean 结尾的接口 (MXBean 也行，不过为了与 JDK 的区分，一般使用 MBean)。&lt;/p&gt;
&lt;p&gt;注册的方法也是有标准的，以 &lt;code&gt;set&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 开头并且参数规范的方法将会被隐藏，对于参数只支持 基本类型、数组、void。隐藏的方法可以通过 &lt;code&gt;属性&lt;/code&gt; 来访问，属性将由 JDK 解析方法名生成。&lt;/p&gt;
&lt;p&gt;为了方便 &lt;code&gt;ManagementFactory&lt;/code&gt; 调用，可以使用提供的 &lt;code&gt;DynamicMBean&lt;/code&gt; 接口进行实现，或者使用更简便的 &lt;code&gt;com.sun.jmx.mbeanserver.StandardMBeanSupport&lt;/code&gt; 进行构建。&lt;/p&gt;
&lt;h3 id=&#34;注册&#34;&gt;注册&lt;/h3&gt;
&lt;p&gt;MBean 的注册管理是通过 &lt;code&gt;javax.management.MBeanServer&lt;/code&gt; 来进行的，并且指定名称 &lt;code&gt;javax.management.ObjectName&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;StandardMBeanSupport mbean = new StandardMBeanSupport(new Object(), Interface.class);
MBeanServer beanServer = ManagementFactory.getPlatformMBeanServer();

try {
    final ObjectName objectName;
    try {
        objectName = ObjectName.getInstance(&amp;quot;domain:type=name&amp;quot;);
    } catch (MalformedObjectNameException e) {
        e.printStackTrace();
        return;
    }

    // 跳过 ManagementPermission 的权限校验
    AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Void&amp;gt;() {
        public Void run() throws MBeanRegistrationException, NotCompliantMBeanException {
            try {
                if (beanServer.isRegistered(objectName)) {
                    beanServer.unregisterMBean(objectName); 
                }
                beanServer.registerMBean(mbean, objectName);
                return null;
            } catch (InstanceAlreadyExistsException | InstanceNotFoundException var2) {
                return null;
            }
        }
    });
} catch (PrivilegedActionException e) {
    e.printStackTrace();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;开放端口&#34;&gt;开放端口&lt;/h3&gt;
&lt;p&gt;当需要通过远程进行 Java 应用管理时，就需要通过提供端口以供访问了，通过先前的 MBeanServer 构建 JMX 连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
    LocateRegistry.createRegistry(port);
} catch (RemoteException e) {
    return;
}

try {
    JMXServiceURL url = new JMXServiceURL(&amp;quot;service:jmx:rmi:///jndi/rmi://127.0.0.1:&amp;quot; + port + &amp;quot;/&amp;quot; + extend);
    JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, beanServer);
    cs.start();
} catch (IOException e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;
&lt;p&gt;对远程开放端口可设置 SSL、权限校验，只需对 JMXConnectorServer 增加配置选项即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; env = new HashMap&amp;lt;String, Object&amp;gt;();
// 对 env 增加配置
...

JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
cs.start(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;开启-ssl-连接&#34;&gt;开启 SSL 连接&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, new SslRMIClientSocketFactory()); 
env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, new SslRMIServerSocketFactory(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;设置权限认证&#34;&gt;设置权限认证&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
SimpleAuthenticator auth = new SimpleAuthenticator();
evn.put(JMXConnectorServer.AUTHENTICATOR, auth);
env.put(&amp;quot;jmx.remote.sasl.callback.handler&amp;quot;, new CallbackHandler() {...}); 


class SimpleAuthenticator implements JMXAuthenticator {

    private final Map&amp;lt;String, Auth&amp;gt; authRole;

    public SimpleAuthenticator() {
        authRole = new HashMap&amp;lt;&amp;gt;();
    }

    public boolean addAuth(String username, String password) {
        return addAuth(username, password, true);
    }

    public boolean addAuth(String username, String password, boolean readOnly) {
        if (authRole.containsKey(username)) {
            return false;
        }
        authRole.put(username, new Auth(password, readOnly));
        return true;
    }

    public boolean removeAuth(String username) {
        return authRole.remove(username) != null;
    }

    @Override
    public Subject authenticate(Object credentials) {
        if (!(credentials instanceof String[])) {
            throw new SecurityException(&amp;quot;Authentication failed!&amp;quot;);
        }
        String[] credentialsInfo = (String[]) credentials;
        if (credentialsInfo.length != 2) {
            throw new SecurityException(&amp;quot;Authentication failed!&amp;quot;);
        }
        String userName = credentialsInfo[0];
        Auth auth = authRole.get(userName);
        if (auth == null) {
            throw new SecurityException(&amp;quot;Invalid Authentication!&amp;quot;);
        }
        String password = credentialsInfo[1];
        if (auth.password.equals(password)) {
            return new Subject(auth.readOnly, Collections.singleton(new JMXPrincipal(userName)), 
                Collections.EMPTY_SET, Collections.EMPTY_SET);
        }
        throw new SecurityException(&amp;quot;Invalid Authentication!&amp;quot;);
    }

    class Auth {
        String password;
        boolean readOnly;

        Auth(String password, boolean readOnly) {
            this.password = password;
            this.readOnly = readOnly;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// Client
String[] credentials = new String[] { &amp;quot;username&amp;quot; , &amp;quot;password&amp;quot; }; 
env.put(JMXConnectorServer.AUTHENTICATOR, credentials);
env.put(&amp;quot;jmx.remote.sasl.callback.handler&amp;quot;, new CallbackHandler() {...}); 
JMXConnector conn = JMXConnectorFactory.connect(serviceURL, env);

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;协议扩展&#34;&gt;协议扩展&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// Server
Security.addProvider(new com.sun.security.sasl.Provider());
env.put(&amp;quot;jmx.remote.profiles&amp;quot;, &amp;quot;TLS SASL/PLAIN&amp;quot;); 
env.put(&amp;quot;jmx.remote.x.access.file&amp;quot;, &amp;quot;config&amp;quot; + File.separator + &amp;quot;access.properties&amp;quot;); 

JMXServiceURL url = new JMXServiceURL(&amp;quot;jmxmp&amp;quot;, null, 5555); 
JMXConnectorServer cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, beanServer); 
cs.start(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// Client
Security.addProvider(new com.sun.security.sasl.Provider());
env.put(&amp;quot;jmx.remote.profiles&amp;quot;, &amp;quot;TLS SASL/PLAIN&amp;quot;); 
JMXServiceURL url = new JMXServiceURL(&amp;quot;jmxmp&amp;quot;, null, port); 
JMXConnector jmxc = JMXConnectorFactory.connect(url, env); 
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;详细步骤可见: &lt;a href=&#34;https://docs.oracle.com/cd/E19698-01/816-7609/6mdjrf86r/index.html&#34;&gt;https://docs.oracle.com/cd/E19698-01/816-7609/6mdjrf86r/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;监听&#34;&gt;监听&lt;/h3&gt;
&lt;p&gt;主要用于 JMX 连接状态和 MXBean 调用的监听。&lt;/p&gt;
&lt;p&gt;通过实现 &lt;code&gt;javax.management.NotificationListener&lt;/code&gt; 创建监听处理器，加入到 &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 的实现类下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jmxConnector.addNotificationListener((notification, handback) -&amp;gt; {...}, null, handback);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要自定义监听广播可以继承 &lt;code&gt;NotificationBroadcasterSupport&lt;/code&gt; 或 &lt;code&gt;NotificationEmitterSupport&lt;/code&gt;，其内部已经实现了 addNotificationListener、removeNotificationListener 方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>跨代引用</title>
      <link>https://moyada.github.io/post/card-table/</link>
      <pubDate>Sat, 15 Dec 2018 01:21:34 +0000</pubDate>
      <guid>https://moyada.github.io/post/card-table/</guid>
      <description>&lt;p&gt;在 JVM 虚拟机的内存管理中，有可能存在老年代对象引用新生代的情况，在 &lt;code&gt;Major GC&lt;/code&gt; 时，为了标记这些引用的新生代对象，需要通过扫描老年代来间接标记。&lt;/p&gt;
&lt;p&gt;然而，正常扫描全部老年代来获取的做法效率太低下了，由此便产生了称为 &lt;code&gt;CardTable&lt;/code&gt; (卡表) 的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Card Table&lt;/code&gt; 保存了所在由老年代所引用的新生代对象的集合，同时利用写屏障，在引用对象变化时，对引用记录标记为 &amp;ldquo;脏&amp;rdquo; ，那么当下次 GC 到来时，只用扫描脏页 (&lt;code&gt;Dirty Page&lt;/code&gt;) 便可以标记出由老年代引用的新生代存活对象。并且在 GC 后，由于复制算法导致了数据的迁移，根据迁移的位置决定是否对引用记录再次进行标记。&lt;/p&gt;
&lt;p&gt;在 G1 中，除了 &lt;code&gt;Card Table&lt;/code&gt; 还存在 &lt;code&gt;Remembered Set&lt;/code&gt;，更好的解决了跨代引用的问题。&lt;/p&gt;
&lt;p&gt;它记录了新生代被老生代引用的记录，存活于 &lt;code&gt;Region&lt;/code&gt; 中，对比 &lt;code&gt;Card Table&lt;/code&gt;，&lt;code&gt;Remembered Sets&lt;/code&gt; 只需通过自身就能得知是否存在跨代引用，无需借助老年代。&lt;/p&gt;
&lt;p&gt;配合 G1 回收算法，在对 &lt;code&gt;Region&lt;/code&gt; 进行回收时，无需借助外部数据就能获取全部存活对象，更大的提高了 GC 的效率。&lt;/p&gt;
&lt;p&gt;其实在 G1 中，&lt;code&gt;Remembered Sets&lt;/code&gt; 是借助 &lt;code&gt;Card Table&lt;/code&gt; 来实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html&#34;&gt;http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java GC过程</title>
      <link>https://moyada.github.io/post/jvm-gc/</link>
      <pubDate>Sun, 15 Jul 2018 12:06:05 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-gc/</guid>
      <description>&lt;p&gt;由于JVM分代设计，GC也根据原因不同而产生不同效果的GC，并且在Java的发展过程中根据不同的GC策略也有不同的过程实现。&lt;/p&gt;
&lt;h2 id=&#34;stop-the-world&#34;&gt;Stop-the-World&lt;/h2&gt;
&lt;p&gt;在 HotSpot 虚拟机中，Stop-the-World 也被称之为 safepoint，在此阶段内，所有运行 Java 代码与 JVM 交互的应用线程将会被挂起。&lt;/p&gt;
&lt;p&gt;以便在执行 GC 复制算法、栈上替换代码、JIT 去优化、清除 code cache、重定义 Class、偏向锁的去除、debug 操作等任务时保证数据的一致性。&lt;/p&gt;
&lt;h2 id=&#34;younggc&#34;&gt;YoungGC&lt;/h2&gt;
&lt;p&gt;发生在新生代的GC称为 &lt;code&gt;Young GC&lt;/code&gt;，也叫 YGC，是 JVM 运行过程中最频繁的GC。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;YoungGC 的产生原因主要是eden区内存不足以分配新对象或者剩余空间达到GC触发条件。
在发生 GC 时，虚拟机会将 &lt;code&gt;eden&lt;/code&gt; 区和 &lt;code&gt;survival from&lt;/code&gt; 区中存活的对象拷贝进 &lt;code&gt;survival to&lt;/code&gt; 区，清理其余对象。&lt;/p&gt;
&lt;h3 id=&#34;parnew&#34;&gt;ParNew&lt;/h3&gt;
&lt;p&gt;需要STW暂停，找出活跃对象，标记为 &lt;code&gt;reachable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;GC ROOTs&lt;/code&gt; 找出活跃的对象，还要根据 &lt;code&gt;CardTable&lt;/code&gt; 的 &lt;code&gt;Dirty&lt;/code&gt; 标记 (晋升至老年代，并且引用新生代对象) 找出老年代引用的新生代对象。&lt;/p&gt;
&lt;p&gt;首先检查老年代的连续可用空间是否可容纳存活对象，如果小于或者不允许担保失败，则需要进行 Full GC。&lt;/p&gt;
&lt;p&gt;检查空间足够则将存活对象进行复制，初始化 MarkWork，将根据年龄选择拷贝对象的目标空间。&lt;/p&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;大体步骤与ParNew类似，也需要 SWT 暂停。
不同的是，G1的 survivor 只有一个区域，并且使用 &lt;code&gt;RegionSet&lt;/code&gt; 来维护块之间的引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1存在一种 &lt;code&gt;Mixed GC&lt;/code&gt;，除了回收新生代之外，还会回收压缩部分老年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;old-gc&#34;&gt;Old GC&lt;/h2&gt;
&lt;p&gt;属于老年代GC的统称，也叫 &lt;code&gt;Old GC&lt;/code&gt;，一般都是伴随着 &lt;code&gt;Young GC&lt;/code&gt; ，主要目的是释放老年代空间，并将相邻对象进行压缩，防止过多的内存碎片。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程-1&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;OldGC的产生原因为YoungGC所需的堆内存空间不足、方法区空间不足、堆内空间达到回收阀值，也有可能人为触发。
发生GC时，标记所有存活对象，可将存活对象进行压缩，对不再使用的类及其子类进行卸载，清理CodeCache，清理弱引用，常量池的清理。&lt;/p&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
暂停所有应用线程，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出老年代边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找所有可到达对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新标记
并发地对上一阶段中引用关系变化的对象进行再标记，然后再暂停应用线程，最后检查是否有发生引用变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发清理
对未标记的对象进行收集，释放空间至空闲列表，此阶段可能将卸载此类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发重置
重新计算堆空间，清理数据，为下一次 GC 周期做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&#34;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;G1 的收集虽然也分为新生代和老年代，但在步骤上其实是有交叉的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
需要暂停应用线程，标记出 &lt;code&gt;Roots&lt;/code&gt;，暂停时间较短，可能会根据 Region 优先级选择执行，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根区域扫描
从标记的存活区域中查找出老年代的引用并进行标记，为了保证数据的正确，在下一次新生代 GC 可能发生之前此阶段必须完成.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找出所有可到达对象，有可能被 &lt;code&gt;Young GC&lt;/code&gt; 打断。过程中还会涉及 &lt;code&gt;SATB&lt;/code&gt;，记录引用关系变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次标记
需要 STW，将上一阶段中引用关系发生变化的对象进行再标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清理
整理对象、更新 &lt;code&gt;RSets&lt;/code&gt; 和将部分老年代加入下次回收周期，需要暂停应用线程，对于清空 Region 加入空闲列表的操作可以并发进行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&#34;&gt;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&lt;/a&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&#34;&gt;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;full-gc&#34;&gt;Full GC&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Full GC&lt;/code&gt; 是对整个堆进行清理的回收算法，包括新生代和老年代。&lt;/p&gt;
&lt;p&gt;在 CMS 中可指定使用并发的 &lt;code&gt;Full GC&lt;/code&gt;，在 JDK10 中 G1 对 &lt;code&gt;Full GC&lt;/code&gt; 也改进为了并发模式。&lt;/p&gt;
&lt;p&gt;除手动触发因素外，&lt;code&gt;Full GC&lt;/code&gt; 的产生通常是由老年代空间不足、方法区空间不足所引起。&lt;/p&gt;
&lt;p&gt;所有的垃圾回收算法都会在 Full GC 时暂停应用线程，因此在对延迟要求高的程序中，Full GC 是应该尽力避免的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java 虚拟机总结</title>
      <link>https://moyada.github.io/post/jvm/</link>
      <pubDate>Sat, 19 May 2018 19:15:57 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm/</guid>
      <description>&lt;h2 id=&#34;jvmjava虚拟机&#34;&gt;JVM(Java虚拟机)&lt;/h2&gt;
&lt;p&gt;JVM 是 JRE 包含的 Java 程序运行所需的程序，屏蔽各种硬件和操作系统的内存访问差异，通用一份 jar 包。
另外，JVM还提供了内存管理的功能，使得开发人员无需关心底层内存如何管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZBJ0u9MaKtM&#34;&gt;https://www.youtube.com/watch?v=ZBJ0u9MaKtM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h2&gt;
&lt;p&gt;Java虚拟机的类加载有加载 (load)、链接 (link)、初始化 (initialize) 三个步骤&lt;/p&gt;
&lt;p&gt;当一个类被实例化时或者类中静态方法被调用时将进行类加载&lt;/p&gt;
&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;
&lt;p&gt;将不同的类数据源以字节码的形式加载到内存中以供类加载器使用，数据的来源可以是 jar 包、class 类、网络数据，一个类数据有且只有一个存在于一个类加载器中。&lt;/p&gt;
&lt;p&gt;正常的类加载是以双亲委任机制，不同的类加载器是以继承的方式链接的，当通过某个类加载器加载一个类数据时，当这个类加载器存在父类加载器时，那么它会先从父类加载器中寻找类数据，不存在再在自身中寻找，并且父类也是遵循这个机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tomcat的类加载器重写了这个加载机制，会优先在自身中查找，这跟Tomcat所加载类的所在位置有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;
&lt;p&gt;链接包含了验证、准备、解析三个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;验证确保了类加载的正确性，它校验了字节码数据是符合Class类规范，常量类型是否支持，语义分析，分析数据流和控制流校验程序语义，符号引用校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;准备环节是为一个类的静态域分配内存空间，并赋予零值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析负责转化类中的符号引用，将类引用转换为直接引用，将类中的常量值转换为常量池中引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果类字段的字段属性为 &lt;code&gt;ConstantValue&lt;/code&gt;，即同时被 &lt;code&gt;final&lt;/code&gt; 、&lt;code&gt;static&lt;/code&gt; 修饰的基础类型数据，并且在定义时即赋值，如 &lt;code&gt;static final String CONSTANT_COMPILE = &amp;quot;java&amp;quot;;&lt;/code&gt;，那么在准备阶段变量就会被初始化为属性所指定的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;p&gt;对类的静态域赋予正确的初始值，执行静态代码块为赋值静态域。&lt;/p&gt;
&lt;h3 id=&#34;异常&#34;&gt;异常&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ClassNotFoundException
这种错误是发生在加载环节，当一个类在双亲委任机制中无法获取到时，便会抛出此异常。常见情景是依赖包的冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NoClassDefFoundError
这个错误主要是发生在链接环节的解析中，当一个类的静态域引用至另一个类中的属性，而这个类无法获取时，那么虚拟机就会抛出此异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运行时数据区域&#34;&gt;运行时数据区域&lt;/h2&gt;
&lt;p&gt;Java 虚拟机在运行程序的过程中把内存数据划分为不同的区域&lt;/p&gt;
&lt;h3 id=&#34;线程隔离的指令区&#34;&gt;线程隔离的(指令区)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序计数器：指向线程下一个执行的指令的地址(&lt;code&gt;本地指针&lt;/code&gt;或者&lt;code&gt;起始指令的偏移量&lt;/code&gt;)，当执行的是本地方法时为 undefined。
许多操作都需要依赖程序计数器来完成，例如在时间片抢占后切换线程能够恢复到正确的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈：包含了线程生命周期的方法调用，一个 Java 方法调用即为一个栈帧，根据调用顺序压入线程栈空间。
栈帧存储当前线程运行方法所需要的局部变量表（基本数据类型、对象引用）、操作数栈、动态链接、方法返回地址，保证了多线程下调用方法的隔离性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法区：与虚拟机栈作用相似，区别是执行 native 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程共享的数据区&#34;&gt;线程共享的(数据区)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法区／元空间 (MetaSpace)：存放类信息、静态域数据(对象实例存于堆中)、类编译期间生成的各种字面量和符号引用、字节码、JIT 编译后的机器码、动态代理产生的数据，使用本地内存存储，几乎不会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆 (Heap)：运行时常量池、对象实例域，是垃圾收集管理的主要区域。可分为新生代、老年代。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接内存：用于 NIO 数据交换的内存空间，只受实际内存及 JVM 参数限制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存溢出&#34;&gt;内存溢出&lt;/h3&gt;
&lt;p&gt;内存溢出是由于虚拟机空间分配失败所导致的致命性错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法栈 (StackOverFlowError)
常见原因有递归或大循环调用方法导致栈帧数量过多、线程内定义大量的本地变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆 (OutOfMemoryError)
常量池溢出、线程持续占有对象都将可能导致堆溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法区 (OutOfMemoryError)
主要原因为动态创建大量的类，并且卸载无法满足新的元类存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;执行引擎&#34;&gt;执行引擎&lt;/h2&gt;
&lt;h3 id=&#34;解释器-interpreter&#34;&gt;解释器 (Interpreter)&lt;/h3&gt;
&lt;p&gt;解释字节码，执行相应的命令&lt;/p&gt;
&lt;h3 id=&#34;分析器-hotspot-profiler&#34;&gt;分析器 (Hotspot profiler)&lt;/h3&gt;
&lt;p&gt;将频繁调用的热点方法编译成与本地平台相关的机器码&lt;/p&gt;
&lt;h3 id=&#34;jit-即时编译器&#34;&gt;JIT (即时编译器)&lt;/h3&gt;
&lt;p&gt;优化解释器，将字节码翻译成本地平台相关的机器码执行
常见的 JIT 有 C1、C2，在 Java10 引入 Graal&lt;/p&gt;
&lt;p&gt;常见的 JIT 优化手段有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;公共子表达式消除
当一个大表达式已经被计算过后，再次出现已经包含了的表达式则不必重新计算，直接用结果代替。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组边界检查消除
消除大循环体内对元素越界检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法内联
将频繁调用方法替换为调用方法代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逃逸分析
当开启了标量替换 (-XX:+EliminateAllocations) 和逃逸分析 (-XX:+DoEscapeAnalysis) 后，会对线程栈内的对象进行分析，将只存活于栈帧内的可分解对象进行基础类型数据替换处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步消除 (-XX:+EliminateLocks)
在开启逃逸分析和 -server 模式后，将会对无多线程竞争的锁进行消除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化技术&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译器策略：延迟编译，分层编译，栈上替换，延迟优化，程序依赖图表示，静态单赋值表示。&lt;/p&gt;
&lt;p&gt;基于性能监控的优化技术：乐观空值断言，乐观类型断言，乐观类型增强，乐观数组增强，裁剪未被选择的分支，乐观的多态内联。分支频率预测，调用频率预测&lt;/p&gt;
&lt;p&gt;基于证据的优化技术：精确性推断，内存值推断，内存值跟踪，常量折叠，重组，操作符退化，空值检查消除。类型检测退化，类型检测消除，代数化简，公共子表达式消除&lt;/p&gt;
&lt;p&gt;数据流敏感重写：条件常量传播，基于六承载的类型缩减转换，无用代码消除&lt;/p&gt;
&lt;p&gt;语言相关的优化技术：类型继承关系分析，去虚拟机化，符号常量传播，自动装箱，消除逃逸分析，锁消除，锁膨胀，消除反射&lt;/p&gt;
&lt;p&gt;内存及代码位置交换：表达式提升，表达式下沉，冗余存储消除，相邻存储合并，交汇点分离&lt;/p&gt;
&lt;p&gt;循环变换：循环展开，循环剥离，安全点消除，迭代分离，范围检查消除&lt;/p&gt;
&lt;p&gt;局部代码调整：内联，全局代码提升，基于热度的代码分离，Switch 调整&lt;/p&gt;
&lt;p&gt;控制流图变换：本地代码编排，本独代码封包，延迟槽填充，着色图寄存器分配，线性扫描寄存器分配，复写聚合，常量分裂，复写移除，地址模式匹配。指令窥孔优化，基于确定有限状态机的代码生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graal [jdk10]
启动方式 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc垃圾收集器策略&#34;&gt;GC(垃圾收集器)策略&lt;/h2&gt;
&lt;p&gt;Java虚拟机在运行时会产生大量的对象，有些对象将不会再被使用，为了使内存不被这些无用的对象占用，垃圾收集器就需要分析出已经死亡的对象，将其所用空间回收。&lt;/p&gt;
&lt;p&gt;虚拟机从一部分称为 &lt;code&gt;GC Roots&lt;/code&gt; 的节点开始搜索引用链，找出存活的引用 (并非特指对象)，对其余对象标记为虚引用，准备下一阶段进行回收释放内存空间。对重写了 finilize() 方法对象封装并放入队列中，在 GC 结束后单线程执行方法后移除。&lt;/p&gt;
&lt;h3 id=&#34;serial&#34;&gt;Serial&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;标记清除整理&lt;/code&gt; 算法，单线程进行垃圾回收，无上下文切换开销，但 cpu 利用率较低，并且无法与应用线程并行进行。&lt;/p&gt;
&lt;h3 id=&#34;parallel&#34;&gt;Parallel&lt;/h3&gt;
&lt;p&gt;基于吞吐量优先的并行收集器，对年轻代使用 &lt;code&gt;标记复制&lt;/code&gt; 算法，对老年代使用 &lt;code&gt;标记清除整理&lt;/code&gt; 算法，适用于多核处理器，有效利用系统资源。&lt;/p&gt;
&lt;h3 id=&#34;cmsconcurrent-mark-sweep&#34;&gt;CMS(Concurrent Mark Sweep)&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;标记清除&lt;/code&gt; 算法为基础，以响应时间优先的并发收集器，对年轻代使用 &lt;code&gt;标记复制&lt;/code&gt; 算法，对老年代使用 &lt;code&gt;标记清除&lt;/code&gt; 算法。
使用 &lt;code&gt;空闲空间列表&lt;/code&gt; 来管理老年代内存，在老年代 GC 阶段大部分工作可以与应用线程并发执行，并且可在老年代空间内存利用率达到阀值时触发 CMS GC。&lt;/p&gt;
&lt;p&gt;收集工作分为数个阶段：初始标记、并发标记、并发预清理、并发可取消的预清理、最终标记、并发清除、并发重置&lt;/p&gt;
&lt;p&gt;CMS 由于不进行内存整理容易造成老年代内存碎片，并且当堆内存较大时，可能产生不可预估的暂停时间。&lt;/p&gt;
&lt;h3 id=&#34;g1garbage-first&#34;&gt;G1(Garbage-First)&lt;/h3&gt;
&lt;p&gt;以 &lt;code&gt;复制&lt;/code&gt; 算法为基础，为了能够得到良好的停顿时间而产生的一款实时收集器。
将内存空间以块 (Region) 进行分配空间，一般划分 2048 个，优先回收大垃圾的回收机制。使用空闲空间列表来管理所有内存。&lt;/p&gt;
&lt;p&gt;虚拟机在分配空间时会选定一个 Region(TLAB将分别指定一个Region)，当 Region 的剩余空间不足以分配对象或者小于最小可空间时，将重新指定下一个 Region 分配空间。&lt;/p&gt;
&lt;h4 id=&#34;hregion&#34;&gt;HRegion&lt;/h4&gt;
&lt;p&gt;当分配对象的大小大于 Region 空间的一半，将会分配一个 Humongous Region 直接进入老年代，省略年轻代的内存复制过程，这个 Humongous Region 的大小将为能容纳对象的最小 Region 空格倍数。&lt;/p&gt;
&lt;h4 id=&#34;satb-snapshot-at-the-beginning&#34;&gt;SATB (snapshot-at-the-beginning)&lt;/h4&gt;
&lt;p&gt;对象初始化时的快照，引用变化时使用 &lt;code&gt;write barrier&lt;/code&gt; 进行更新，在 GC 中利用了此列表进行扫描。&lt;/p&gt;
&lt;h4 id=&#34;rset&#34;&gt;RSet&lt;/h4&gt;
&lt;p&gt;与 CMS 不同，G1 使用了记录 Region 引用关系的 &lt;code&gt;Remembered Set&lt;/code&gt; 来记录，内部为多个 &lt;code&gt;Card Table&lt;/code&gt; ，并且是用于记录 &lt;code&gt;被引用&lt;/code&gt; 的对象集合。
使用 &lt;code&gt;三色标记法&lt;/code&gt; + &lt;code&gt;写屏障(write barrier)&lt;/code&gt; 来更新其引用关系。&lt;/p&gt;
&lt;p&gt;G1 解决了 CMS 中的各种疑难问题, 包括暂停时间的可预测性, 并终结了堆内存的碎片化。&lt;/p&gt;
&lt;h3 id=&#34;zgc&#34;&gt;ZGC&lt;/h3&gt;
&lt;p&gt;是一个可伸缩的低延迟垃圾收集器，暂停时间不超过10毫秒，暂停时间不会随堆或实时设置大小而增加&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/renfufei/article/details/54885190&#34;&gt;https://blog.csdn.net/renfufei/article/details/54885190&lt;/a&gt;
&lt;a href=&#34;https://www.zhihu.com/question/53613423/answer/135743258&#34;&gt;https://www.zhihu.com/question/53613423/answer/135743258&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存模型jmm&#34;&gt;内存模型(JMM)&lt;/h2&gt;
&lt;p&gt;heap 根据空间利用率、垃圾回收存活年龄分为年轻代、老年代，永久代。&lt;/p&gt;
&lt;h3 id=&#34;年轻代&#34;&gt;年轻代&lt;/h3&gt;
&lt;p&gt;年轻代又可细分为 Eden空间、S0空间 (From Survivor)、S1空间 (To Survivor)
Eden Space 中存在线程私有的空间 TLAB，是每个线程的缓冲区，存放一些用过即丢弃的对象。&lt;/p&gt;
&lt;h3 id=&#34;老年代&#34;&gt;老年代&lt;/h3&gt;
&lt;p&gt;当新生代的对象超过设定年龄，或者同龄对象达到幸存区的一半，这些对象将被划入老年代(Old Space)。
只有当老年代空间不足分配发生 Full GC 时 (CMS 中可以为 CMS GC)，才会对老年代的数据进行回收。&lt;/p&gt;
&lt;h3 id=&#34;永久代&#34;&gt;永久代&lt;/h3&gt;
&lt;p&gt;用于存放元类数据，在并发标记时和类加载器卸载时将会对相关数据进行回收。
当一个类加载器死亡时，相对应的元数据也被销毁，释放其块空间。&lt;/p&gt;
&lt;h4 id=&#34;permgenspace&#34;&gt;PermgenSpace&lt;/h4&gt;
&lt;p&gt;java8 之前的永久代实现，也称为方法区，为一块固定空间大小，当空间不足时会进行Full GC。
由于区空间大小固定，在大量动态创建类的程序中容易造成OOM。&lt;/p&gt;
&lt;h4 id=&#34;metaspace&#34;&gt;MetaSpace&lt;/h4&gt;
&lt;p&gt;源自 JRockit，在 Java8 与 Hotspot 合并，将 native method area 概念加入 Hotspot，由此得来 MetaSpace 替换原有的 PermGen，容量仅受可用的本地内存限制。&lt;/p&gt;
&lt;p&gt;MetaSpace 的空间是以块 (Chunk) 为单位，这个块的大小取决与申请空间的类加载器类型。&lt;/p&gt;
&lt;p&gt;当类加载器加载类时，从块分配器中获取一份块内存空间存在类元数据，并映射此地址。&lt;/p&gt;
&lt;p&gt;由于每个类加载器申请的块大小不一致，MetaspaceVM 也还未使用压缩技术，这就容易导致内存碎片的产生。&lt;/p&gt;
&lt;h3 id=&#34;tlab&#34;&gt;TLAB&lt;/h3&gt;
&lt;p&gt;当大量线程申请空间时，JVM 需要对并发操作保障不会发生指针碰撞，这样便增加了复杂性，降低性能。&lt;/p&gt;
&lt;p&gt;因此，在 jdk1.6 以后便引入了 TLAB 技术。&lt;/p&gt;
&lt;p&gt;TLAB 全名 Thread-local allocation buffers，是在线程初始化的时候在堆中新生代申请一块线程私有的分配空间(允许所有线程访问)，减少同步开销，使用参数 &lt;code&gt;-XX:UseTLAB&lt;/code&gt; 开启。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/cd85098cca39&#34;&gt;https://www.jianshu.com/p/cd85098cca39&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;plab&#34;&gt;PLAB&lt;/h3&gt;
&lt;p&gt;全名 promotion-local allocation buffers，用于 Young GC 时的空间分配及复制。&lt;/p&gt;
&lt;p&gt;其他还有 CLAB，全名 core-local allocation buffers，用于全局的空间分配。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM 参数</title>
      <link>https://moyada.github.io/post/jvm-param/</link>
      <pubDate>Tue, 24 Apr 2018 21:25:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-param/</guid>
      <description>&lt;style&gt;
table th:nth-of-type(1) {
    width: 250px;
}

table th:nth-of-type(2) {
    width: 30px;
}

table th:nth-of-type(3) {
    width: 300px;
}

table th:nth-of-type(4) {
    width: 150px;
}
&lt;/style&gt;
&lt;h2 id=&#34;空间&#34;&gt;空间&lt;/h2&gt;
&lt;h3 id=&#34;通用&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xms&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 初始化的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmx&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmn&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新生代的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 GC 下建议不设置该参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xss&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;线程栈的大小，默认 1M&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxDirectMemorySize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 NIO 的直接缓存最大容量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SurvivorRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Eden 和 Survior(from和to) 大小比例，默认是 8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:AutoBoxCacheMax=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置自动装箱池缓存大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;server模式专有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveGCBoundary&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态化使用资源&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态调整各个代区的内存大小，每次 minor gc 后会重新计算 eden，from 和 to 的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的初始大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxNewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代和老年代的比例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.noInflation=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时是否使用代理类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.inflationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时生成代理类调用的次数，之后使用 JNI 字节码调用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRAM=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinRAMFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存除数，默认为 4，即堆空间内 MaxRAM 的四分之一&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErgoHeapSizeLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;限制堆内存上限&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之前&#34;&gt;Java8之前&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxPermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之后&#34;&gt;Java8之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxMetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增，初始大小是 21M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java9之后&#34;&gt;Java9之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapRegionSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个区域块大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1M-32M 之间,必须是2的幂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1NewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最小值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MaxNewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最大值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 60%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;
&lt;h3 id=&#34;通用-1&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;虚拟机会以 server 模式运行，该模式与 C2 编译器共同运行，更注重编译的质量，启动速度慢，但是运行效率高，适合用在服务器环境下，针对生产环境进行了优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JVM 启动时就会先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过快速对象分配模式在 TLAB（Thread-local allocation buffers）中进行分配对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以避免大量的线程通信所导致的性能下降&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TLABSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 TLAB 的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-ResizeTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用自动调整 TLAB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseLargePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用最大值内存页&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTransparentHugePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对大对象分配使用大内存页分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseNUMA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象分配优先使用 NUMA 本地内存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PerfDisableSharedMem&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 日志指向 /dev/shm，避免 IO 造成的 JVM 停顿&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShowHiddenFrames&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;展示虚拟机隐藏的栈信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ObjectAlignmentInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 java 对象的内存对齐，默认是 8 字节，指定的值必须是 2 的幂次，且必须在 8 和 256 之间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PageAlignDirectMemory&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置堆外内存使用内存对齐&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedOops&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 64 位环境下，压缩对象头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;原始类型的快速优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastEmptyMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastJNIAccessors&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用类或 int 的成员方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LargePageSizeInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 中内存页的最大值，参数必须是 2 的幂，不可设置过大&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseBiasedLocking&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用偏向锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在存在大量锁对象的创建并高度并发的环境下禁用偏向锁能够带来一定的性能优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:BiasedLockingStartupDelay=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;延迟(秒钟)启用偏向锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XXtlaSize:min=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;,preferred=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调整 TLA，每个线程私有的空间的默认最小大小和默认首选大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysAtomicAccesses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;实现对所有 Access 的原子性保证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启标量替换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DoEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;进行逃逸分析之后，创建的可分解的对象都将由栈上分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;标量替换，栈上分配，受限于栈的空间大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看逃逸分析结果&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateLocks&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分析并且消除无线程竞争下的锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同步消除，必须开启 -XX:+DoEscapeAnalysis 和 -server 模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看标量的替换情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;max number of live nodes in a method&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PositiveIdentityHash&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只允许分配正数的哈希值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EnableJVMCI&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用 Graal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseJVMCICompiler&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Graal JIT编译器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TieredCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用分层编译策略，根据编译器编译、优化的规模与耗时，划分出不同的编译层次&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TieredStopAtLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JIT 编译的最高层级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCodeCacheFlushing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当代码缓存被填满时让 JVM 放弃一些编译代码&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitialCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置初始代码缓存的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ReservedCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置代码缓存的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompileThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发标准的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InterpreterBackwardBranchLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发 OSR 形式的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HugeMethodLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JIT 编译字节码大小超过 size 字节的方法就是巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DontCompileHugeMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不编译巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseCounterDecay&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止 JIT 调用计数器衰减&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CompileCommand=&lt;code&gt;command,method[,option]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定制编译需求，比如过滤某个方法不做 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+InlineSynchronizedMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对同步方法进行内联&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行方法内联前，方法的最多嵌套调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 325&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTrivialSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;归属于不重要的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinInliningThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法被内联的最小调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 250&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRecursiveInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对方法的递归调用做内联优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法内最大存活的 JIT IR 节点数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 20000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ActiveProcessorCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 jvm 使用 cpu 个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseContainerSupport&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;支持容器化功能，默认开启&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCGroupMemoryLimitForHeap&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 CGroup Namespace&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk10 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;gc&#34;&gt;GC&lt;/h2&gt;
&lt;h3 id=&#34;通用-2&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedClassPointers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启压缩类指针&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64 位平台上默认打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代为多线程收集&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以和 CMS GC 一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ParallelRefProcEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并行的处理对象标记过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定并行处理 GC 的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 GC 线程数为 CPU 的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParGCCardsPerStrideChunk=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个线程每次扫描的 Card 数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CardTable 用来标记老年代的某一块内存区域中的对象是否持有新生代对象的引用,卡表的数量取决于老年代的大小和每张卡对应的内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinHeapFreeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定堆内存在使用率以下进行收缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisableExplicitGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止代码中显示调用 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CMS 下可使用 -XX:+ExplicitGCInvokesConcurrent 替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+GCLockerInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的执行 GC Lock&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ConcGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置并行GC的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTenuringThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代经过多少次YGC晋升到老生代&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PretenureSizeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;晋升老年代对象年龄&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无默认值，Paralle Scavenge收集器无法识别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompressedClassSpaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置指针压缩空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;字符串concat优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;选择垃圾收集器为并行收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能和 CMS GC 一起使用,系统吨吐量优先&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCTimeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置吞吐量大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SoftRefLRUPolicyMSPerMB=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每兆空间中软引用的生命周期 (多少毫秒后清除)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xnoclassgc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不对 Class 元数据进行 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseConcMarkSweepGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用 CMS 低停顿垃圾收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelRemarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启并行标记&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;命令JVM无论什么时候调用系统 GC，都执行 CMS GC，而不是 Full GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent &lt;br/&gt; AndUnloadsClasses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保证当有系统 GC 调用时，永久代也被包括进 CMS 垃圾回收的范围内&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSConcurrentMTEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的 CMS 阶段将以多线程执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelInitialMarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启初始标记过程中的并行化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelCMSThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设定 CMS 的线程数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 老年代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingPermOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 永久代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只使用 CMSInitiatingOccupancyFraction 设置的回收阈值，否则交由 JVM 动态调整&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSTriggerRatio&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 CMSInitiatingOccupancyFraction 错误时的生成策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSScavengeBeforeRemark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;重新标记之前对年轻代做一次 Minor GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSClassUnloadingEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 &lt;code&gt;CMS GC&lt;/code&gt; 时对永久代进行垃圾回收(类卸载)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 时会扫描 MetaSpace/PermGen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSFullGCsBeforeCompaction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定进行多少次Full GC之后，执行内存空间整理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 的时候，对年老代的压缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能会影响性能，但是可以消除碎片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseG1GC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用G1垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitiatingHeapOccupancyPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发并发标记周期时的堆内存占用率阈值. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;值为 0 则表示一直执行 GC 循环，默认值为 45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1UseAdaptiveIHOP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启自适应并发标记控制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ConcRefinementThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 Remenbered Set 的工作线程数目&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxGCPauseMillis=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每次年轻代垃圾回收的最长时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseStringDeduplication&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用字符串去重机制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 收集器下生效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCLiveThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动混合垃圾回收周期的老年代占用率阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认占用率为 65%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapWastePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置允许浪费的堆百分比，如果触发回收百分比小于该百分比，JVM 则不会启动混合垃圾回收周期&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCCountTarget=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置标记周期完成后，执行混合垃圾回收老年代的目标次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1OldCSetRegionThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置混合垃圾回收期间要回收的最大旧区域数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ReservePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置作为预留存活区在 heap 中的百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeConcMark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1PrintHeapRegions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 G1 收集器收集的区域&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeRSetStats&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印标记过程引用信息(Print RSet processing information)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1SummarizeRSetStatsPeriod=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 GC 周期频率报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-G1EagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用 G1 优先尝试回收大对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1TraceEagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 在每个 &lt;code&gt;Young GG&lt;/code&gt; 周期都会回收消亡的 Humongous 对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1ConcRegionFreeingVerbose&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Debug JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;zgc&#34;&gt;ZGC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseZGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 ZGC 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java11，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/zgc/Main&#34;&gt;https://wiki.openjdk.java.net/display/zgc/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;shenandoah-gc&#34;&gt;Shenandoah GC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseShenandoahGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Shenandoah 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk12，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahInitFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发垃圾回收的初始阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahMinFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无条件触发垃圾回收的最小空间阀值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocSpikeFactor=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置预留堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahGarbageThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置一个 Region 被视为 &lt;code&gt;可回收&lt;/code&gt; 的垃圾对象所需百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动垃圾回收的空闲堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置上一次垃圾回收周期的分配内存百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahPacing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;根据垃圾回收效率分配应用程序的线程与可用空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahPacingMaxDelay=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在最大延迟时间之前，将不干预应用程序的分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahDegeneratedGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当程序遇到分配失败时，Shenandoah 将会暂停应用线程，直到完成后续垃圾回收工作&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerify&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检测垃圾回收异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahGCHeuristics=[ passive | aggressive ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;暂停应用线程执行垃圾回收 或 执行紧凑的垃圾回收并疏散所有非空 Region&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerifyOptoBarriers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;验证 C2 模式&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;b&gt;Java9之后&lt;/b&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;jvm日志使用 &lt;code&gt;-Xlog[&amp;lt;what&amp;gt;][:[&amp;lt;output&amp;gt;][:[&amp;lt;decorators&amp;gt;][:&amp;lt;output-options&amp;gt;]]]&lt;/code&gt; 记录
可以使用 &lt;code&gt;java -Xlog:help&lt;/code&gt; 查看帮助文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;-Xlog:disable -Xlog:gc+liveness=info,rt*=off:file=../logs/gc_%t.log:time,uptimemillis,pid:filecount=5,filesize=1024
先关闭所有日志，打开 gc 和存活对象的日志，关闭包含 rt 的日志级别，输出日志至文件，额外包含时间、耗时、进程 id，以 5 个 1M 的文件循环保存历史日志文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考:
&lt;a href=&#34;http://www.cnblogs.com/IcanFixIt/p/7259712.html&#34;&gt;http://www.cnblogs.com/IcanFixIt/p/7259712.html&lt;/a&gt;
&lt;a href=&#34;https://juejin.im/post/5a981f056fb9a028bf04bec4&#34;&gt;https://juejin.im/post/5a981f056fb9a028bf04bec4&lt;/a&gt;
&lt;a href=&#34;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&#34;&gt;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/jeps/158&#34;&gt;http://openjdk.java.net/jeps/158&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用-3&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xloggc=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如 -Xloggc=/data/application/logs/gc.log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+verbosegc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCCause&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 GC 的原因&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDetails&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印GC日志详情&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;建议开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCTimeStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以基准时间的形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDateStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以日期的形式，如 2013-05-04T21:53:59.234+0800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErrorFile=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 JVM 出现致命错误时，生成错误文件，包括了导致 jvm crash 的重要信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationStoppedTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 的停顿时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationConcurrentTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 在两次停顿之间的正常运行时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 OutOfMemoryError 时拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpBeforeFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 前拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpAfterFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 后拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HeapDumpPath=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定导出堆的存放路径&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseGCLogFileRotation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启日志文件的循环&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NumberOfGCLogfiles=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;配置日志循环文件个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCLogfileSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定日志文件大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NativeMemoryTracking=[off | summary | detail]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看 JVM 本地方法使用情况&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;p&gt;jcmd &lt;pid&gt; VM.native_memory [summary &amp;amp;##124; detail &amp;amp;##124; baseline &amp;amp;##124; summary.diff &amp;amp;##124; detail.diff &amp;amp;##124; shutdown] [scale= KB &amp;amp;##124; MB &amp;amp;##124; GB] &lt;p/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintNMTStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 JVM 退出时打印 NMT 报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:class&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在程序运行的时候有多少类被加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;verbose:class 来监视 java -verbose:class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:gc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在虚拟机发生内存回收时在输出设备显示信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:jni&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 native 方法调用的相关情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintHeapAtGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行 GC 的前后打印出堆的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsInitial&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示所有可设置参数及默认值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsFinal&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示可以获取到所有设置后参数及值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockDiagnosticVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁对 JVM 进行诊断的选项参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCommandLineFlags&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示出 JVM 初始化完毕后所有跟最初的默认值不同的参数及它们的值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintTenuringDistribution&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内存模型各代信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisplayVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 输出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;记录 JVM 输出到日志&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintJNIGCStalls&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印进入临界区 (JVM 传向 JNI) 的线程信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFLSStatistics=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 前后输出内存的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 &lt;code&gt;size &amp;gt; 1&lt;/code&gt; 时还会输出 IndexedFreeLists 统计信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatisticsCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印自适应收集的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintReferenceGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;跟踪系统内的软引用,弱引用,虚引用和 finallize 队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintClassHistogram&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印出实例的数量以及空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit-1&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInlining&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内联优化的方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简单的输出一些关于从字节码转化成本地代码的编译过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 JIT 的编译信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过使用外部的 disassembler.so 库打印汇编的字节码和 native 方法来辅助分析&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要和-XX:UnlockDiagnosticVMOptions一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassLoading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassUnloading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的卸载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInterpreter&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印解释过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;exclude，跳过编译指定的方法; compileonly，只编译指定的方法; inline/dontinline，设置是否内联指定方法; print，打印生成的汇编代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印JIT编译过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无法使用该参数可以用 -XX:+PrintOptoAssembly 来代替&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1LogLevel=fine, finer, finest&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志包含信息以及每个工作线程的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintStringDeduplicationStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印字符串去重的影响&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否支持远程 JMX 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定远程监控端口号，随机分配 RMI 端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.ssl=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否对连接开启 SSL 加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.authenticate=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否需要开启用户认证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.rmi.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 与远程监控端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.rmi.server.hostname=&lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 服务的对应主机名&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.net.preferIPv4Stack=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;优先使用 IPv4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.security.egd=file:/dev/./urandom&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用非阻塞的随机数与熵池策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.util.concurrent.ForkJoinPool.common.parallelism=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改 ForkJoinPool 的默认线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockExperimentalVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 实验性参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 商业特性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对商业特性进行日志记录&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+FlightRecorder&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 JFR 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FlightRecorderOptions=&lt;code&gt;&amp;lt;parameter&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JFR 监控参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生不可恢复的错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnOutOfMemoryError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生内存溢出错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AggressiveOpts&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用预设的优化參數&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.awt.headless=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用计算能力模拟外设功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如创建图片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>
