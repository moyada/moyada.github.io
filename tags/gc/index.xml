<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GC | 疯狂的厨子</title>
    <link>https://moyada.github.io/tags/gc/</link>
      <atom:link href="https://moyada.github.io/tags/gc/index.xml" rel="self" type="application/rss+xml" />
    <description>GC</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><copyright>© 2017 - 2020 moyada</copyright><lastBuildDate>Sun, 04 Aug 2019 13:30:02 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=true) shape:circle]</url>
      <title>GC</title>
      <link>https://moyada.github.io/tags/gc/</link>
    </image>
    
    <item>
      <title>Shenandoah GC 介绍</title>
      <link>https://moyada.github.io/post/shenandoah-gc/</link>
      <pubDate>Sun, 04 Aug 2019 13:30:02 +0000</pubDate>
      <guid>https://moyada.github.io/post/shenandoah-gc/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Shenandoah GC 是 OpenJDK 在 JDK12 推出的新一代 &lt;code&gt;标记整理&lt;/code&gt; 的垃圾回收器，它的目标时为了使大容量内存应用在垃圾回收时只进行短暂的应用暂停，使用 -XX:+UseShenandoahGC 开启。&lt;/p&gt;
&lt;p&gt;它能够在垃圾回收周期中进行 &lt;code&gt;并发整理&lt;/code&gt; 和 &lt;code&gt;并发更新&lt;/code&gt;，不暂停应用线程，并将垃圾回收分解为多个阶段，来达到极短的暂停时间，同时不会随着堆内存大小而影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=VCeHkcwfF9Q&#34;&gt;https://www.youtube.com/watch?v=VCeHkcwfF9Q&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=E1M3hNlhQCg&#34;&gt;https://www.youtube.com/watch?v=E1M3hNlhQCg&lt;/a&gt;
&lt;a href=&#34;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&#34;&gt;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&#34;&gt;https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers/&lt;/a&gt;
&lt;a href=&#34;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&#34;&gt;https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;并发复制&#34;&gt;并发复制&lt;/h3&gt;
&lt;p&gt;Shenandoah GC 是如何做到并发复制的呢？这主要是利用了 &lt;code&gt;读屏障&lt;/code&gt; 和 &lt;code&gt;Brooks Pointers&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://rkennke.wordpress.com/2013/10/23/shenandoah-gc-brooks-pointers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brooks Pointers&lt;/a&gt; 是为了保证并发环境下数据一致性而设计的字段，它在对象地址中占用了 8 位地址来标识实际对象地址的偏移值。&lt;/p&gt;
&lt;p&gt;通常情况下它指向当前对象地址自身，当进入并发整理的对象拷贝阶段时，GC 将会利用 CAS 操作替换新的地址偏移值，并保证只进行一次成功的操作。&lt;/p&gt;
&lt;p&gt;当应用线程操作该对象时将会使用 &lt;code&gt;读屏障&lt;/code&gt; 获取 &lt;code&gt;brooks pointers&lt;/code&gt; 偏移值再计算得出实际地址返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hotspot/share/gc/shenandoah/shenandoahBrooksPointer.inline.hpp

inline oop ShenandoahBrooksPointer::forwardee(oop obj) {
  shenandoah_assert_correct(NULL, obj);
  return oop(*brooks_ptr_addr(obj));
}

inline HeapWord** ShenandoahBrooksPointer::brooks_ptr_addr(oop obj) {
  return (HeapWord**)((HeapWord*) obj + word_offset());
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于通常情况下并不需要使用读屏障来获取地址，Shenandoah GC 又引入了 &lt;code&gt;slow path&lt;/code&gt; 的设计。&lt;/p&gt;
&lt;p&gt;它的作用是，只有当垃圾回收进行中，并且对象处于 &lt;code&gt;collection set&lt;/code&gt; 中，那么程序才会使用 读屏障 来获取对象地址。&lt;/p&gt;
&lt;p&gt;同时 Shenandoah GC 还会对字节码进行优化，以确保程序正确的情况下减少用读屏障获取地址的使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/concurrent-copy.png&#34; alt=&#34;concurrent-copy&#34; title=&#34;并发修改&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于需要使用额外的空间来存储 &lt;code&gt;brooks pointers&lt;/code&gt;，则必须使用 64 位地址，同时堆空间也会增加 3% ~ 15% 的开销，而 CAS 和 读屏障 则产生 2% ~ 20% 的吞吐量下降。&lt;/p&gt;
&lt;h3 id=&#34;空间划为&#34;&gt;空间划为&lt;/h3&gt;
&lt;p&gt;Shenandoah 与 G1 类似也是以 Region 来划分堆内存，但是不进行分代标记。&lt;/p&gt;
&lt;p&gt;每个 Region 对应一个数组用来表示有哪些 Region 存在对象指向自身 Region 中的对象，这就避免了 G1 在年轻代之间的引用关系需要扫描整个年轻代甚至是堆的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/region-incoming.png&#34; alt=&#34;region-incoming&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;numa&#34;&gt;NUMA&lt;/h3&gt;
&lt;p&gt;与 ZGC 相同，利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的 CPU 缓存，并且使 应用线程 与 GC线程 处于同一核心线程下，共享同一个 Region 的数据。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;从 &lt;code&gt;hotspot/share/gc/shenandoah/shenandoahControlThread.cpp::run_service()&lt;/code&gt; 可以观察到 Shenandoah GC 的垃圾收回触发策略，将会根据 内存分配情况 或 提交的垃圾回收事件 &lt;code&gt;_requested_gc_cause&lt;/code&gt; 来决定所执行的具体垃圾回收流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  switch (mode) {
    case none:
      break;
    case concurrent_traversal:
      service_concurrent_traversal_cycle(cause);
      break;
    case concurrent_normal:
      service_concurrent_normal_cycle(cause);
      break;
    case stw_degenerated:
      service_stw_degenerated_cycle(cause, degen_point);
      break;
    case stw_full:
      service_stw_full_cycle(cause);
      break;
    default:
      ShouldNotReachHere();
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;Shenandoah 的回收过程与 G1 类似，都是基于 Region 的收集策略，一般情况下将垃圾回收声明周期分解成数个阶段执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/shenandoah-gc/shenandoah-gc-cycle.png&#34; alt=&#34;shenandoah-gc-cycle&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，扫描 GC Roots。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;b&gt;并发标记&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与应用程序并发进行，通过上一阶段的 GC Roots 遍历堆，使用 STAB 算法描绘存活对象图谱。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，处理位于队列中的标记和更新操作，并预先进行下一阶段，可能与下一阶段同时完成。&lt;/p&gt;
&lt;p&gt;收集存在死亡对象的 Region&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将无存活对象的 Region 进行清理并加入空闲列表。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;b&gt;并发疏散&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将收集集合中的对象复制至空闲 Region 中，此阶段不会造成应用线程暂停。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;初始更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;短暂的暂停应用线程，只确保疏散操作均已完成。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;b&gt;并发更新引用&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遍历堆中对象，更新疏散对象的引用。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;最终更新引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;暂停应用线程，堆当前的 Root Set 进行更新，对收集集合的 Region 进行回收。&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;并发清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回收无任何对象引用的 Region。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ZGC 介绍</title>
      <link>https://moyada.github.io/post/zgc/</link>
      <pubDate>Fri, 28 Jun 2019 20:12:10 +0000</pubDate>
      <guid>https://moyada.github.io/post/zgc/</guid>
      <description>&lt;h2 id=&#34;什么是-zgc&#34;&gt;什么是 ZGC&lt;/h2&gt;
&lt;p&gt;由于现在系统日趋增长的内存，传统的垃圾回收器在整理阶段需要花费更长的时间，为了提高 jvm 在大容量内存应用的回收效率，一款新的垃圾回收器 ZGC 在 JDK11 上正式公布问世。通过配置参数 -XX:+UseZGC 开启，目前仅支持 Linux x86 64位的系统。&lt;/p&gt;
&lt;p&gt;ZGC 全称 Z Garbage Collector，是一款 &lt;code&gt;低停顿&lt;/code&gt; 的标记整理垃圾收集器，它能够在大部分时间与应用线程并行运行。ZGC 在 Oracle 官方资料中表明能够保证垃圾回收中最高 &lt;code&gt;10毫秒&lt;/code&gt; 的停顿，而作为低停顿的代价也只是最多下降 15% 的总吞吐量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料:
&lt;a href=&#34;https://openjdk.java.net/projects/zgc/&#34;&gt;https://openjdk.java.net/projects/zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7k_XfLGu-Ts&#34;&gt;https://www.youtube.com/watch?v=7k_XfLGu-Ts&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=kF_r3GE3zOo&#34;&gt;https://www.youtube.com/watch?v=kF_r3GE3zOo&lt;/a&gt;
&lt;a href=&#34;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&#34;&gt;https://dinfuehr.github.io/blog/a-first-look-into-zgc/&lt;/a&gt;
&lt;a href=&#34;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&#34;&gt;https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/&lt;/a&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&#34;&gt;https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&#34;&gt;https://www.youtube.com/watch?v=tShc0dyFtgw&amp;amp;t=2007s&lt;/a&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=7cWiwu7kYkE&#34;&gt;https://www.youtube.com/watch?v=7cWiwu7kYkE&lt;/a&gt;
&lt;a href=&#34;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&#34;&gt;http://likehui.top/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/gc-concurrent.png&#34; alt=&#34;gc-concurrent&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;基于-region-的并发收集模式&#34;&gt;基于 Region 的并发收集模式&lt;/h3&gt;
&lt;p&gt;ZGC 与 G1 类似，也是以 Region 划分堆内存结构的，不同的是，ZGC 中 Region 是以大小进行分组的，分别是 Small (2MB)、Medium (32MB)、Large (N*MB)，并且尚未进行分代。由于没有了分代，也就没有了 &lt;code&gt;CardTable&lt;/code&gt; 和 &lt;code&gt;RememberedSet&lt;/code&gt; 的开销。&lt;/p&gt;
&lt;h3 id=&#34;使用-numa架构技术httpsenwikipediaorgwikinon-uniform_memory_access高效的分配空间和进行对象的扫描&#34;&gt;使用 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Non-uniform_memory_access&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NUMA架构技术&lt;/a&gt;高效的分配空间和进行对象的扫描&lt;/h3&gt;
&lt;p&gt;利用 NUMA 架构的 CPU 亲和的内存分配策略，在分配对象时使用线程所处的节点缓存，使线程在操作自身创建的对象时提高效率。&lt;/p&gt;
&lt;h3 id=&#34;设计颜色指针标记对象状态保障引用关系一致&#34;&gt;设计颜色指针标记对象状态，保障引用关系一致&lt;/h3&gt;
&lt;p&gt;颜色指针就好比状态机，ZGC 在对象地址的其中 4bit 的空间用于标记&lt;code&gt;颜色&lt;/code&gt;状态，这四个字节分别称之 &lt;code&gt;Finalizable&lt;/code&gt;、 &lt;code&gt;Remapped&lt;/code&gt; 、&lt;code&gt;Marked1&lt;/code&gt;、 &lt;code&gt;Marked0&lt;/code&gt;，通过在不同的收集阶段对指定标记的状态检测，从而采取不同的执行动作。&lt;/p&gt;
&lt;p&gt;由于需要额外的空间来存储标记，因此不支持 32 位平台和指针压缩。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Makred0、 Marked1 用于识别对象在垃圾回收周期中是否被标记存活，存在两个的原因是因为一个被标记的对象可能来自上一个回收周期并未重新映射，此类对象则只需进行映射而无需重定位。&lt;/li&gt;
&lt;li&gt;Remapped 表明该引用对象需要从地址映射表中获取新地址并转移。&lt;/li&gt;
&lt;li&gt;Finalizable 表示这是一个 finalizar 对象，只有 Finalizer 可以对其进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体逻辑见 &lt;code&gt;hotspot/share/gc/z/zAddress.hpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.cpp&lt;/code&gt;、&lt;code&gt;hotspot/share/gc/z/zAddress.inline.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;利用-读屏障-修改引用来提高对象的整理迁移功能&#34;&gt;利用 读屏障 修改引用来提高对象的整理迁移功能&lt;/h3&gt;
&lt;p&gt;对比 G1 使用 &lt;code&gt;写屏障&lt;/code&gt; 来保证引用关系一致，ZGC 则是使用 &lt;code&gt;读屏障&lt;/code&gt; 来达到。&lt;/p&gt;
&lt;p&gt;在应用线程与 GC 线程同时操作同一对象时，通过读屏障检测对象状态，通过 CAS 对重映射对象进行迁移。&lt;/p&gt;
&lt;p&gt;这种设计使得无需暂停应用线程就能保证引用正确，而读屏障的性能开销只有约 4%。&lt;/p&gt;
&lt;h2 id=&#34;触发策略&#34;&gt;触发策略&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;hotspot/share/gc/z/zDirector.cpp&lt;/code&gt; 中可得知，ZGC 与其他 GC 的回收策略有所不同，是一种主动式的垃圾回收模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void ZDirector::run_service() {
  // Main loop
  while (_metronome.wait_for_tick()) {  // 1
    sample_allocation_rate();
    const GCCause::Cause cause = make_gc_decision(); // 2
    if (cause != GCCause::_no_gc) {
      ZCollectedHeap::heap()-&amp;gt;collect(cause);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;wait_for_tick&lt;/code&gt; 中，JVM 会利用时钟计算等待时间，当到达唤醒时间并且不在安全点期间则执行后续逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make_gc_decision&lt;/code&gt; 是根据条件返回回收策略，包含 4 种可执行垃圾回收的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;** 定时执行 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断当前时间距离上次垃圾回收的差值，当时间差值大于设定的间隔时间时则触发垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 内存预热 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据堆内存使用率判断是否进行垃圾回收，当每突破一个 10% 值时进行垃圾回收，例如超过 20%、30% 时。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 吞吐量过大 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对比剩余空间所需分配时间与最久 GC 时间差值，当大于指定间距时 (默认 0.1) 则说明存在空间不足分配的可能性，需要进行垃圾回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;** 主动触发 **&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当距离上次垃圾回收已经过了 5 分钟同时堆空间上涨了 10%，并且距离上次 GC 的时间大于最久 GC 时间的 49 倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当这些条件满足时 JVM 将会调用 Monitor (synchronized 底层线程安全模块) 唤醒线程，&lt;code&gt;异步&lt;/code&gt; 执行垃圾回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;回收过程&#34;&gt;回收过程&lt;/h2&gt;
&lt;p&gt;ZGC 的回收过程几乎是完全并发进行的，只会在三个阶段进行短短的暂停: 标记开始(mark-start)、标记结束(mark-final)、迁移开始(relocate-start)，具体流程可见于 &lt;code&gt;src/hotspot/share/gc/z/zDriver.cpp::run_gc_cycle()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/phases.png&#34; alt=&#34;zgc-phases&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;【标记开始】&lt;/strong&gt; 开始标记时，会暂停所有应用线程，标记出堆中的 
&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/gcroots.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GC Roots&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-start.png&#34; alt=&#34;mark-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发标记】&lt;/strong&gt; 释放应用线程，通过 GC Roots 遍历堆中所有对象，找出存活的对象集合 (类似一个 bitmap)。应用线程利用&lt;code&gt;读屏障&lt;/code&gt;将对象的变化信息保存于线程中，之后转交由 GC 线程处理引用关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-mark.png&#34; alt=&#34;concurrent-mark&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;【标记结束】&lt;/strong&gt; 完成所有对象的标记后，短时暂停应用线程，完成标记阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/mark-final.png&#34; alt=&#34;mark-final&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发准备】&lt;/strong&gt; 为下一阶段的重定位做准备，收集那些垃圾对象占比最大或最多的 page 加入 &lt;code&gt;relocate set&lt;/code&gt;，每个 page 都分配一个 &lt;code&gt;forwarding table&lt;/code&gt; 保存重定向地址，还进行一些其他数据的清理 (比如软弱虚引用、Finalizer 对象、字符串常量池、元数据)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/prepare.png&#34; alt=&#34;prepare&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;【迁移开始】&lt;/strong&gt; 暂停应用线程，扫描 GC Roots 的指向对象，对 &lt;code&gt;relocate set&lt;/code&gt; 内对象进行迁移并将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt;。将本地线程状态设置为 &lt;code&gt;bad mask&lt;/code&gt;，对应用线程内对迁移对象的引用标记为 &lt;code&gt;Remapped relocate&lt;/code&gt;。分配大块连续空间，以便能够存放要迁移的对象，申请一下阶段所需的工作线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/relocate-start.png&#34; alt=&#34;relocate-start&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;【并发迁移】&lt;/strong&gt; 对 &lt;code&gt;relocate set&lt;/code&gt; 中 page 里剩余的存活对象进行迁移，将重定位地址写入 &lt;code&gt;forwarding table&lt;/code&gt; 中。应用线程在操作 &lt;code&gt;Remapped relocate&lt;/code&gt; 对象时将通过读屏障进行重新映射地址，同时 GC线程 也对程序内的对象引用进行重映射。当映射地址与原地址一致时则表明所有引用均已重映射，标记 page 在之后清除释放空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://moyada.github.io/img/zgc/concurrent-relocate.png&#34; alt=&#34;concurrent-relocate&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如未重映射对象在下一垃圾回收周期也被标记，则该对象则不会进行分配重定位地址，为了达到这一区别所以才有了 &lt;code&gt;Makred0&lt;/code&gt;、 &lt;code&gt;Marked1&lt;/code&gt; 两个标记标识。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;停顿时间不会随着堆空间的大小增长，但是与 GC Root 的数量是成正比，而 GC Root 的数量则与应用线程的数量有关。
在 GC 的周期内，标记开始和迁移开始操作会比较花费时间，但所有停顿时间总共也是小于 10 毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Java GC过程</title>
      <link>https://moyada.github.io/post/jvm-gc/</link>
      <pubDate>Sun, 15 Jul 2018 12:06:05 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-gc/</guid>
      <description>&lt;p&gt;由于JVM分代设计，GC也根据原因不同而产生不同效果的GC，并且在Java的发展过程中根据不同的GC策略也有不同的过程实现。&lt;/p&gt;
&lt;h2 id=&#34;stop-the-world&#34;&gt;Stop-the-World&lt;/h2&gt;
&lt;p&gt;在 HotSpot 虚拟机中，Stop-the-World 也被称之为 safepoint，在此阶段内，所有运行 Java 代码与 JVM 交互的应用线程将会被挂起。&lt;/p&gt;
&lt;p&gt;以便在执行 GC 复制算法、栈上替换代码、JIT 去优化、清除 code cache、重定义 Class、偏向锁的去除、debug 操作等任务时保证数据的一致性。&lt;/p&gt;
&lt;h2 id=&#34;younggc&#34;&gt;YoungGC&lt;/h2&gt;
&lt;p&gt;发生在新生代的GC称为 &lt;code&gt;Young GC&lt;/code&gt;，也叫 YGC，是 JVM 运行过程中最频繁的GC。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;YoungGC 的产生原因主要是eden区内存不足以分配新对象或者剩余空间达到GC触发条件。
在发生 GC 时，虚拟机会将 &lt;code&gt;eden&lt;/code&gt; 区和 &lt;code&gt;survival from&lt;/code&gt; 区中存活的对象拷贝进 &lt;code&gt;survival to&lt;/code&gt; 区，清理其余对象。&lt;/p&gt;
&lt;h3 id=&#34;parnew&#34;&gt;ParNew&lt;/h3&gt;
&lt;p&gt;需要STW暂停，找出活跃对象，标记为 &lt;code&gt;reachable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;GC ROOTs&lt;/code&gt; 找出活跃的对象，还要根据 &lt;code&gt;CardTable&lt;/code&gt; 的 &lt;code&gt;Dirty&lt;/code&gt; 标记 (晋升至老年代，并且引用新生代对象) 找出老年代引用的新生代对象。&lt;/p&gt;
&lt;p&gt;首先检查老年代的连续可用空间是否可容纳存活对象，如果小于或者不允许担保失败，则需要进行 Full GC。&lt;/p&gt;
&lt;p&gt;检查空间足够则将存活对象进行复制，初始化 MarkWork，将根据年龄选择拷贝对象的目标空间。&lt;/p&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;大体步骤与ParNew类似，也需要 SWT 暂停。
不同的是，G1的 survivor 只有一个区域，并且使用 &lt;code&gt;RegionSet&lt;/code&gt; 来维护块之间的引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1存在一种 &lt;code&gt;Mixed GC&lt;/code&gt;，除了回收新生代之外，还会回收压缩部分老年代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;old-gc&#34;&gt;Old GC&lt;/h2&gt;
&lt;p&gt;属于老年代GC的统称，也叫 &lt;code&gt;Old GC&lt;/code&gt;，一般都是伴随着 &lt;code&gt;Young GC&lt;/code&gt; ，主要目的是释放老年代空间，并将相邻对象进行压缩，防止过多的内存碎片。&lt;/p&gt;
&lt;h3 id=&#34;原因及过程-1&#34;&gt;原因及过程&lt;/h3&gt;
&lt;p&gt;OldGC的产生原因为YoungGC所需的堆内存空间不足、方法区空间不足、堆内空间达到回收阀值，也有可能人为触发。
发生GC时，标记所有存活对象，可将存活对象进行压缩，对不再使用的类及其子类进行卸载，清理CodeCache，清理弱引用，常量池的清理。&lt;/p&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
暂停所有应用线程，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出老年代边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找所有可到达对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新标记
并发地对上一阶段中引用关系变化的对象进行再标记，然后再暂停应用线程，最后检查是否有发生引用变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发清理
对未标记的对象进行收集，释放空间至空闲列表，此阶段可能将卸载此类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发重置
重新计算堆空间，清理数据，为下一次 GC 周期做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&#34;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;p&gt;G1 的收集虽然也分为新生代和老年代，但在步骤上其实是有交叉的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记
需要暂停应用线程，标记出 &lt;code&gt;Roots&lt;/code&gt;，暂停时间较短，可能会根据 Region 优先级选择执行，从 &lt;code&gt;GC ROOTs&lt;/code&gt; 标记出边缘的存活对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根区域扫描
从标记的存活区域中查找出老年代的引用并进行标记，为了保证数据的正确，在下一次新生代 GC 可能发生之前此阶段必须完成.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记
根据标记对象进行扫描，查找出所有可到达对象，有可能被 &lt;code&gt;Young GC&lt;/code&gt; 打断。过程中还会涉及 &lt;code&gt;SATB&lt;/code&gt;，记录引用关系变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次标记
需要 STW，将上一阶段中引用关系发生变化的对象进行再标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清理
整理对象、更新 &lt;code&gt;RSets&lt;/code&gt; 和将部分老年代加入下次回收周期，需要暂停应用线程，对于清空 Region 加入空闲列表的操作可以并发进行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&#34;&gt;https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html&lt;/a&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&#34;&gt;https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;full-gc&#34;&gt;Full GC&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Full GC&lt;/code&gt; 是对整个堆进行清理的回收算法，包括新生代和老年代。&lt;/p&gt;
&lt;p&gt;在 CMS 中可指定使用并发的 &lt;code&gt;Full GC&lt;/code&gt;，在 JDK10 中 G1 对 &lt;code&gt;Full GC&lt;/code&gt; 也改进为了并发模式。&lt;/p&gt;
&lt;p&gt;除手动触发因素外，&lt;code&gt;Full GC&lt;/code&gt; 的产生通常是由老年代空间不足、方法区空间不足所引起。&lt;/p&gt;
&lt;p&gt;所有的垃圾回收算法都会在 Full GC 时暂停应用线程，因此在对延迟要求高的程序中，Full GC 是应该尽力避免的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM 参数</title>
      <link>https://moyada.github.io/post/jvm-param/</link>
      <pubDate>Tue, 24 Apr 2018 21:25:44 +0000</pubDate>
      <guid>https://moyada.github.io/post/jvm-param/</guid>
      <description>&lt;style&gt;
table th:nth-of-type(1) {
    width: 250px;
}

table th:nth-of-type(2) {
    width: 30px;
}

table th:nth-of-type(3) {
    width: 300px;
}

table th:nth-of-type(4) {
    width: 150px;
}
&lt;/style&gt;
&lt;h2 id=&#34;空间&#34;&gt;空间&lt;/h2&gt;
&lt;h3 id=&#34;通用&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xms&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 初始化的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmx&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xmn&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;新生代的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 GC 下建议不设置该参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xss&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;线程栈的大小，默认 1M&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxDirectMemorySize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 NIO 的直接缓存最大容量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SurvivorRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Eden 和 Survior(from和to) 大小比例，默认是 8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:AutoBoxCacheMax=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置自动装箱池缓存大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;server模式专有&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveGCBoundary&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态化使用资源&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态调整各个代区的内存大小，每次 minor gc 后会重新计算 eden，from 和 to 的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的初始大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxNewSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NewRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代和老年代的比例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.noInflation=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时是否使用代理类&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dsun.reflect.inflationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;反射时生成代理类调用的次数，之后使用 JNI 字节码调用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRAM=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinRAMFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置最大内存除数，默认为 4，即堆空间内 MaxRAM 的四分之一&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErgoHeapSizeLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;限制堆内存上限&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之前&#34;&gt;Java8之前&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxPermSize&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法区的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java8之后&#34;&gt;Java8之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxMetaspaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;元空间的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 后新增，初始大小是 21M&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;java9之后&#34;&gt;Java9之后&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapRegionSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个区域块大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1M-32M 之间,必须是2的幂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1NewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最小值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MaxNewSizePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代大小占堆的最大值百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 60%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;
&lt;h3 id=&#34;通用-1&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-server&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;虚拟机会以 server 模式运行，该模式与 C2 编译器共同运行，更注重编译的质量，启动速度慢，但是运行效率高，适合用在服务器环境下，针对生产环境进行了优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysPreTouch&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JVM 启动时就会先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过快速对象分配模式在 TLAB（Thread-local allocation buffers）中进行分配对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以避免大量的线程通信所导致的性能下降&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TLABSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 TLAB 的初始化大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-ResizeTLAB&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用自动调整 TLAB&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseLargePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用最大值内存页&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseTransparentHugePages&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对大对象分配使用大内存页分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要 Linux kernel &amp;gt;= 4.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseNUMA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对象分配优先使用 NUMA 本地内存&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PerfDisableSharedMem&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 日志指向 /dev/shm，避免 IO 造成的 JVM 停顿&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShowHiddenFrames&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;展示虚拟机隐藏的栈信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ObjectAlignmentInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 java 对象的内存对齐，默认是 8 字节，指定的值必须是 2 的幂次，且必须在 8 和 256 之间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PageAlignDirectMemory&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置堆外内存使用内存对齐&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedOops&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 64 位环境下，压缩对象头&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastAccessorMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;原始类型的快速优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastEmptyMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;空方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseFastJNIAccessors&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用类或 int 的成员方法优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LargePageSizeInBytes=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Heap 中内存页的最大值，参数必须是 2 的幂，不可设置过大&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseBiasedLocking&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用偏向锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在存在大量锁对象的创建并高度并发的环境下禁用偏向锁能够带来一定的性能优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:BiasedLockingStartupDelay=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;延迟(秒钟)启用偏向锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XXtlaSize:min=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;,preferred=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;调整 TLA，每个线程私有的空间的默认最小大小和默认首选大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AlwaysAtomicAccesses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;实现对所有 Access 的原子性保证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启标量替换&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DoEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;进行逃逸分析之后，创建的可分解的对象都将由栈上分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;标量替换，栈上分配，受限于栈的空间大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEscapeAnalysis&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看逃逸分析结果&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EliminateLocks&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分析并且消除无线程竞争下的锁&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同步消除，必须开启 -XX:+DoEscapeAnalysis 和 -server 模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintEliminateAllocations&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;查看标量的替换情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;max number of live nodes in a method&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PositiveIdentityHash&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只允许分配正数的哈希值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+EnableJVMCI&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用 Graal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseJVMCICompiler&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Graal JIT编译器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TieredCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用分层编译策略，根据编译器编译、优化的规模与耗时，划分出不同的编译层次&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java8 默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:TieredStopAtLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JIT 编译的最高层级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCodeCacheFlushing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当代码缓存被填满时让 JVM 放弃一些编译代码&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitialCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置初始代码缓存的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ReservedCodeCacheSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置代码缓存的最大值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompileThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发标准的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InterpreterBackwardBranchLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当某个方法被调用 + 循环次数累计超过该值时，触发 OSR 形式的 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HugeMethodLimit=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;JIT 编译字节码大小超过 size 字节的方法就是巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DontCompileHugeMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不编译巨型方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-UseCounterDecay&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止 JIT 调用计数器衰减&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CompileCommand=&lt;code&gt;command,method[,option]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定制编译需求，比如过滤某个方法不做 JIT 编译&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+InlineSynchronizedMethods&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对同步方法进行内联&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行方法内联前，方法的最多嵌套调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 325&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTrivialSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;归属于不重要的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinInliningThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法被内联的最小调用次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 250&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxRecursiveInlineLevel=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对方法的递归调用做内联优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1MaxInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:Tier1FreqInlineSize=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1层内联 &lt;code&gt;频繁执行&lt;/code&gt; 的方法的最大字节码大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:LiveNodeCountInliningCutoff=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;方法内最大存活的 JIT IR 节点数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认为 20000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ActiveProcessorCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 jvm 使用 cpu 个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseContainerSupport&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;支持容器化功能，默认开启&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCGroupMemoryLimitForHeap&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 CGroup Namespace&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk10 后废弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;gc&#34;&gt;GC&lt;/h2&gt;
&lt;h3 id=&#34;通用-2&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCompressedClassPointers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启压缩类指针&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64 位平台上默认打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParNewGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置年轻代为多线程收集&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以和 CMS GC 一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ParallelRefProcEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并行的处理对象标记过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定并行处理 GC 的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认 GC 线程数为 CPU 的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParGCCardsPerStrideChunk=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每个线程每次扫描的 Card 数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CardTable 用来标记老年代的某一块内存区域中的对象是否持有新生代对象的引用,卡表的数量取决于老年代的大小和每张卡对应的内存大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MinHeapFreeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定堆内存在使用率以下进行收缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisableExplicitGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁止代码中显示调用 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CMS 下可使用 -XX:+ExplicitGCInvokesConcurrent 替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+GCLockerInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的执行 GC Lock&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ConcGCThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置并行GC的线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxTenuringThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置新生代经过多少次YGC晋升到老生代&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:PretenureSizeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;晋升老年代对象年龄&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无默认值，Paralle Scavenge收集器无法识别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CompressedClassSpaceSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置指针压缩空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+OptimizeStringConcat&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;字符串concat优化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseParallelGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;选择垃圾收集器为并行收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能和 CMS GC 一起使用,系统吨吐量优先&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCTimeRatio=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置吞吐量大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:SoftRefLRUPolicyMSPerMB=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每兆空间中软引用的生命周期 (多少毫秒后清除)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xnoclassgc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不对 Class 元数据进行 GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseConcMarkSweepGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启用 CMS 低停顿垃圾收集器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelRemarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启并行标记&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;命令JVM无论什么时候调用系统 GC，都执行 CMS GC，而不是 Full GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ExplicitGCInvokesConcurrent &lt;br/&gt; AndUnloadsClasses&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;保证当有系统 GC 调用时，永久代也被包括进 CMS 垃圾回收的范围内&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSConcurrentMTEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;并发的 CMS 阶段将以多线程执行&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSParallelInitialMarkEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启初始标记过程中的并行化&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ParallelCMSThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设定 CMS 的线程数量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 老年代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSInitiatingPermOccupancyFraction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 CMS 永久代在对内存占用率达到多少百分比的时候开始GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只使用 CMSInitiatingOccupancyFraction 设置的回收阈值，否则交由 JVM 动态调整&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSTriggerRatio&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 CMSInitiatingOccupancyFraction 错误时的生成策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSScavengeBeforeRemark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;重新标记之前对年轻代做一次 Minor GC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+CMSClassUnloadingEnabled&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 &lt;code&gt;CMS GC&lt;/code&gt; 时对永久代进行垃圾回收(类卸载)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 时会扫描 MetaSpace/PermGen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:CMSFullGCsBeforeCompaction=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定进行多少次Full GC之后，执行内存空间整理&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:UseCMSCompactAtFullCollection&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 Full GC 的时候，对年老代的压缩&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能会影响性能，但是可以消除碎片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseG1GC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用G1垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:InitiatingHeapOccupancyPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发并发标记周期时的堆内存占用率阈值. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;值为 0 则表示一直执行 GC 循环，默认值为 45&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1UseAdaptiveIHOP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启自适应并发标记控制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ConcRefinementThreads=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 Remenbered Set 的工作线程数目&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:MaxGCPauseMillis=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置每次年轻代垃圾回收的最长时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseStringDeduplication&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用字符串去重机制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 收集器下生效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCLiveThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动混合垃圾回收周期的老年代占用率阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认占用率为 65%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1HeapWastePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置允许浪费的堆百分比，如果触发回收百分比小于该百分比，JVM 则不会启动混合垃圾回收周期&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1MixedGCCountTarget=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置标记周期完成后，执行混合垃圾回收老年代的目标次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1OldCSetRegionThresholdPercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置混合垃圾回收期间要回收的最大旧区域数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 Java 堆的 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1ReservePercent=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置作为预留存活区在 heap 中的百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认值是 10%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeConcMark&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1PrintHeapRegions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 G1 收集器收集的区域&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1SummarizeRSetStats&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印标记过程引用信息(Print RSet processing information)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1SummarizeRSetStatsPeriod=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 GC 周期频率报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-G1EagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;禁用 G1 优先尝试回收大对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1TraceEagerReclaimHumongousObjects&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;G1 在每个 &lt;code&gt;Young GG&lt;/code&gt; 周期都会回收消亡的 Humongous 对象&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;默认开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+G1ConcRegionFreeingVerbose&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Debug JVM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;zgc&#34;&gt;ZGC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseZGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 ZGC 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java11，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/zgc/Main&#34;&gt;https://wiki.openjdk.java.net/display/zgc/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;shenandoah-gc&#34;&gt;Shenandoah GC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseShenandoahGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;启动 Shenandoah 垃圾回收器&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;jdk12，非正式版本需开启 &lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt; 解锁参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahInitFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置触发垃圾回收的初始阈值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahMinFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无条件触发垃圾回收的最小空间阀值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocSpikeFactor=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置预留堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahGarbageThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置一个 Region 被视为 &lt;code&gt;可回收&lt;/code&gt; 的垃圾对象所需百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahFreeThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置启动垃圾回收的空闲堆空间百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahAllocationThreshold=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置上一次垃圾回收周期的分配内存百分比&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahPacing&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;根据垃圾回收效率分配应用程序的线程与可用空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ShenandoahPacingMaxDelay=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在最大延迟时间之前，将不干预应用程序的分配&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahDegeneratedGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当程序遇到分配失败时，Shenandoah 将会暂停应用线程，直到完成后续垃圾回收工作&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerify&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;检测垃圾回收异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahGCHeuristics=[ passive | aggressive ]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;暂停应用线程执行垃圾回收 或 执行紧凑的垃圾回收并疏散所有非空 Region&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+ShenandoahVerifyOptoBarriers&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;验证 C2 模式&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.openjdk.java.net/display/shenandoah/Main&#34;&gt;https://wiki.openjdk.java.net/display/shenandoah/Main&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;&lt;big&gt;&lt;b&gt;Java9之后&lt;/b&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;jvm日志使用 &lt;code&gt;-Xlog[&amp;lt;what&amp;gt;][:[&amp;lt;output&amp;gt;][:[&amp;lt;decorators&amp;gt;][:&amp;lt;output-options&amp;gt;]]]&lt;/code&gt; 记录
可以使用 &lt;code&gt;java -Xlog:help&lt;/code&gt; 查看帮助文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;-Xlog:disable -Xlog:gc+liveness=info,rt*=off:file=../logs/gc_%t.log:time,uptimemillis,pid:filecount=5,filesize=1024
先关闭所有日志，打开 gc 和存活对象的日志，关闭包含 rt 的日志级别，输出日志至文件，额外包含时间、耗时、进程 id，以 5 个 1M 的文件循环保存历史日志文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考:
&lt;a href=&#34;http://www.cnblogs.com/IcanFixIt/p/7259712.html&#34;&gt;http://www.cnblogs.com/IcanFixIt/p/7259712.html&lt;/a&gt;
&lt;a href=&#34;https://juejin.im/post/5a981f056fb9a028bf04bec4&#34;&gt;https://juejin.im/post/5a981f056fb9a028bf04bec4&lt;/a&gt;
&lt;a href=&#34;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&#34;&gt;https://blog.gceasy.io/2017/10/17/43-gc-logging-flags-removed-in-java-9/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://openjdk.java.net/jeps/158&#34;&gt;http://openjdk.java.net/jeps/158&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用-3&#34;&gt;通用&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Xloggc=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志文件&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如 -Xloggc=/data/application/logs/gc.log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+verbosegc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印每次GC的消息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCCause&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 GC 的原因&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDetails&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印GC日志详情&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;建议开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCTimeStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以基准时间的形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCDateStamps&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出GC的时间戳&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;以日期的形式，如 2013-05-04T21:53:59.234+0800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:ErrorFile=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 JVM 出现致命错误时，生成错误文件，包括了导致 jvm crash 的重要信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationStoppedTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 的停顿时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintGCApplicationConcurrentTime&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 在两次停顿之间的正常运行时间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 OutOfMemoryError 时拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpBeforeFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 前拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+HeapDumpAfterFullGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;遇到 Full GC 后拍摄一个&lt;code&gt;堆转储快照&lt;/code&gt;，并将其保存在一个文件中。&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:HeapDumpPath=&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定导出堆的存放路径&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:-OmitStackTraceInFastThrow&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;要求 JVM 始终抛出含堆栈的异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UseGCLogFileRotation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启日志文件的循环&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NumberOfGCLogfiles=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;配置日志循环文件个数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:GCLogfileSize=&lt;code&gt;&amp;lt;size&amp;gt;&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定日志文件大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:NativeMemoryTracking=[off | summary | detail]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;
&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看 JVM 本地方法使用情况&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;p&gt;jcmd &lt;pid&gt; VM.native_memory [summary &amp;amp;##124; detail &amp;amp;##124; baseline &amp;amp;##124; summary.diff &amp;amp;##124; detail.diff &amp;amp;##124; shutdown] [scale= KB &amp;amp;##124; MB &amp;amp;##124; GB] &lt;p/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintNMTStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在 JVM 退出时打印 NMT 报告&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:class&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在程序运行的时候有多少类被加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;verbose:class 来监视 java -verbose:class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:gc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在虚拟机发生内存回收时在输出设备显示信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-verbose:jni&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 native 方法调用的相关情况&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintHeapAtGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在进行 GC 的前后打印出堆的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsInitial&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示所有可设置参数及默认值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFlagsFinal&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示可以获取到所有设置后参数及值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockDiagnosticVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁对 JVM 进行诊断的选项参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCommandLineFlags&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;显示出 JVM 初始化完毕后所有跟最初的默认值不同的参数及它们的值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintTenuringDistribution&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内存模型各代信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+DisplayVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印 JVM 输出&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogVMOutput&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;记录 JVM 输出到日志&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintJNIGCStalls&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印进入临界区 (JVM 传向 JNI) 的线程信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintFLSStatistics=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GC 前后输出内存的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当 &lt;code&gt;size &amp;gt; 1&lt;/code&gt; 时还会输出 IndexedFreeLists 统计信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintSafepointStatisticsCount=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 safepoint 的统计次数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAdaptiveSizePolicy&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印自适应收集的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintReferenceGC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;跟踪系统内的软引用,弱引用,虚引用和 finallize 队列&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintClassHistogram&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印出实例的数量以及空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;jit-1&#34;&gt;JIT&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInlining&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印内联优化的方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;简单的输出一些关于从字节码转化成本地代码的编译过程&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCompilation&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;输出 JIT 的编译信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;通过使用外部的 disassembler.so 库打印汇编的字节码和 native 方法来辅助分析&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要和-XX:UnlockDiagnosticVMOptions一起使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassLoading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的加载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+TraceClassUnloading&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;动态跟踪类的卸载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintInterpreter&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印解释过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;exclude，跳过编译指定的方法; compileonly，只编译指定的方法; inline/dontinline，设置是否内联指定方法; print，打印生成的汇编代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintAssembly&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印JIT编译过程中生成的汇编指令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无法使用该参数可以用 -XX:+PrintOptoAssembly 来代替&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;g1-1&#34;&gt;G1&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:G1LogLevel=fine, finer, finest&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;日志包含信息以及每个工作线程的信息&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+PrintStringDeduplicationStatistics&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;打印字符串去重的影响&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;常用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;说明&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否支持远程 JMX 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定远程监控端口号，随机分配 RMI 端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.ssl=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否对连接开启 SSL 加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.authenticate=&lt;code&gt;&amp;lt;boolean&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否需要开启用户认证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Dcom.sun.management.jmxremote.rmi.port=&lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 与远程监控端口号&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.rmi.server.hostname=&lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;指定 RMI 服务的对应主机名&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.net.preferIPv4Stack=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;优先使用 IPv4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.security.egd=file:/dev/./urandom&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;●&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用非阻塞的随机数与熵池策略&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.util.concurrent.ForkJoinPool.common.parallelism=&lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;修改 ForkJoinPool 的默认线程数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockExperimentalVMOptions&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 实验性参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+UnlockCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;解锁 JVM 商业特性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+LogCommercialFeatures&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;对商业特性进行日志记录&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+FlightRecorder&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 JFR 监控&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:FlightRecorderOptions=&lt;code&gt;&amp;lt;parameter&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置 JFR 监控参数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生不可恢复的错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:OnOutOfMemoryError=&lt;code&gt;command&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;设置当发生内存溢出错误时执行的命令&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-XX:+AggressiveOpts&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用预设的优化參數&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;-Djava.awt.headless=true&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用计算能力模拟外设功能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;例如创建图片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>
