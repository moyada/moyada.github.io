[{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://moyada.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"薛毅康","type":"authors"},{"authors":[],"categories":[],"content":"a b ","date":1584789963,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584789963,"objectID":"1d72cff56cf19358564ac7ef9b2d0bfc","permalink":"https://moyada.github.io/test/demo/","publishdate":"2020-03-21T19:26:03+08:00","relpermalink":"/test/demo/","section":"test","summary":"a b ","tags":[],"title":"Demo","type":"docs"},{"authors":[],"categories":[],"content":"","date":1584780297,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584780297,"objectID":"1f8a418ab45271a95628640ee04867cd","permalink":"https://moyada.github.io/test/test/","publishdate":"2020-03-21T16:44:57+08:00","relpermalink":"/test/test/","section":"test","summary":"","tags":[],"title":"Test","type":"test"},{"authors":[],"categories":[],"content":"由于JVM分代设计，GC也根据原因不同而产生不同效果的GC，并且在Java的发展过程中根据不同的GC策略也有不同的过程实现。\nStop-the-World 在 HotSpot 虚拟机中，Stop-the-World 也被称之为 safepoint，在此阶段内，所有运行 Java 代码与 JVM 交互的应用线程将会被挂起。\n以便在执行 GC 复制算法、栈上替换代码、JIT 去优化、清除 code cache、重定义 Class、偏向锁的去除、debug 操作等任务时保证数据的一致性。\nYoungGC 发生在新生代的GC称为 Young GC，也叫 YGC，是 JVM 运行过程中最频繁的GC。\n原因及过程 YoungGC 的产生原因主要是eden区内存不足以分配新对象或者剩余空间达到GC触发条件。 在发生 GC 时，虚拟机会将 eden 区和 survival from 区中存活的对象拷贝进 survival to 区，清理其余对象。\nParNew 需要STW暂停，找出活跃对象，标记为 reachable。\n从 GC ROOTs 找出活跃的对象，还要根据 CardTable 的 Dirty 标记 (晋升至老年代，并且引用新生代对象) 找出老年代引用的新生代对象。\n首先检查老年代的连续可用空间是否可容纳存活对象，如果小于或者不允许担保失败，则需要进行 Full GC。\n检查空间足够则将存活对象进行复制，初始化 MarkWork，将根据年龄选择拷贝对象的目标空间。\nG1 大体步骤与ParNew类似，也需要 SWT 暂停。 不同的是，G1的 survivor 只有一个区域，并且使用 RegionSet 来维护块之间的引用。\n G1存在一种 Mixed GC，除了回收新生代之外，还会回收压缩部分老年代。\n Old GC 属于老年代GC的统称，也叫 Old GC，一般都是伴随着 Young GC ，主要目的是释放老年代空间，并将相邻对象进行压缩，防止过多的内存碎片。\n原因及过程 OldGC的产生原因为YoungGC所需的堆内存空间不足、方法区空间不足、堆内空间达到回收阀值，也有可能人为触发。 发生GC时，标记所有存活对象，可将存活对象进行压缩，对不再使用的类及其子类进行卸载，清理CodeCache，清理弱引用，常量池的清理。\nCMS   初始标记 暂停所有应用线程，从 GC ROOTs 标记出老年代边缘的存活对象。\n  并发标记 根据标记对象进行扫描，查找所有可到达对象。\n  重新标记 并发地对上一阶段中引用关系变化的对象进行再标记，然后再暂停应用线程，最后检查是否有发生引用变化。\n  并发清理 对未标记的对象进行收集，释放空间至空闲列表，此阶段可能将卸载此类。\n  并发重置 重新计算堆空间，清理数据，为下一次 GC 周期做准备。\n   https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ\n G1 G1 的收集虽然也分为新生代和老年代，但在步骤上其实是有交叉的地方\n  初始标记 需要暂停应用线程，标记出 Roots，暂停时间较短，可能会根据 Region 优先级选择执行，从 GC ROOTs 标记出边缘的存活对象。\n  根区域扫描 从标记的存活区域中查找出老年代的引用并进行标记，为了保证数据的正确，在下一次新生代 GC 可能发生之前此阶段必须完成.\n  并发标记 根据标记对象进行扫描，查找出所有可到达对象，有可能被 Young GC 打断。过程中还会涉及 SATB，记录引用关系变化。\n  再次标记 需要 STW，将上一阶段中引用关系发生变化的对象进行再标记。\n  清理 整理对象、更新 RSets 和将部分老年代加入下次回收周期，需要暂停应用线程，对于清空 Region 加入空闲列表的操作可以并发进行。\n   https://www.oracle.com/technetwork/articles/java/g1gc-1984535.html https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-F1BE86FA-3EDC-4D4F-BDB4-4B044AD83180\n Full GC Full GC 是对整个堆进行清理的回收算法，包括新生代和老年代。\n在 CMS 中可指定使用并发的 Full GC，在 JDK10 中 G1 对 Full GC 也改进为了并发模式。\n除手动触发因素外，Full GC 的产生通常是由老年代空间不足、方法区空间不足所引起。\n所有的垃圾回收算法都会在 Full GC 时暂停应用线程，因此在对延迟要求高的程序中，Full GC 是应该尽力避免的。\n","date":1531656365,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1531656365,"objectID":"cf27dc5282cc5045bcdb73ea719bcf95","permalink":"https://moyada.github.io/post/jvm-gc/","publishdate":"2018-07-15T12:06:05Z","relpermalink":"/post/jvm-gc/","section":"post","summary":"由于JVM分代设计，GC也根据原因不同而产生不同效果的GC，并且在Java的发展过程中根据不同的GC策略也有不同的过程实现。\nStop-the-World 在 HotSpot 虚拟机中，Stop-the-World 也被称之为 safepoint，在此阶段内，所有运行 Java 代码与 JVM 交互的应用线程将会被挂起。\n以便在执行 GC 复制算法、栈上替换代码、JIT 去优化、清除 code cache、重定义 Class、偏向锁的去除、debug 操作等任务时保证数据的一致性。\nYoungGC 发生在新生代的GC称为 Young GC，也叫 YGC，是 JVM 运行过程中最频繁的GC。\n原因及过程 YoungGC 的产生原因主要是eden区内存不足以分配新对象或者剩余空间达到GC触发条件。 在发生 GC 时，虚拟机会将 eden 区和 survival from 区中存活的对象拷贝进 survival to 区，清理其余对象。","tags":["jvm","gc"],"title":"Java GC过程","type":"post"},{"authors":[],"categories":[],"content":"单机环境下有著名的 ACID理论，但是对于现代互联网下的分布式环境 ACID 就无能为力了。 所以，随着分布式系统的发展，一套针对分布式环境下 CAP定理 也随之产生。\nCAP 定理 CAP 定理是分布式计算领域公认的理论，所关心的是在互相连通和共享数据的多节点环境下的数据读写操作，主要可分为 C、A、P 三点。\n一般分布式环境下是无法保证 C、A、P 三个要素都满足，需依据业务进行取舍。\n一致性 (Consistence) 要求各节点之间读取的数据一致，必须保证 client 能够查看到所写的数据变化，即 读己之所写。\n 由于节点之间数据同步存在时差，并不强要求同一时刻数据的 强一致性，但需保证 最终一致性。\n 可用性 (Availability) 即为非故障节点能够返回合理的数据，不能是错误或者超时。\n 由于无法保障强一致性，故不要求数据的正确性，即在合理范围内则可。\n 分区容错性 (Partition Tolerance) 要求由于拥塞、丢包、中断、超时等故障造成 网络分区时，系统各节点能够正常服务。\n思考 在实际中，节点之间网络状况无法做到 100% 可靠，即 CAP 三者中的P是必须考虑的。\n而 CA 在理论上是无法同时满足的，即当出现网络分区时，为了保证数据 一致性，系统应不允许写入，则无法保证 可用性。\n因此，在考虑设计分布式架构时，一般选择 CP 或 AP 架构，具体设计时需要考虑业务特性。\nBASE理论 BASE 理论是对 CAP 定理的延伸和补充，在 AP 方案的基础上进行平衡，保证一定时间内最终达到 C 的要素。\n基本可用 (Basically Available) 在系统故障时，能保证核心功能可用。\n软状态 (Soft Status) 允许数据不一致情况，但要求该中间数据不会影响整理系统的可用性。\n最终一致性 (Eventual Consistency) 即要求在一定时间后达到各节点的数据一致，属于特殊的 弱一致性。\n https://www.cnblogs.com/nucdy/p/7483108.html http://xinklabi.iteye.com/blog/2341034\n ","date":1530971061,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1530971061,"objectID":"fd04318bbe01924861ff9d74e7050770","permalink":"https://moyada.github.io/bak/cap-base/","publishdate":"2018-07-07T13:44:21Z","relpermalink":"/bak/cap-base/","section":"bak","summary":"单机环境下有著名的 ACID理论，但是对于现代互联网下的分布式环境 ACID 就无能为力了。 所以，随着分布式系统的发展，一套针对分布式环境下 CAP定理 也随之产生。\nCAP 定理 CAP 定理是分布式计算领域公认的理论，所关心的是在互相连通和共享数据的多节点环境下的数据读写操作，主要可分为 C、A、P 三点。\n一般分布式环境下是无法保证 C、A、P 三个要素都满足，需依据业务进行取舍。\n一致性 (Consistence) 要求各节点之间读取的数据一致，必须保证 client 能够查看到所写的数据变化，即 读己之所写。\n 由于节点之间数据同步存在时差，并不强要求同一时刻数据的 强一致性，但需保证 最终一致性。\n 可用性 (Availability) 即为非故障节点能够返回合理的数据，不能是错误或者超时。","tags":[],"title":"CAP定理和BASE理论","type":"bak"}]